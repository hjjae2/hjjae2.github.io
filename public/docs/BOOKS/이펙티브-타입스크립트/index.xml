<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>이펙티브 타입스크립트 on thisandthat</title>
    <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/</link>
    <description>Recent content in 이펙티브 타입스크립트 on thisandthat</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-01.-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%99%80-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-%EA%B4%80%EA%B3%84-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-01.-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%99%80-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-%EA%B4%80%EA%B3%84-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/</guid>
      <description>&amp;quot; 타입스크립트는 인터프리터 언어로 실행되는 것도 아니고, (Java, C 같이)저수준 언어로 컴파일 되는 것도 아닙니다. 또 다른 고수준 언어인 &amp;lsquo;자바스크립트&amp;rsquo;로 컴파일되며, 실행 역시 타입스크립트가 아닌 자바스크립트로 이루어집니다. 그래서 타입스크립트와 자바스크립트의 관계는 필연적이며, 이 밀접한 관계 때문에 혼란스러운 일이 벌어지기도 합니다. &amp;quot; (1장 소개말 중)
아이템 1. 타입스크립트와 자바스크립트의 관계 이해하기 # 타입스크립트는 자바스크립트의 상위 집합 모든 &amp;lsquo;자바스크립트&amp;rsquo; 는 &amp;lsquo;타입스크립트&amp;rsquo; 이다. (참) 모든 &amp;lsquo;타입스크립트&amp;rsquo; 는 &amp;lsquo;자바스크립트&amp;rsquo; 이다. (거짓) 타입스크립트 중에는 자바스크립트가 아닌 프로그램이 존재한다고 한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-02.-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%84%A4%EC%A0%95-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-02.-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%84%A4%EC%A0%95-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/</guid>
      <description>아이템 2. 타입스크립트 설정 이해하기 # 타입스크립트 컴파일러(타입 체커)는 매우 많은 설정을 가지고 있다.
설정 방법 예시 커맨드 라인 (cli) tsc --noImplicitAny program.ts 파일 (file) tsconfig.json 참고 : tsc --init 통해 파일 생성 가능하다. 중요/권장 설정 : noImplicitAny
타입을 미리 정의하여 사용할 것인지 설정하는 것
값 설명 true 타입을 미리 정의해야 한다. 타입스크립트는 타입 정보를 설정/체크할 때 가장 효과적이기 때문에, 되도록 true 설정을 권장한다. false (기존 자바스크립트와 같이) 타입을 미리 정의하지 않아도 된다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-03.-%EC%BD%94%EB%93%9C-%EC%83%9D%EC%84%B1%EA%B3%BC-%ED%83%80%EC%9E%85%EC%9D%B4-%EA%B4%80%EA%B3%84%EC%97%86%EC%9D%8C%EC%9D%84-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-03.-%EC%BD%94%EB%93%9C-%EC%83%9D%EC%84%B1%EA%B3%BC-%ED%83%80%EC%9E%85%EC%9D%B4-%EA%B4%80%EA%B3%84%EC%97%86%EC%9D%8C%EC%9D%84-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/</guid>
      <description>아이템 3. 코드 생성과 타입이 관계없음을 이해하기 # 타입스크립트는 두 가지 역할(트랜스파일, 컴파일)을 수행한다. # 1. 최신 타입스크립트/자바스크립트를 (브라우저에서 동작할 수 있도록) 구버전의 자바스크립트로 트랜스파일(transpile)한다. 2. 코드의 타입 오류를 체크한다.
트랜스파일, 타입 체크는 완벽히 독립적이다. 트랜스파일이 잘못되어도 타입 체크는 실행될 수 있다. 타입 체크가 잘못되어도 트랜스파일은 실행될 수 있다. 타입 오류가 있는 코드도 컴파일(트랜스파일)이 가능하다. # » cat test.ts let x = &amp;#39;hello&amp;#39;; x = 1234; » tsc test.ts test.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-04.-%EA%B5%AC%EC%A1%B0%EC%A0%81-%ED%83%80%EC%9D%B4%ED%95%91%EC%97%90-%EC%9D%B5%EC%88%99%ED%95%B4%EC%A7%80%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-04.-%EA%B5%AC%EC%A1%B0%EC%A0%81-%ED%83%80%EC%9D%B4%ED%95%91%EC%97%90-%EC%9D%B5%EC%88%99%ED%95%B4%EC%A7%80%EA%B8%B0/</guid>
      <description>아이템 4. 구조적 타이핑에 익숙해지기 # 자바스크립트는 본질적으로 &amp;lsquo;덕 타이핑(duck typing)&amp;rsquo; 기반이다. # 덕타이핑이란? 어떤 값에 필요한 속성, 메서드가 존재한다면 그냥 사용하는 것을 의미한다.
타입스크립트는 자바스크립트의 런타임 동작을 모델링한다. 덕타이핑을 모델링하기 위해 &amp;lsquo;구조적 타이핑&amp;rsquo; 기법을 사용한다. (올바른 표현인가&amp;hellip;?)
interface Vector2D { x: number; y: number; } interface NamedVector2D { name: string; x: number; y: number; } function calculateLength(v: Vector2D) { return Math.sqrt(v.x * v.x + v.y * v.y); } » tsc example.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-05.-any-%ED%83%80%EC%9E%85-%EC%A7%80%EC%96%91%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-05.-any-%ED%83%80%EC%9E%85-%EC%A7%80%EC%96%91%ED%95%98%EA%B8%B0/</guid>
      <description>아이템 5. any 타입 지양하기 # 타입스크립트 타입 시스템은 &amp;lsquo;점진적(gradual)&amp;rsquo;, &amp;lsquo;선택적(optional)&amp;rsquo; 이다.
점진적 : 코드에 타입을 조금씩 추가할 수 있다. 선택적 : 언제든지 타입 체킹을 해제할 수 있다. 이 기능의 핵심은 &amp;lsquo;any&amp;rsquo; 타입이다.
하지만 (일부 특별한 경우를 제외하고는) any 를 사용하지 않는 것을 권장한다.
any 타입에는 &amp;lsquo;타입 안정성&amp;rsquo;이 없다. # 예시 : any 사용 X
let age: number; age = &amp;#39;12&amp;#39;; // 에러 발생 (error TS2322: Type &amp;#39;string&amp;#39; is not assignable to type &amp;#39;number&amp;#39;.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-06.-%ED%8E%B8%EC%A7%91%EA%B8%B0%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%ED%83%80%EC%9E%85-%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%83%90%EC%83%89%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-06.-%ED%8E%B8%EC%A7%91%EA%B8%B0%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%ED%83%80%EC%9E%85-%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%83%90%EC%83%89%ED%95%98%EA%B8%B0/</guid>
      <description>아이템 6. 편집기를 사용하여 타입 시스템 탐색하기 # 타입스크립트 설치 시, 다음 두 가지를 실행할 수 있다.
타입스크립트 컴파일러 : tsc 타입스크립트 서버 : tsserver &amp;quot; 보통은 타입스크립트 컴파일러를 실행하는 것이 주된 목적이지만, 타입스크립트 서버 또한 &amp;lsquo;언어 서비스&amp;rsquo;를 제공한다는 점에서 중요합니다. &amp;ldquo;
여기서 말하는 &amp;lsquo;언어 서비스&amp;rsquo;란? 자동 완성, 검색, 검사, 리팩터링 등을 의미한다. (예를 들면, IDE 에서 도와주는 기능들)
이번 아이템에서는 IDE, 편집기에서 제공하는 언어 서비스에 대해 설명한다.
상세한 내용은 생략한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-07.-%ED%83%80%EC%9E%85%EC%9D%B4-%EA%B0%92%EB%93%A4%EC%9D%98-%EC%A7%91%ED%95%A9%EC%9D%B4%EB%9D%BC%EA%B3%A0-%EC%83%9D%EA%B0%81%ED%95%98%EA%B8%B0-todo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-07.-%ED%83%80%EC%9E%85%EC%9D%B4-%EA%B0%92%EB%93%A4%EC%9D%98-%EC%A7%91%ED%95%A9%EC%9D%B4%EB%9D%BC%EA%B3%A0-%EC%83%9D%EA%B0%81%ED%95%98%EA%B8%B0-todo/</guid>
      <description>아이템 7. 타입이 갑들의 집합이라고 생각하기 # 7장은 다시 확인/이해가 필요하다.
&amp;lsquo;할당 가능한 값들의 집합(범위)&amp;rsquo; = &amp;lsquo;타입&amp;rsquo; 이라고 생각하면 된다. 예를 들어, 모든 숫자값의 집합(범위)는 number 타입이다. 1. 가장 작은 집합 = 아무 값도 포함하지 않는 공집합 = never
const x: neber = 12; // ~ &amp;#39;12&amp;#39; 형식은 &amp;#39;never&amp;#39; 형식에 할당할 수 없습니다. 2. 그 다음으로 작은 집합 = 한 가지 값만 포함하는 타입 = unit (literal)
type A = &amp;#39;A&amp;#39;; type B = &amp;#39;B&amp;#39;; type Twelve = &amp;#39;12&amp;#39;; 3.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-08.-%ED%83%80%EC%9E%85-%EA%B3%B5%EA%B0%84%EA%B3%BC-%EA%B0%92-%EA%B3%B5%EA%B0%84%EC%9D%98-%EC%8B%AC%EB%B2%8C-%EA%B5%AC%EB%B6%84%ED%95%98%EA%B8%B0-todo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-08.-%ED%83%80%EC%9E%85-%EA%B3%B5%EA%B0%84%EA%B3%BC-%EA%B0%92-%EA%B3%B5%EA%B0%84%EC%9D%98-%EC%8B%AC%EB%B2%8C-%EA%B5%AC%EB%B6%84%ED%95%98%EA%B8%B0-todo/</guid>
      <description>아이템 8. 타입 공간과 값 공간의 심벌 구분하기 # 타입스크립트의 심벌(symbol)은 타입 공간, 값 공간 중 한 곳에 존재한다.
쉽게 말하면, 같은 네이밍을 가진 심벌은 타입이 될 수도, 값이 될 수도 있다는 의미이다.
// &amp;#39;Cylinder&amp;#39; 라는 심볼은 &amp;#39;타입&amp;#39;이다. interface Cylinder { radius: number; height: number; } // &amp;#39;Cylinder&amp;#39; 라는 심볼은 &amp;#39;값&amp;#39;이다. const Cylinder = { radius: number, height: number} =&amp;gt; ({ radius, height }); 한 심벌이 &amp;lsquo;타입&amp;rsquo;인지, &amp;lsquo;값&amp;rsquo;인지 알기 위해서는 &amp;lsquo;문맥&amp;rsquo;을 살펴 알아냐애 한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-09.-%ED%83%80%EC%9E%85-%EB%8B%A8%EC%96%B8%EB%B3%B4%EB%8B%A4%EB%8A%94-%ED%83%80%EC%9E%85-%EC%84%A0%EC%96%B8%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-todo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-09.-%ED%83%80%EC%9E%85-%EB%8B%A8%EC%96%B8%EB%B3%B4%EB%8B%A4%EB%8A%94-%ED%83%80%EC%9E%85-%EC%84%A0%EC%96%B8%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-todo/</guid>
      <description>아이템 9. 타입 단언보다는 타입 선언을 사용하기 # 종류 설명 타입 선언 선언한 타입임을 명시한다. - alice: Person 타입 단언 (타입스크립트가 추론한 타입이 있더라도) 해당 타입으로 (강제로) 간주한다. - as Person 타입 단언보다 타입 선언을 사용하는 것이 좋다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-10.-%EA%B0%9D%EC%B2%B4-%EB%9E%98%ED%8D%BC-%ED%83%80%EC%9E%85-%ED%94%BC%ED%95%98%EA%B8%B0-todo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-10.-%EA%B0%9D%EC%B2%B4-%EB%9E%98%ED%8D%BC-%ED%83%80%EC%9E%85-%ED%94%BC%ED%95%98%EA%B8%B0-todo/</guid>
      <description> 아이템 10. 객체 래퍼 타입 피하기 # </description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-11.-%EC%9E%89%EC%97%AC-%EC%86%8D%EC%84%B1-%EC%B2%B4%ED%81%AC%EC%9D%98-%ED%95%9C%EA%B3%84-%EC%9D%B8%EC%A7%80%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-11.-%EC%9E%89%EC%97%AC-%EC%86%8D%EC%84%B1-%EC%B2%B4%ED%81%AC%EC%9D%98-%ED%95%9C%EA%B3%84-%EC%9D%B8%EC%A7%80%ED%95%98%EA%B8%B0/</guid>
      <description>아이템 11. 잉여 속성 체크의 한계 인지하기 # &amp;quot; 잉여 속성 체크를 이용하면 기본적으로 타입 시스템의 구조적 본질을 해치지 않으면서도 객체 리터럴에 알 수 없는 속성을 허용하지 않음으로써, 이번 아이템에서 다룰 Room이나 Options 예제 같은 문제점을 방지할 수 있습니다. (&amp;lsquo;엄격한 객체 리터럴 체크&amp;rsquo;라고 불립니다.) &amp;ldquo;
(구조적 타이핑 기반에서) 타입이 명시된 변수에 &amp;lsquo;객체 리터럴&amp;rsquo;을 할당할 때, 추가로 설정된/할당된 속성(잉여 속성)이 있는지 체크할 수 있다.
객체 리터럴로 할당 시 적용된다. # &amp;lsquo;객체 리터럴&amp;rsquo;로 값을 할당하려고 하면, &amp;lsquo;잉여 속성 체크&amp;rsquo;에 의해 에러를 확인할 수 있다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-14.-%ED%83%80%EC%9E%85-%EC%97%B0%EC%82%B0%EA%B3%BC-%EC%A0%9C%EB%84%88%EB%A6%AD-%EC%82%AC%EC%9A%A9%EC%9C%BC%EB%A1%9C-%EB%B0%98%EB%B3%B5-%EC%A4%84%EC%9D%B4%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-14.-%ED%83%80%EC%9E%85-%EC%97%B0%EC%82%B0%EA%B3%BC-%EC%A0%9C%EB%84%88%EB%A6%AD-%EC%82%AC%EC%9A%A9%EC%9C%BC%EB%A1%9C-%EB%B0%98%EB%B3%B5-%EC%A4%84%EC%9D%B4%EA%B8%B0/</guid>
      <description>아이템 14. 타입 연산과 제너릭 사용으로 반복 줄이기 # DRY(Don&amp;rsquo;t repeat yourself) 원칙에 따라 코드를 개선해볼 수 있다.
함수, 상수, Loop 를 통해 개선했다.
/** 원본 코드 (개선 전) */ console.log(&amp;#39;Cylinder 1 x 1 &amp;#39;, &amp;#39;Surface area: &amp;#39;, 6.283185 * 1 * 1 + 6.283185 * 1 * 1, &amp;#39;Volume: &amp;#39;, 3.14159 * 1 * 1 * 1 ) console.log(&amp;#39;Cylinder 1 x 2 &amp;#39;, &amp;#39;Surface area: &amp;#39;, 6.283185 * 1 * 1 + 6.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-15.-%EB%8F%99%EC%A0%81-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%97%90-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%8B%9C%EA%B7%B8%EB%8B%88%EC%B2%98-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-15.-%EB%8F%99%EC%A0%81-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%97%90-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%8B%9C%EA%B7%B8%EB%8B%88%EC%B2%98-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/</guid>
      <description>아이템 15. 동적 데이터에 인덱스 시그니처 사용하기 # // JS const rocket = { name: &amp;#39;Falcon 9&amp;#39;, variant: &amp;#39;v1.0&amp;#39;, thrust: &amp;#39;4,940 kN&amp;#39;, } // TS (인덱스 시그니처 사용 예시) // Rocket = {[property: string]: string}; const rocket: Rocket = { name: &amp;#39;Falcon 9&amp;#39;, variant: &amp;#39;v1.0&amp;#39;, thrust: &amp;#39;4,940 kN&amp;#39;, } 위 예시에서 {[property: string]: string} 부분이 인덱스 시그니처이다.
**세 가지 기능을 한다.** 기능 설명 키의 이름 키의 위치만 표시하는 용도 (* 타입 체커에서는 사용하지 않는다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-16.-number-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%8B%9C%EA%B7%B8%EB%8B%88%EC%B2%98%EB%B3%B4%EB%8B%A4%EB%8A%94-Array-%ED%8A%9C%ED%94%8C-ArrayLike%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-16.-number-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%8B%9C%EA%B7%B8%EB%8B%88%EC%B2%98%EB%B3%B4%EB%8B%A4%EB%8A%94-Array-%ED%8A%9C%ED%94%8C-ArrayLike%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/</guid>
      <description>&amp;ldquo;자바스크립트는 이상하게 동작하기로 유명한 언어입니다.&amp;rdquo;
아이템 16. number 인덱스 시그니처보다는 Array, 튜플, ArrayLike를 사용하기 # 자바스크립트에서 객체란 키/값 쌍의 모음입니다.
키 : 보통 문자열 (ES2015 이후로는 &amp;lsquo;심벌&amp;rsquo;도 가능) &amp;lsquo;숫자&amp;rsquo; 불가 : &amp;lsquo;숫자&amp;rsquo;를 키로 사용할 경우 런타임에 &amp;lsquo;문자열&amp;rsquo;로 변환됩니다. 값 : 어떤 것이든 가능 파이썬이나 자바에서 볼 수 있는 &amp;lsquo;해시 가능(hashable)&amp;rsquo; 객체라는 표현이 자바스크립트에서는 없습니다. 만약 더 복잡한 객체(심볼)을 &amp;lsquo;키&amp;rsquo;로 사용하려고 하면, toString 메서드가 호출되어 객체가 문자열로 변환됩니다.
배열 # 배열은 객체이다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-19.-%EC%B6%94%EB%A1%A0-%EA%B0%80%EB%8A%A5%ED%95%9C-%ED%83%80%EC%9E%85%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%B4-%EC%9E%A5%ED%99%A9%ED%95%9C-%EC%BD%94%EB%93%9C-%EB%B0%A9%EC%A7%80%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-19.-%EC%B6%94%EB%A1%A0-%EA%B0%80%EB%8A%A5%ED%95%9C-%ED%83%80%EC%9E%85%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%B4-%EC%9E%A5%ED%99%A9%ED%95%9C-%EC%BD%94%EB%93%9C-%EB%B0%A9%EC%A7%80%ED%95%98%EA%B8%B0/</guid>
      <description>아이템 19. 추론 가능한 타입을 사용해 장황한 코드 방지하기 # &amp;quot; 타입 구문을 생략하여, 방해되는 것들을 최소화하고 코드를 읽는 사람이 구현 로직에 집중할 수 있게 해주는 것이 좋습니다. &amp;ldquo;
대부분의 경우 타입스크립트에서 타입 구문은 불필요하다.
타입을 선언하는 것은 &amp;lsquo;비생상적&amp;rsquo;, &amp;lsquo;형편없는 스타일&amp;rsquo;로 여겨진다.
let x: number = 12; // vs // x: number = 12; (코드를 보면서) 타입을 확신하지 못한다면 편집기(IDE)를 통해 체크할 수 있다.
ㄴ 이 문장은 &amp;lsquo;타입이 명시적으로 있는 게 좋지 않은가?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-20.-%EB%8B%A4%EB%A5%B8-%ED%83%80%EC%9E%85%EC%97%90%EB%8A%94-%EB%8B%A4%EB%A5%B8-%EB%B3%80%EC%88%98-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-20.-%EB%8B%A4%EB%A5%B8-%ED%83%80%EC%9E%85%EC%97%90%EB%8A%94-%EB%8B%A4%EB%A5%B8-%EB%B3%80%EC%88%98-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/</guid>
      <description>아이템 20. 다른 타입에는 다른 변수 사용하기 # 결론 = 한 변수(명)를 무분별하게 재사용하지 말자.
자바스크립트에서는 한 변수에 다른 타입을 재사용할 수 있다.
타입스크립트에서는 한 변수에 다른 타입을 재사용할 수 없다. (= 타입 체커에서 걸린다.)
// js : O // ts : X let id = &amp;#34;12-34-56&amp;#34;; id = 123456; &amp;quot; 변수의 &amp;lsquo;값&amp;rsquo;은 바뀔 수 있지만 &amp;lsquo;타입&amp;rsquo;은 보통 바뀌지 않는다. &amp;ldquo;
타입을 바꿀 수 있는 한 가지 방법 : &amp;lsquo;(타입의)범위를 좁히는 것&amp;rsquo; # &amp;lsquo;타입을 더 작게 제한하는 것&amp;rsquo;을 의미한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-21.-%ED%83%80%EC%9E%85-%EB%84%93%ED%9E%88%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-21.-%ED%83%80%EC%9E%85-%EB%84%93%ED%9E%88%EA%B8%B0/</guid>
      <description>아이템 21. 타입 넓히기 # &amp;quot; 아이템 7에서 설명한 것처럼 런타임에 모든 변수는 유일한 값을 가집니다. &amp;ldquo;
런타임(=자바스크립트) 시에는 모든 변수가 값을 가진다. 그러나 타입스크립트가 작성된 코드를 체크하는 정적 분석 시점에는, 변수는 &amp;lsquo;가능한 값들의 집합&amp;rsquo;인 타입을 가진다.
넓히기 (widening) # 상수를 사용해서 변수를 초기화할 때, 타입을 명시하지 않으면 타입 체커는 타입을 추론/결정해야 한다. = &amp;lsquo;가능한 값들의 집합&amp;rsquo;(타입)을 추론해야 한다.
타입스크립트에서는 이 과정을 &amp;lsquo;넓히기(widening)&amp;rsquo; 라고 부른다.
&amp;lsquo;넓히기&amp;rsquo;가 진행될 때, 가능한 값의 범위를 최대한 좁히되 오류(잘못된 추론)는 발생하면 안된다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-23.-%ED%95%9C%EA%BA%BC%EB%B2%88%EC%97%90-%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-23.-%ED%95%9C%EA%BA%BC%EB%B2%88%EC%97%90-%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0/</guid>
      <description>아이템 23. 한꺼번에 객체 생성하기 # 변수의 값은 변경될 수 있지만, 타입스크립트의 타입은 (일반적으로) 변경되지 않는다.
즉, 객체를 생성할 때는 속성을 하나씩 추가하기보다는 여러 속성을 포함해서 &amp;lsquo;한꺼번에 생성해야 타입 추론에 유리&amp;rsquo;하다.
const pt = {}; pt.x = 3; pt.y = 4; » tsc example.ts example.ts:2:4 - error TS2339: Property &amp;#39;x&amp;#39; does not exist on type &amp;#39;{}&amp;#39;. 2 pt.x = 3; ~ example.ts:3:4 - error TS2339: Property &amp;#39;y&amp;#39; does not exist on type &amp;#39;{}&amp;#39;.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-24.-%EC%9D%BC%EA%B4%80%EC%84%B1-%EC%9E%88%EB%8A%94-%EB%B3%84%EC%B9%AD-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-24.-%EC%9D%BC%EA%B4%80%EC%84%B1-%EC%9E%88%EB%8A%94-%EB%B3%84%EC%B9%AD-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/</guid>
      <description>아이템 24. 일관성 있는 별칭 사용하기 # 별칭의 값을 변경하면 원래 속성값도 변경된다. 별칭 남발 시, 코드를 분석하기 어렵다. const borough = { name: &amp;#39;Brooklyn&amp;#39;, location: [40, -73] } const loc = borough.location // 별칭의 값을 변경하면 원래 속성값도 변경된다. loc[0] = 0; console.log(borough.location) // [0, -73] 타입 체크 시에도 신경써야한다. # function isPointinPolygon(polygon: Polygon, pt: Coordinate) { polygon.bbox; // 타입 : BoundingBox | undefined const box = polygon.bbox; // 타입 : BoundingBox | undefined if (polygon.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-25.-%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%BD%94%EB%93%9C%EC%97%90%EB%8A%94-%EC%BD%9C%EB%B0%B1-%EB%8C%80%EC%8B%A0-async-%ED%95%A8%EC%88%98-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-25.-%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%BD%94%EB%93%9C%EC%97%90%EB%8A%94-%EC%BD%9C%EB%B0%B1-%EB%8C%80%EC%8B%A0-async-%ED%95%A8%EC%88%98-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/</guid>
      <description>아이템 25. 비동기 코드에는 콜백 대신 async 함수 사용하기 # ES2015, 프로미스(promis) 개념이 도입되었다.
프로미스는 미래에 가능해질 어떤 것을 나타낸다. (future) ES2017, async/await 키워드가 도입되었다.
await : 각각의 프로미스가 처리(resolve)될 때까지 함수의 실행을 멈춘다. async : 함수 내에서 await 중인 프로미스가 거절(reject)되면 예외를 던진다. 이를 통해 일반적인 try/catch 구문을 사용할 수 있다. 아래 예시를 살펴보자. 콜백 지옥, 프로미스, async/await 를 사용하여 코드를 개선한 예시이다.
/** 예시 : 콜백 */ fetchURL(url1, function(response1) { fetchURL(url2, function(response2) { fetchURL(url3, function(response3) { //.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-26.-%ED%83%80%EC%9E%85-%EC%B6%94%EB%A1%A0%EC%97%90-%EB%AC%B8%EB%A7%A5%EC%9D%B4-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%82%AC%EC%9A%A9%EB%90%98%EB%8A%94%EC%A7%80-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-26.-%ED%83%80%EC%9E%85-%EC%B6%94%EB%A1%A0%EC%97%90-%EB%AC%B8%EB%A7%A5%EC%9D%B4-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%82%AC%EC%9A%A9%EB%90%98%EB%8A%94%EC%A7%80-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/</guid>
      <description>아이템 26. 타입 추론에 문맥이 어떻게 사용되는지 이해하기 # 이번 아이템에서 말하는 문맥이란, 상수를 그대로 사용하지 않고 변수(?), 별칭(?)과 같은 것(=문맥)을 의미한다.
문맥을 사용했을 때, 타입 추론이 다르다는 것을 이야기하는 내용이다.
아래 예시는, 문맥을 활용했을 때 타입추론이 어떻게 변하는지 보여주는 예시이다.
type Language = &amp;#39;Javascript&amp;#39; | &amp;#39;TypeScript&amp;#39; | &amp;#39;Python&amp;#39; function setLanguage(language: Language) { /* ... */ } // 예시 1 : 상수 직접 사용 setLanguage(&amp;#39;Javascript&amp;#39;); // 예시 2 : 문맥 활용 let language = &amp;#39;Javascript&amp;#39;; setLanguage(language); // ~~~~~~~~ &amp;#39;string&amp;#39; 형식의 인수는 // &amp;#39;Language&amp;#39; 형식의 매개변수에 할당될 수 없습니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-27.-%ED%95%A8%EC%88%98%ED%98%95-%EA%B8%B0%EB%B2%95%EA%B3%BC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EB%A1%9C-%ED%83%80%EC%9E%85-%ED%9D%90%EB%A6%84-%EC%9C%A0%EC%A7%80%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-27.-%ED%95%A8%EC%88%98%ED%98%95-%EA%B8%B0%EB%B2%95%EA%B3%BC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EB%A1%9C-%ED%83%80%EC%9E%85-%ED%9D%90%EB%A6%84-%EC%9C%A0%EC%A7%80%ED%95%98%EA%B8%B0/</guid>
      <description>아이템 27. 함수형 기법과 라이브러리로 타입 흐름 유지하기 # 라이브러리는 타입스크립트와 조합하여 사용하면 더욱 빛을 발휘한다.
이유는 타입 정보가 그대로 유지되면서 타입 흐름(flow)가 계속 전달되기 때문이다.
즉, 타입이 추론되고 추론된 타입이 계속 사용되고, 사용되고, 사용된다.
자바스크립트의 경우 라이브러리를 쓰는 것은 &amp;lsquo;고려 사항&amp;rsquo;이다. # 서드파티 라이브러리 종속성을 추가할 때 신중해야 한다.
서드파티 라이브러리를 통해 시간, 비용이 많이 든다면 사용하지 않는게 나을 것이다.
타입스크립트의 경우 라이브러리를 쓰는 것은 &amp;lsquo;필수&amp;rsquo;이다. (매우 권장) # 타입이 &amp;lsquo;정확하게&amp;rsquo; 추론된다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-28.-%EC%9C%A0%ED%9A%A8%ED%95%9C-%EC%83%81%ED%83%9C%EB%A7%8C-%ED%91%9C%ED%98%84%ED%95%98%EB%8A%94-%ED%83%80%EC%9E%85%EC%9D%84-%EC%A7%80%ED%96%A5%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-28.-%EC%9C%A0%ED%9A%A8%ED%95%9C-%EC%83%81%ED%83%9C%EB%A7%8C-%ED%91%9C%ED%98%84%ED%95%98%EB%8A%94-%ED%83%80%EC%9E%85%EC%9D%84-%EC%A7%80%ED%96%A5%ED%95%98%EA%B8%B0/</guid>
      <description>타입 시스템의 큰 장점 중 하나는 데이터 타입을 명확히 알 수 있어 코드를 이해하기 쉽다는 것이다. 4장(타입 설계)에서는 타입 자체의 설계에 대해 다룬다. 대부분 다른 언어에서도 적용될 수 있는 아이디어다.
아이템 28. 유효한 상태만 표현하는 타입을 지향하기 # 효과적으로 타입을 설계하려면, 유효한 상태만 표현할 수 있는 타입을 만들어 내는 것이 중요합니다.
interface State { pageText: string; isLoading: boolean; error?: string; } 위 타입이 페이지를 렌더링하는 상태를 나타낸다고 가정할 때, 이 타입은 애매하다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-29.-%EC%82%AC%EC%9A%A9%ED%95%A0-%EB%95%8C%EB%8A%94-%EB%84%88%EA%B7%B8%EB%9F%BD%EA%B2%8C-%EC%83%9D%EC%84%B1%ED%95%A0-%EB%95%8C%EB%8A%94-%EC%97%84%EA%B2%A9%ED%95%98%EA%B2%8C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-29.-%EC%82%AC%EC%9A%A9%ED%95%A0-%EB%95%8C%EB%8A%94-%EB%84%88%EA%B7%B8%EB%9F%BD%EA%B2%8C-%EC%83%9D%EC%84%B1%ED%95%A0-%EB%95%8C%EB%8A%94-%EC%97%84%EA%B2%A9%ED%95%98%EA%B2%8C/</guid>
      <description>아이템 29. 사용할 때는 너그럽게, 생성할 때는 엄격하게 # &amp;quot; 아이템 29의 제목은 TCP 관련해서 존 포스텔이 쓴 견고성 원칙(포스텔의 법칙)에서 따왔습니다. &amp;ldquo;
&amp;rdquo; TCP 구현체는 견고성의 일반적 원칙을 따라야 한다. 당신의 작업은 엄격하게 하고, 다른 사람의 작업은 너그럽게 받아들여야 한다. &amp;ldquo;
함수의 시그니처에도 비슷한 규칙을 적용해야 한다. # 함수의 매개변수는 타입의 범위가 넓어도 되지만, 결과를 반환할 때는 일반적으로 타입의 범위가 더 구체적이어야 한다.
어떤 함수의 반환타입의 범위가 넓으면 사용하기 불편하다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-30.-%EB%AC%B8%EC%84%9C%EC%97%90-%ED%83%80%EC%9E%85-%EC%A0%95%EB%B3%B4%EB%A5%BC-%EC%93%B0%EC%A7%80-%EC%95%8A%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-30.-%EB%AC%B8%EC%84%9C%EC%97%90-%ED%83%80%EC%9E%85-%EC%A0%95%EB%B3%B4%EB%A5%BC-%EC%93%B0%EC%A7%80-%EC%95%8A%EA%B8%B0/</guid>
      <description>아이템 30. 문서에 타입 정보를 쓰지 않기 # 주석을 통해 타입에 대해 설명하곤 한다.
/** * 0개 또는 1개의 매개변수를 받습니다. * 매개변수가 없을 때는 표준 전경색을 반환합니다. */ function getForegroundColor(page?: string) { return page === &amp;#39;login&amp;#39; ? {r: 127, g: 127, b: 127} : {r: 0, g: 0, b: 0}; } 코드와 주석의 정보가 맞지 않는다.
둘 중 어느것이 맞는지 판단해야하는 상황이 생긴다.
코드를 수정하면서 함께 수정하지 않는 경우가 많다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-31.-%ED%83%80%EC%9E%85-%EC%A3%BC%EB%B3%80%EC%97%90-null-%EA%B0%92-%EB%B0%B0%EC%B9%98%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-31.-%ED%83%80%EC%9E%85-%EC%A3%BC%EB%B3%80%EC%97%90-null-%EA%B0%92-%EB%B0%B0%EC%B9%98%ED%95%98%EA%B8%B0/</guid>
      <description>아이템 31. 타입 주변에 null 값 배치하기 # 값이 전부 null, null이 아닌 경우로 분명히 구분한다면 값이 섞여 있을 때보다 다루기 쉽다.
if 혹은 !(단언) 을 통해 쉽게 타입을 좁힐 수 있다. 추가로 undefined 를 포함하는 객체는 다루기 어렵고 절대 권장하지 않는다.
타입에 null 을 추가하는 방식으로 이러한 경우를 모델링할 수 있다.
function extent(nums: number[]) { let result: [number, number] | null = null; for (const num of nums) { if(!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-33.-string-%ED%83%80%EC%9E%85%EB%B3%B4%EB%8B%A4-%EB%8D%94-%EA%B5%AC%EC%B2%B4%EC%A0%81%EC%9D%B8-%ED%83%80%EC%9E%85-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-33.-string-%ED%83%80%EC%9E%85%EB%B3%B4%EB%8B%A4-%EB%8D%94-%EA%B5%AC%EC%B2%B4%EC%A0%81%EC%9D%B8-%ED%83%80%EC%9E%85-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/</guid>
      <description>아이템 33. string 타입보다 더 구체적인 타입 사용하기 # string 타입의 범위는 매우 넓다.(&amp;ldquo;a&amp;rdquo;, &amp;ldquo;b&amp;rdquo;, &amp;ldquo;casdsad&amp;rdquo;, &amp;hellip;)
다음은 string 타입이 남발된 타입의 예시이다.
interface Album { artist: string; title: string; releaseDate: string; // 예를 들어, yyyy-mm-dd recordingType: string; // 예를 들어, &amp;#34;live&amp;#34; 또는 &amp;#34;studio&amp;#34; } string 은 다음과 같은 단점이 있다.
예를 들어,
recordingType 에 &amp;ldquo;Live&amp;rdquo; 값이 들어가도, 타입 체커는 완벽하게 체크할 수 없다. releaseDate 에 &amp;ldquo;asdsad&amp;rdquo; 값이 들어가도, 타입체커는 완벽하게 체크할 수 없다.</description>
    </item>
    
  </channel>
</rss>
