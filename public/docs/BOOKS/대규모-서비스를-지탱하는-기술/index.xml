<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>대규모 서비스를 지탱하는 기술 on thisandthat</title>
    <link>https://hjjae2.github.io/docs/BOOKS/%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%84%9C%EB%B9%84%EC%8A%A4%EB%A5%BC-%EC%A7%80%ED%83%B1%ED%95%98%EB%8A%94-%EA%B8%B0%EC%88%A0/</link>
    <description>Recent content in 대규모 서비스를 지탱하는 기술 on thisandthat</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://hjjae2.github.io/docs/BOOKS/%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%84%9C%EB%B9%84%EC%8A%A4%EB%A5%BC-%EC%A7%80%ED%83%B1%ED%95%98%EB%8A%94-%EA%B8%B0%EC%88%A0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>5장. 대규모 데이터 처리의 어려운 점 (메모리와 디스크)</title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%84%9C%EB%B9%84%EC%8A%A4%EB%A5%BC-%EC%A7%80%ED%83%B1%ED%95%98%EB%8A%94-%EA%B8%B0%EC%88%A0/5%EC%9E%A5_%EB%8C%80%EA%B7%9C%EB%AA%A8-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%B2%98%EB%A6%AC%EC%9D%98-%EC%96%B4%EB%A0%A4%EC%9A%B4-%EC%A0%90-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%99%80-%EB%94%94%EC%8A%A4%ED%81%AC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%84%9C%EB%B9%84%EC%8A%A4%EB%A5%BC-%EC%A7%80%ED%83%B1%ED%95%98%EB%8A%94-%EA%B8%B0%EC%88%A0/5%EC%9E%A5_%EB%8C%80%EA%B7%9C%EB%AA%A8-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%B2%98%EB%A6%AC%EC%9D%98-%EC%96%B4%EB%A0%A4%EC%9A%B4-%EC%A0%90-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%99%80-%EB%94%94%EC%8A%A4%ED%81%AC/</guid>
      <description>(대규모 데이터 처리가 어려운 이유)메모리 내에서 처리(계산)할 수 없다. # 메모리에서 처리할 수 없으면 DISK 를 사용해야 한다. 메모리의 크기는 DISK에 비해 작기 때문에 데이터의 크기가 클 경우 메모리에서 모두 처리할 수 없게 된다. 메모리는 디스크에 비해 10^5(10만) ~ 10^6(100만) 배 빠르다. 메모리는 왜 디스크보다 빠를까? # 1. 물리적인 구조
물리적인 구조가 그렇다. 메모리는 전기적인 부품이다. 데이터를 탐색하는 속도가 빠르다.
반대로 DISK는 동축 상에 원반(disk)로 쌓여 있다. 원반 회전, 헤드의 이동 등의 물리적인 비용이 발생하고 이게 크다.</description>
    </item>
    
    <item>
      <title>6장. 규모 조정의 요소</title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%84%9C%EB%B9%84%EC%8A%A4%EB%A5%BC-%EC%A7%80%ED%83%B1%ED%95%98%EB%8A%94-%EA%B8%B0%EC%88%A0/6%EC%9E%A5_%EA%B7%9C%EB%AA%A8-%EC%A1%B0%EC%A0%95%EC%9D%98-%EC%9A%94%EC%86%8C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%84%9C%EB%B9%84%EC%8A%A4%EB%A5%BC-%EC%A7%80%ED%83%B1%ED%95%98%EB%8A%94-%EA%B8%B0%EC%88%A0/6%EC%9E%A5_%EA%B7%9C%EB%AA%A8-%EC%A1%B0%EC%A0%95%EC%9D%98-%EC%9A%94%EC%86%8C/</guid>
      <description>규모 조정 # CPU 부하의 규모 조정은 간단하다. # 스케일 아웃 전략을 통해 대응한다. 보통 웹, API, 크롤러 등의 애플리케이션에 해당된다. I/O 부하의 규모 조정은 어렵다. # 보통 DB(with 대규모 데이터) 가 해당된다. 두 종류의 부하(CPU, I/O)와 웹 애플리케이션 # 일반적으로 웹 애플리케이션은 CPU 바운드 프로그램이다.
반면, 일반적으로 디스크에 저장된 데이터를 찾아내는 프로그램(= DB)는 I/O 바운드 프로그램이다.
멀티태스킹 OS와 부하 # (멀티 태스킹 환경에서) A가 CPU 를 점유하고 있는 동안 (CPU가 필요한)B, C 는 대기하게 된다.</description>
    </item>
    
    <item>
      <title>7장. 대규모 데이터를 다루기 위한 기초 지식</title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%84%9C%EB%B9%84%EC%8A%A4%EB%A5%BC-%EC%A7%80%ED%83%B1%ED%95%98%EB%8A%94-%EA%B8%B0%EC%88%A0/7%EC%9E%A5_%EB%8C%80%EA%B7%9C%EB%AA%A8-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EB%8B%A4%EB%A3%A8%EA%B8%B0-%EC%9C%84%ED%95%9C-%EA%B8%B0%EC%B4%88_%EC%A7%80%EC%8B%9D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%84%9C%EB%B9%84%EC%8A%A4%EB%A5%BC-%EC%A7%80%ED%83%B1%ED%95%98%EB%8A%94-%EA%B8%B0%EC%88%A0/7%EC%9E%A5_%EB%8C%80%EA%B7%9C%EB%AA%A8-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EB%8B%A4%EB%A3%A8%EA%B8%B0-%EC%9C%84%ED%95%9C-%EA%B8%B0%EC%B4%88_%EC%A7%80%EC%8B%9D/</guid>
      <description>대규모 데이터를 다루는 세 가지 요령 # 1. 최대한 메모리에서 처리한다.
ex: disk seek 횟수 최소화 ex: 국소성 활용한 분산 실현 2. (데이터량에 따른) 효율적인 알고리즘/자료구조 사용
ex: 선형 탐색 -&amp;gt; 이분 탐색 3. 데이터 압축, 검색 기술과 같은 테크닉
ex: 데이터 압축(데이터 용량 ↓) = 메모리 처리 ↑ = seek 횟수 ↓ Load Average 다음은 CPU 사용률, I/O 대기율 # 과부하로 시스템의 성능이 떨어지는 원인은 대부분의 경우에 CPU, I/O에 있다.</description>
    </item>
    
  </channel>
</rss>
