<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>이펙티브 코틀린 on thisandthat</title>
    <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/</link>
    <description>Recent content in 이펙티브 코틀린 on thisandthat</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-01.-%EA%B0%80%EB%B3%80%EC%84%B1%EC%9D%84-%EC%A0%9C%ED%95%9C%ED%95%98%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-01.-%EA%B0%80%EB%B3%80%EC%84%B1%EC%9D%84-%EC%A0%9C%ED%95%9C%ED%95%98%EB%9D%BC/</guid>
      <description>아이템 01. 가변성을 제한하라. # val # val 은 읽기 전용 프로퍼티지만, immutable 을 의미하는 것은 아니다. setter 를 제공하지 않을 뿐이다. (혼동하지 말 것)
immutable 이 필요하다면 final 키워드를 사용한다.
컬렉션 다운캐스팅 # 컬렉션 다운캐스팅은 계약을 위반하고, 추상화를 무시하는 행위다.
아래는 컬렉션 다운캐스팅의 간단한 예시이다.
val list = listOf(1,2,3) if (list is MutableList) { list.add(4) } JVM에서 listOf 는 자바의 List 인터페이스를 구현한 Array.ArrayList 객체를 리턴한다.
자바의 List 인터페이스는 add, set 과 같은 메서드를 제공하니까 코틀린에서 MutableList 로 변경될 수 있다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-02.-%EB%B3%80%EC%88%98%EC%9D%98-%EC%8A%A4%EC%BD%94%ED%94%84%EB%A5%BC-%EC%B5%9C%EC%86%8C%ED%95%98%ED%95%98%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-02.-%EB%B3%80%EC%88%98%EC%9D%98-%EC%8A%A4%EC%BD%94%ED%94%84%EB%A5%BC-%EC%B5%9C%EC%86%8C%ED%95%98%ED%95%98%EB%9D%BC/</guid>
      <description>변수의 스코프를 최소화하라 # 프로퍼티보다는 지역 변수를 사용하는 것이 좋다. 최대한 좁은 스코프를 갖게 변수를 사용한다. (예를 들어, 블록 내에서만 변수가 사용된다면 블록 내에서만 변수를 사용하는 것이 좋다.) 스코프를 좁게 만들어야 하는 가장 중요한 이유는 코드를 추적하고 관리하기 쉽기 때문이다.
변수를 정의할 때 초기화되는 것이 가장 좋다. (코틀린의) if, when, try-catch, Elvis 표현식, 구조분해 선언 등을 활용하여 변수 정의-초기화를 최대한 함께 처리할 수 있다.
캡처링 # 위의 예시 처럼 변수 선언 위치에 따라 결과가 달라지는 경우도 있다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-03.-%EC%B5%9C%EB%8C%80%ED%95%9C-%ED%94%8C%EB%9E%AB%ED%8F%BC-%ED%83%80%EC%9E%85%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EB%A7%90%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-03.-%EC%B5%9C%EB%8C%80%ED%95%9C-%ED%94%8C%EB%9E%AB%ED%8F%BC-%ED%83%80%EC%9E%85%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EB%A7%90%EB%9D%BC/</guid>
      <description>최대한 플랫폼 타입을 사용하지 말라 # 코틀린은 자바 등의 다른 프로그래밍 언어에서 넘어온 타입들을 특수하게 다룬다. 이 타입을 플랫폼 타입(platform type) 이라고 부른다.
플랫폼 타입은 ! 기호를 붙여서 표기한다. 예를 들면, String! 과 같다.
플랫폼 타입은 코틀린에서 non-nullable, nullable, platform type 변수로 받아 사용할 수 있다.
// 자바 public User getUser() { ... } // 코틀린 val user = getUser() // User! val user = getUser() // User val user = getUser() // User?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-04.-inferred-%ED%83%80%EC%9E%85%EC%9C%BC%EB%A1%9C-%EB%A6%AC%ED%84%B4%ED%95%98%EC%A7%80-%EB%A7%90%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-04.-inferred-%ED%83%80%EC%9E%85%EC%9C%BC%EB%A1%9C-%EB%A6%AC%ED%84%B4%ED%95%98%EC%A7%80-%EB%A7%90%EB%9D%BC/</guid>
      <description>inferred 타입으로 리턴하지 말라 # 타입 추론은 코틀린의 대표적인 특징이다. 다만, 타입 추론을 사용할 때 몇 가지 위험한 부분들이 있다.
(assign 구문에서) 타입 추론 시 슈퍼클래스 또는 인터페이스로 설정되지 않는다. # (assign 구문에서) 타입 추론 시 정확하게 오른쪽에 있는 피연산자에 맞게 설정된다.
슈퍼클래스, 혹은 인터페이스로 설정되지 않는다.
open class Animal class Zebra: Animal() fun main() { var animal = Zebra() // animal 타입은 Zebra animal = Animal() // 오류 : Type mismatch } 타입을 명시하면 아래와 같다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-05.-%EC%98%88%EC%99%B8%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%B4-%EC%BD%94%EB%93%9C%EC%97%90-%EC%A0%9C%ED%95%9C%EC%9D%84-%EA%B1%B8%EC%96%B4%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-05.-%EC%98%88%EC%99%B8%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%B4-%EC%BD%94%EB%93%9C%EC%97%90-%EC%A0%9C%ED%95%9C%EC%9D%84-%EA%B1%B8%EC%96%B4%EB%9D%BC/</guid>
      <description>예외를 활용해 코드에 제한을 걸어라 # &amp;quot; 확실하게 어떤 기능으로(형태로) 동작해야 하는 코드가 있다면, 예외를 활용해 제한을 걸어주는 것이 좋습니다. &amp;ldquo;
예외(제한)을 통해 가독성, 빠른 실패의 이점을 취할 수 있겠다.
코틀린에서는 제한을 걸 때 아래 기능을 사용할 수 있다.
기능 설명 require argument 를 대상으로 한다. argument에 제한을 건다. check 상태를 대상으로 한다. 상태를 확인(제한)할 때 사용할 수 있다. assert 말 그대로 assertion assert 블록은 테스트 모드에서만 작동한다. (?, 밑에 내용을 살펴보면 코틀린/JVM에서만 테스트 코드가 아닌 곳에서 사용할 수 있다고 한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-06.-%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EC%9D%98-%EC%98%A4%EB%A5%98%EB%B3%B4%EB%8B%A4%EB%8A%94-%ED%91%9C%EC%A4%80-%EC%98%A4%EB%A5%98%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-06.-%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EC%9D%98-%EC%98%A4%EB%A5%98%EB%B3%B4%EB%8B%A4%EB%8A%94-%ED%91%9C%EC%A4%80-%EC%98%A4%EB%A5%98%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/</guid>
      <description>사용자 정의 오류보다는 표준 오류를 사용하라 # 가능하다면, 직접 오류를 정의(커스텀 Exception)하는 것보다는 최대한 표준 라이브러리의 오류를 사용하는 것이 좋다. 표준 라이브러리의 사용은 범용성↑ 을 의미한다. (많은 개발자가 이미 알고 있다.)
잘 만들어진 규약을 재사용하는 것은 코드(API)를 더 쉽게 만드는 것이라고 볼 수 있다.
일반적으로 사용되는 Exception # 일반적으로 많이 사용되는 Exception 몇 가지를 살펴본다.
Exception 설명 IllegalArgumentException 생략 IllegalStateException 생략 IndexOutOfBoundsException 생략 ConcurrentModificationException 동시 수정(concurrent modification)을 금지했으나, 발생한 경우 UnsupportedOperationException 사용자가 사용하려는 메서드가 현재는 사용할 수 없는 상태(지원되지 않는 상태) 단, 기본적으로 사용할 수 없는 메서드는 코드(클래스)에 없는 것이 좋다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-07.-%EA%B2%B0%EA%B3%BC-%EB%B6%80%EC%A1%B1%EC%9D%B4-%EB%B0%9C%EC%83%9D%ED%95%A0-%EA%B2%BD%EC%9A%B0-null%EA%B3%BC-Failure%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-07.-%EA%B2%B0%EA%B3%BC-%EB%B6%80%EC%A1%B1%EC%9D%B4-%EB%B0%9C%EC%83%9D%ED%95%A0-%EA%B2%BD%EC%9A%B0-null%EA%B3%BC-Failure%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/</guid>
      <description>결과 부족이 발생할 경우 null과 Failure를 사용하라 # 함수가 원하는 결과를 만들어 낼 수 없는 경우가 있다. 이런 상황을 처리하는 메커니즘은 크게 두 가지가 있다.
null 또는 Failure를 나타내는 seald 클래스 예외 throw 위 두 가지는 중요한 차이점이 있다.
Exception (예외) # 예외는 정보를 전달하는 방법으로 사용해서는 안된다. 예외는 잘못된 특별한 상황을 나타내고 처리해야 한다.
immutable 컬렉션의 경우 명시적으로 Exception 을 사용하지 않던가&amp;hellip;🤔 어떻게 보느냐가 중요할 것 같다. 메시지 전달을 포함하여 잘못된 상황을 처리하는 것이기도 하니까.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-08.-%EC%A0%81%EC%A0%88%ED%95%98%EA%B2%8C-null%EC%9D%84-%EC%B2%98%EB%A6%AC%ED%95%98%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-08.-%EC%A0%81%EC%A0%88%ED%95%98%EA%B2%8C-null%EC%9D%84-%EC%B2%98%EB%A6%AC%ED%95%98%EB%9D%BC/</guid>
      <description>적절하게 null을 처리하라 # null은 &amp;lsquo;값이 부족하다(lack of value)&amp;lsquo;를 의미한다. 프로퍼티가 null이 라는 것은 값이 제대로 설정되지 않았다거나, 제거됐다는 것을 의미한다.
nullable 은 최대한 명확하게 처리해야한다. (String.toIntOrNull(), Iterable&amp;lt;T&amp;gt;.firstOrNull(() -&amp;gt; Boolean))
기본적으로 nullable 타입은 3 가지 방법으로 처리한다.
?., ?:, 스마트 캐스팅 등을 활용해서 처리한다. 오류를 throw 한다. (함수, 프로퍼티 리팩터링하여) non-nullable로 변경한다. null 안전하게 처리 # safe call (?., ?:), 스마트 캐스팅을 활용해서 null 을 안전하게 처리할 수 있다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-09.-use%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%EB%A6%AC%EC%86%8C%EC%8A%A4%EB%A5%BC-%EB%8B%AB%EC%95%84%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-09.-use%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%EB%A6%AC%EC%86%8C%EC%8A%A4%EB%A5%BC-%EB%8B%AB%EC%95%84%EB%9D%BC/</guid>
      <description>use를 사용하여 리소스를 닫아라 # java 의 try-with-resources 와 동일한 기능이겠다.
코틀린에서는 java의 try-with-resources 와 같은 기능으로 use, useLines 등을 사용할 수 있다.
모든 Closable 객체에 사용할 수 있다.
fun countCharactersInFile(path: String): Int { val reader = BufferedReader(FileReader(path)) reader.use { return reader.lineSequence().sumBy { it.length } } } fun countCharactersInFile(path: String): Int { BufferedReader(FileReader(path)).use { return reader.lineSequence().sumBy { it.length } } } fun countCharactersInFile(path: String): Int { File(path).useLines { lines -&amp;gt; return lines.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-10.-%EB%8B%A8%EC%9C%84-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-10.-%EB%8B%A8%EC%9C%84-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%9D%BC/</guid>
      <description>단위 테스트를 만들어라 # 이 아이템의 내용은 생략</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-11.-%EA%B0%80%EB%8F%85%EC%84%B1%EC%9D%84-%EB%AA%A9%ED%91%9C%EB%A1%9C-%EC%84%A4%EA%B3%84%ED%95%98%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-11.-%EA%B0%80%EB%8F%85%EC%84%B1%EC%9D%84-%EB%AA%A9%ED%91%9C%EB%A1%9C-%EC%84%A4%EA%B3%84%ED%95%98%EB%9D%BC/</guid>
      <description>코틀린은 간결성을 목표로 설계된 프로그래밍 언어가 아니라, 가독성을 좋게 하는 데 목표를 두고 설계된 프로그래밍 언어입니다.
간결성과 가독성을 혼동하지 말자. (책에서 말하는)간결성은 &amp;lsquo;짧음&amp;rsquo;과 조금 더 관계가 있다. 가독성은 &amp;lsquo;읽기 좋음&amp;rsquo;과 관계가 있다.
가독성을 목표로 설계하라 # 프로그래밍은 쓰기보다 읽기가 중요하다. (e.g. &amp;quot; 개발자가 코드를 작성하는 데는 1분 걸리지만, 이를 읽는 데는 10분이 걸린다. &amp;ldquo;)
인식 부하 감소 # 사용 빈도가 적은 관용구는 코드를 복잡하게 만든다. 이런 관용구들을 한 문장 내부에 조합해서 사용하면 복잡성은 훨씬 빠르게 증가한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-12.-%EC%97%B0%EC%82%B0%EC%9E%90-%EC%98%A4%EB%B2%84%EB%A1%9C%EB%93%9C%EB%A5%BC-%ED%95%A0-%EB%95%8C%EB%8A%94-%EC%9D%98%EB%AF%B8%EC%97%90-%EB%A7%9E%EA%B2%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-12.-%EC%97%B0%EC%82%B0%EC%9E%90-%EC%98%A4%EB%B2%84%EB%A1%9C%EB%93%9C%EB%A5%BC-%ED%95%A0-%EB%95%8C%EB%8A%94-%EC%9D%98%EB%AF%B8%EC%97%90-%EB%A7%9E%EA%B2%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/</guid>
      <description>연산자 오버로드를 할 때는 의미에 맞게 사용하라 # 연산자 오버로딩은 그 이름의 의미에 맞게 사용하자. 적절하게 사용하지 못할 것 같다면, 오버로딩을 하지 않는 것이 좋다. (이때는 일반 함수를 쓰자)
연산자 같은 형태로 사용하고 싶다면 infix 확장 함수, Top-Level 함수를 활용할 수 있다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-13.-Unit%EC%9D%84-%EB%A6%AC%ED%84%B4%ED%95%98%EC%A7%80-%EB%A7%90%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-13.-Unit%EC%9D%84-%EB%A6%AC%ED%84%B4%ED%95%98%EC%A7%80-%EB%A7%90%EB%9D%BC/</guid>
      <description>Unit? 을 리턴하지 말라 # fun keyIsCorrect(key: String): Boolean = //... if(!keyIsCorrect(key)) { // 로직 } fun keyIsCorrect(key: String): Unit? = //... keyIsCorrect(key) ?: // 로직 위 코드를 보면, Unit? 의 경우에도 ?:, ?.let 등을 활용해 Boolean 처럼 쓸 수 있다.
하지만 이 형태는 좋지 않다. 예측하기 어려운 오류를 만들어 낼 수 있다.
예시
getData()?.let { view.showData(it) } ?: view.showError() 위 코드에서 getData 가 null 이 아니고, showData(it)가 null 인 상황이면 showData, showError 가 모두 호출된다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-14.-%EB%B3%80%EC%88%98-%ED%83%80%EC%9E%85%EC%9D%B4-%EB%AA%85%ED%99%95%ED%95%98%EC%A7%80-%EC%95%8A%EC%9D%80-%EA%B2%BD%EC%9A%B0-%ED%99%95%EC%8B%A4%ED%95%98%EA%B2%8C-%EC%A7%80%EC%A0%95%ED%95%98%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-14.-%EB%B3%80%EC%88%98-%ED%83%80%EC%9E%85%EC%9D%B4-%EB%AA%85%ED%99%95%ED%95%98%EC%A7%80-%EC%95%8A%EC%9D%80-%EA%B2%BD%EC%9A%B0-%ED%99%95%EC%8B%A4%ED%95%98%EA%B2%8C-%EC%A7%80%EC%A0%95%ED%95%98%EB%9D%BC/</guid>
      <description>변수 타입이 명확하지 않은 경우 확실하게 지정하라 # 코틀린의 타입 추론 시스템은 매우 편리하다.
하지만 타입을 명확하게 보여주지 않는 것은 좋지 않다.
// data 의 타입이 무엇인지 바로 알 수 없다. val data = getSomeData() // 다음과 같이 표현하는 것이 좋다. val data: UserData = getSomeData() 가독성을 위해 코드를 작성/설계할 때는 읽는 사람에게 중요한 정보를 숨겨선 안된다. 가독성 향상 이외에 안전을 위해서라도 타입을 지정하는 것이 좋다.
함수 정의를 보면 되지 않나?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-15.-%EB%A6%AC%EC%8B%9C%EB%B2%84%EB%A5%BC-%EB%AA%85%EC%8B%9C%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%B0%B8%EC%A1%B0%ED%95%98%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-15.-%EB%A6%AC%EC%8B%9C%EB%B2%84%EB%A5%BC-%EB%AA%85%EC%8B%9C%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%B0%B8%EC%A1%B0%ED%95%98%EB%9D%BC/</guid>
      <description>리시버를 명시적으로 참조하라 # 여러 개의 리시버 # 스코프 내부에 둘 이상의 리시버가 있는 경우, 리시버를 명시적으로 나타내면 좋다. 즉 리시버가 헷갈릴 수 있는 경우, 명시적으로 표현하자.
또, 리시버가 중첩되는 경우 목적에 맞는 함수를 잘 구분해서 쓰자. (e.g. let, apply, also, with, run)
class Node(val name: String) { fun makeChild(childName: String) { create(&amp;#34;$name.$childName&amp;#34;).apply { print(&amp;#34;Created ${this?.name} in ${this@Node.name}&amp;#34;) // this@Node와 같이 label 을 활용할 수 있다. } } } label 없이 리시버 사용하면, 가장 가까운 리시버를 의미한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-16.-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EB%8A%94-%EB%8F%99%EC%9E%91%EC%9D%B4-%EC%95%84%EB%8B%88%EB%9D%BC-%EC%83%81%ED%83%9C%EB%A5%BC-%EB%82%98%ED%83%80%EB%82%B4%EC%95%BC-%ED%95%9C%EB%8B%A4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-16.-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EB%8A%94-%EB%8F%99%EC%9E%91%EC%9D%B4-%EC%95%84%EB%8B%88%EB%9D%BC-%EC%83%81%ED%83%9C%EB%A5%BC-%EB%82%98%ED%83%80%EB%82%B4%EC%95%BC-%ED%95%9C%EB%8B%A4/</guid>
      <description>프로퍼티는 동작이 아니라 상태를 나타내야 한다. # 코틀린의 프로퍼티는 자바의 필드랑 비슷해 보이지만, 서로 완전히 다른 개념이다.
둘 다 데이터를 저장한다는 점은 같다. 하지만 프로퍼티에는 더 많은 기능이 있다.
프로퍼티 # 사용자 정의 getter/setter 가질 수 있다. val 프로퍼티에는 백킹 필드가 만들어지지 않는다. 필드가 필요 없다. 프로퍼티는 개념적으로 &amp;lsquo;접근자&amp;rsquo;를 나타낸다. 따라서 코틀린에서는 인터페이스에서도 프로퍼티를 정의할 수 있다. (아래 &amp;lsquo;예시 1&amp;rsquo; 참고) 위임(property delegate)할 수 있다. 프로퍼티는 본질적으로 함수이다. 확장 프로퍼티를 만들 수 있다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-17.-%EC%9D%B4%EB%A6%84-%EC%9E%88%EB%8A%94-%EC%95%84%EA%B7%9C%EB%A8%BC%ED%8A%B8%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-17.-%EC%9D%B4%EB%A6%84-%EC%9E%88%EB%8A%94-%EC%95%84%EA%B7%9C%EB%A8%BC%ED%8A%B8%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/</guid>
      <description>이름 있는 아규먼트를 사용하라 # 장점은 다음과 같다.
이름을 기반으로 값이 무엇을 나타내는지 알 수 있다. 파라미터 입력 순서와 상관 없으므로 안전하다. 함수 타입 파라미터 # 함수 타입 파라미터는 마지막 위치에 배치하는 것이 좋다.
:thinking: (책에서 이렇게 말한)이유가 무엇인지?
참고로, 코틀린에서는 마지막에 위치한 함수 타입의 경우 람다를 이용할 수 있다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-18.-%EC%BD%94%EB%94%A9-%EC%BB%A8%EB%B2%A4%EC%85%98%EC%9D%84-%EC%A7%80%EC%BC%9C%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-18.-%EC%BD%94%EB%94%A9-%EC%BB%A8%EB%B2%A4%EC%85%98%EC%9D%84-%EC%A7%80%EC%BC%9C%EB%9D%BC/</guid>
      <description>코딩 컨벤션을 지켜라 # 코드는 마치 한 사람이 작성한 것 처럼 작성돼야 한다.
코딩 컨벤션을 지켜야 하는 이유는 다음과 같다.
이해하기 쉽다. (인지 부하 감소) 코드 병합, 리팩터링이 쉬워진다. IntelliJ 의 경우 Code Style - Kotlin - Predefined style/Kotlin style guide 를 이용할 수 있다. (= 공식 코딩 컨벤션 스타일)</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-19.-knowledge%EB%A5%BC-%EB%B0%98%EB%B3%B5%ED%95%98%EC%97%AC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EB%A7%90%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-19.-knowledge%EB%A5%BC-%EB%B0%98%EB%B3%B5%ED%95%98%EC%97%AC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EB%A7%90%EB%9D%BC/</guid>
      <description>knowledge를 반복하여 사용하지 말라 # &amp;quot; 프로젝트에서 이미 있던 코드를 복사해서 붙여넣고 있다면, 무언가가 잘못된 것이다. &amp;quot;
규모가 작은 것들(예를 들어, 함수, 단일 클래스 등)은 재사용할 수 있게 잘 추출해서 정리하고 있다. 다만, 최근에 규모가 큰 것(패키지 단위)에 대해서 복붙한 경험이 있다. 공통 모듈로 분리할 수 있었지만 깊이 있게 고민하지 않고 넘어갔다. :thinking:
DRY, WET 안티패턴(We Enjoy Typing, Waste Everyone&amp;rsquo;s Time or Write Everthing Twice), SSOT(Single Source of Truth)</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-20.-%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9D%B8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%84-%EB%B0%98%EB%B3%B5%ED%95%B4%EC%84%9C-%EA%B5%AC%ED%98%84%ED%95%98%EC%A7%80-%EB%A7%90%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-20.-%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9D%B8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%84-%EB%B0%98%EB%B3%B5%ED%95%B4%EC%84%9C-%EA%B5%AC%ED%98%84%ED%95%98%EC%A7%80-%EB%A7%90%EB%9D%BC/</guid>
      <description>일반적인 알고리즘을 반복해서 구현하지 말라 # 여기서 말하는 알고리즘은 특정 프로젝트에 국한된 것이 아니라 정말 일반적인(수학 연산과 같은)것들을 말한다.
(깨알 TIP) 아래 코드는 권장되지 않는 코드다. 팩토리 메서드를 활용하거나 기본 생성자를 활용하는 것이 좋다.
item.sources.forEach { var sourceEntity = SourceEntity() sourceEntity.id = it.id sourceEntity.category = it.category ... } 널리 알려진, 일반적으로 모두 이해할 수 있는 것들은(수학 연산과 같은), 꼭 여러 번 재사용되지 않는다고 해도 공통으로 추출하는 것이 좋다. 예를 들면 아래와 같다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-21.-%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9D%B8-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%ED%8C%A8%ED%84%B4%EC%9D%80-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%9C%84%EC%9E%84%EC%9C%BC%EB%A1%9C-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-21.-%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9D%B8-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%ED%8C%A8%ED%84%B4%EC%9D%80-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%9C%84%EC%9E%84%EC%9C%BC%EB%A1%9C-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%9D%BC/</guid>
      <description>일반적인 프로퍼티 패턴은 프로퍼티 위임으로 만들어라 # 프로퍼티 위임을 사용하면 일반적인 프로퍼티 행위를 추출해서 재사용할 수 있다. 또, 프로퍼티 위임 메커니즘을 통해 다양한 패턴들을 만들 수 있다.
프로퍼티 위임은 프로퍼티 패턴을 추출하는 일반적인 방법이라 많이 사용되고 있다.
lazy, observable, 뷰, 리소스 바인딩, 의존성 주입, 데이터 바인딩 등의 사용 예시가 있겠다.
// 예시 : lazy val value by lazy { createValue() } // 예시 : observable var items: List&amp;lt;Item&amp;gt; by Delegates.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-22.-%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9D%B8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%84-%EA%B5%AC%ED%98%84%ED%95%A0-%EB%95%8C-%EC%A0%9C%EB%84%A4%EB%A6%AD%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-22.-%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9D%B8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%84-%EA%B5%AC%ED%98%84%ED%95%A0-%EB%95%8C-%EC%A0%9C%EB%84%A4%EB%A6%AD%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/</guid>
      <description>일반적인 알고리즘을 구현할 때 제네릭을 사용하라 # 타입 아규먼트를 사용하면 함수에 타입을 전달할 수 있다. 타입 아규먼트를 사용하는 함수를 제네릭 함수라고 부른다.
&amp;quot; 제네릭은 List 또는 Set 처럼 구체적인 타입으로 컬렉션을 만들 수 있게 클래스와 인터페이스에 도입된 기능입니다. &amp;ldquo;
제네릭 제한 # 구체적인 타입의 서브타입만 허용하도록 제한할 수도 있다.
// 콜론 뒤에 상위 타입 명시 `T: Comparable&amp;lt;T&amp;gt;` fun &amp;lt;T : Comparable&amp;lt;T&amp;gt;&amp;gt; Iterable&amp;lt;T&amp;gt;.sorted(): List&amp;lt;T&amp;gt; { ... 많이 사용하는 제한 타입으로 Any 가 있다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-23.-%ED%83%80%EC%9E%85-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EC%9D%98-%EC%84%80%EB%8F%84%EC%9E%89%EC%9D%84-%ED%94%BC%ED%95%98%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-23.-%ED%83%80%EC%9E%85-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EC%9D%98-%EC%84%80%EB%8F%84%EC%9E%89%EC%9D%84-%ED%94%BC%ED%95%98%EB%9D%BC/</guid>
      <description>타입 파라미터의 섀도잉을 피하라 # interface Tree class Birch: Tree class Spruce: Tree class Forest&amp;lt;T: Tree&amp;gt; { fun &amp;lt;T: Tree&amp;gt; addTree(tree: T) { // ... } } Forest와 addTree의 타입 파라미터는 독립적이다. (관계가 없다.)
val forest = Forest&amp;lt;Birch&amp;gt;() forest.addTree(Birch()) forest.addTree(Spruce()) (아마도 대부분의 경우) 위 코드는 개발자가 의도한 것이 아닐 것이다. 따라서 오류가 발생한다는 것을 알아차리기 쉽지 않다.
[수정 1] 다음과 같이 작성하는 것이 올바를 것이다.
class Forest&amp;lt;T: Tree&amp;gt; { fun addTree(tree: T) { // 클래스의 타입 파라미터를 사용하도록 수정한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-24.-%EC%A0%9C%EB%84%A4%EB%A6%AD-%ED%83%80%EC%9E%85%EA%B3%BC-variance-%ED%95%9C%EC%A0%95%EC%9E%90%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%98%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-24.-%EC%A0%9C%EB%84%A4%EB%A6%AD-%ED%83%80%EC%9E%85%EA%B3%BC-variance-%ED%95%9C%EC%A0%95%EC%9E%90%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%98%EB%9D%BC/</guid>
      <description>제네릭 타입과 variance 한정자를 활용하라 # class Cup&amp;lt;T&amp;gt; 위 코드에서 (타입 파라미터)T는 variacne 한정자(out 또는 in)가 없으므로, invariant(불공변성)이다.
invariant 는 제네릭 타입으로 만들어지는 타입들이 서로 아무 관계가 없다는 것을 의미한다. (e.g., Cup&amp;lt;Coffee&amp;gt;, Cup&amp;lt;Int&amp;gt;, Cup&amp;lt;Any&amp;gt;, Cup&amp;lt;Nothing&amp;gt;)
만약 제네릭 타입으로 만들어지는 타입에 관련성을 원한다면, variance 한정자(out 또는 in)를 사용한다.
variance 설명 out covariance (공변성) in contravariant(반변성) out (covariance) # class Cup&amp;lt;out T&amp;gt; open class Dog class Puppy: Dog() fun main(args: Array&amp;lt;String&amp;gt;) { val a: Cup&amp;lt;Dog&amp;gt; = Cup&amp;lt;Puppy&amp;gt;() // OK val b: Cup&amp;lt;Puppy&amp;gt; = Cup&amp;lt;Dog&amp;gt;() // ERROR } in (contravariant) # class Cup&amp;lt;in T&amp;gt; open class Dog class Puppy: Dog() fun main(args: Array&amp;lt;String&amp;gt;) { val a: Cup&amp;lt;Dog&amp;gt; = Cup&amp;lt;Puppy&amp;gt;() // ERROR val b: Cup&amp;lt;Puppy&amp;gt; = Cup&amp;lt;Dog&amp;gt;() // OK } variant, invariant 정리 # 함수 타입 # 함수타입은 파라미터 타입과 리턴 타입에 따라 서로 어떤 관계를 갖는다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-25.-%EA%B3%B5%ED%86%B5-%EB%AA%A8%EB%93%88%EC%9D%84-%EC%B6%94%EC%B6%9C%ED%95%B4%EC%84%9C-%EC%97%AC%EB%9F%AC-%ED%94%8C%EB%9E%AB%ED%8F%BC%EC%97%90%EC%84%9C-%EC%9E%AC%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-25.-%EA%B3%B5%ED%86%B5-%EB%AA%A8%EB%93%88%EC%9D%84-%EC%B6%94%EC%B6%9C%ED%95%B4%EC%84%9C-%EC%97%AC%EB%9F%AC-%ED%94%8C%EB%9E%AB%ED%8F%BC%EC%97%90%EC%84%9C-%EC%9E%AC%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/</guid>
      <description> 공통 모듈을 추출해서 여러 플랫폼에서 재사용하라 # 함께 사용하기 # 코틀린/JVM 을 사용한 백엔드 개발 : Spring, Ktor 등 코틀린/JVM 을 사용한 데스크톱(애플리케이션) 개발 : TornatoFX 등 코틀린/JVM 을 사용한 안드로이드 개발 : Android SDK 등 코틀린/JS 을 사용한 프론트 개발 : React 등 코틀린/네이티브 을 사용한 IOS 개발 코틀린/네이티브 을 사용한 라즈베리파이, 리눅스, macOS 프로그램 개발 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-26.-%ED%95%A8%EC%88%98-%EB%82%B4%EB%B6%80%EC%9D%98-%EC%B6%94%EC%83%81%ED%99%94-%EB%A0%88%EB%B2%A8%EC%9D%84-%ED%86%B5%EC%9D%BC%ED%95%98%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-26.-%ED%95%A8%EC%88%98-%EB%82%B4%EB%B6%80%EC%9D%98-%EC%B6%94%EC%83%81%ED%99%94-%EB%A0%88%EB%B2%A8%EC%9D%84-%ED%86%B5%EC%9D%BC%ED%95%98%EB%9D%BC/</guid>
      <description>&amp;quot; 컴퓨터 과학에서 추상화는 복잡한 자료, 모듈, 시스템 등으로부터 핵심적인 개념 또는 기능을 간추려 내는 것을 말한다. &amp;hellip; 조금 간단하게 표현하면, 추상화는 복잡성을 숨기기 위해 사용되는 방식을 의미한다. &amp;ldquo;
인터페이스는 클래스라는 복잡한 것에서 메서드, 프로퍼티만 추출해서 간단하게 만들었으므로 클래스의 추상화라고 볼 수 있다.
추상화를 하려면 무엇을 감추고 무엇을 노출해야 하는지 결정해야 한다. (잘 결정하지 못하면 추상화 능력이 떨어진다고 볼 수 있다.)
일반적으로 프로그래밍에서는 다음과 같은 목적으로 추상화를 사용한다.
복잡성을 숨기기 위해 코드를 체계화 하기 위해 만드는 사람에게 변화의 자유를 주기 위해 = 쉽게 확장할 수 있고, 수정할 수 있도록 하기 위해 함수 내부의 추상화 레벨을 통일하라 # 계층이 잘 분리되면 좋은 점은 다음과 같다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-27.-%EB%B3%80%ED%99%94%EB%A1%9C%EB%B6%80%ED%84%B0-%EC%BD%94%EB%93%9C%EB%A5%BC-%EB%B3%B4%ED%98%B8%ED%95%98%EB%A0%A4%EB%A9%B4-%EC%B6%94%EC%83%81%ED%99%94%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-27.-%EB%B3%80%ED%99%94%EB%A1%9C%EB%B6%80%ED%84%B0-%EC%BD%94%EB%93%9C%EB%A5%BC-%EB%B3%B4%ED%98%B8%ED%95%98%EB%A0%A4%EB%A9%B4-%EC%B6%94%EC%83%81%ED%99%94%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/</guid>
      <description>변화로부터 코드를 보호하려면 추상화를 사용하라 # &amp;quot; 함수와 클래스 등의 추상화로 실질적인 코드를 숨기면, 사용자가 세부 사항을 알지 못해도 괜찮다는 장점이 있습니다. 그리고 이후에 실질적인 코드를 원하는대로 수정할 수도 있습니다. &amp;ldquo;
&amp;rdquo; 추상화는 더 많은 자유를 주지만, 이를 정의하고, 사용하고, 이해하는 것이 조금 어려워질 수 있습니다. &amp;ldquo;
추상화 사례 1. 상수 # 리터럴은 아무것도 설명하지 않는다.
리터럴을 상수 프로퍼티로 변경하면 해당 값에 의미를 부여할 수 있다. 그래서 두 번 이상 사용되는 값은 상수 프로퍼티(변수)로 만드는 것이 좋다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-28.-API-%EC%95%88%EC%A0%84%EC%84%B1%EC%9D%84-%ED%99%95%EC%9D%B8%ED%95%98%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-28.-API-%EC%95%88%EC%A0%84%EC%84%B1%EC%9D%84-%ED%99%95%EC%9D%B8%ED%95%98%EB%9D%BC/</guid>
      <description>API 안전성을 확인하라 # API 또는 API의 일부가 불안정하다면, 작성자/개발자가 이를 명확하게 알려줘야 한다.
일반적으로 버전을 활용해서 라이브러리, 모듈의 안전성을 나타낸다.
많은 버저닝 시스템이 있지만 일반적으로 사용되는 것은 **시멘틱 버저닝(Semantic Versioning, SemVer)**이다.
시멘틱 버저닝의 표기법은 {MAJOR}.{MINOR}.{PATCH} 이다. 각각의 부분은 0 이상의 정수로 구성되고, 변경 마다 1씩 증가시킨다.
구분 설명 비고 MAJOR 호환되지 않는 수준의 API 변경 MAJOR 증가 시, MINOR, PATCH 는 0으로 초기화한다. MINOR 이전 변경과 호환되는 기능 추가 MINOR 증가 시, PATCH 는 0으로 초기화한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-29.-%EC%99%B8%EB%B6%80-API%EB%A5%BC-%EB%9E%A9wrap%ED%95%B4%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-29.-%EC%99%B8%EB%B6%80-API%EB%A5%BC-%EB%9E%A9wrap%ED%95%B4%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/</guid>
      <description>외부 API를 랩(wrap)해서 사용하라 # &amp;quot; API 설계자가 안전하지 않다고 하거나 API 설계자가 안전하다고 해도 우리가 그것을 제대로 신뢰할 수 없다면, 해당 API는 불안정한 것입니다. &amp;ldquo;
불안정한, 신뢰할 수 없는 API를 사용하는 것은 위험하다. 어쩔 수 없이 이런 API를 활용해야 한다면, 최대한 우리의 제품(로직)과 직접적인 결합을 만들지 않는 것이 좋다.
그래서 많은 프로젝트가 (잠재적으로 불안한 API에 대해서) 랩(wrap)해서 사용한다.
랩해서 사용하면 다음과 같은 장,단점이 있다.
장점 단점 - (해당 API에) 문제 발생 시, 래퍼(wrapper)만 변경하면 되므로 API 변경에 쉽게 대응할 수 있다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-50.-%EC%BB%AC%EB%A0%89%EC%85%98-%EC%B2%98%EB%A6%AC-%EB%8B%A8%EA%B3%84-%EC%88%98%EB%A5%BC-%EC%A0%9C%ED%95%9C%ED%95%98%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-50.-%EC%BB%AC%EB%A0%89%EC%85%98-%EC%B2%98%EB%A6%AC-%EB%8B%A8%EA%B3%84-%EC%88%98%EB%A5%BC-%EC%A0%9C%ED%95%9C%ED%95%98%EB%9D%BC/</guid>
      <description>컬렉션 처리 단계 수를 제한하라 # 모든 컬렉션 처리 메서드는 비용이 발생한다.
&amp;quot; 표준 컬렉션 처리는 내부적으로 요소들을 활용해 반복문을 돌며, 계산을 위해 추가적인 컬렉션을 만들어 사용합니다. 시퀀스 처리도 시퀀스 전체를 wrap하는 객체가 만들어지며, 조작을 위해서 또 다른 추가적인 객체를 만들어 냅니다. 두 처리 모두 요소의 수가 많다면, 꽤 큰 비용이 들어갑니다. &amp;ldquo;
따라서 적절한 메서드를 활용해서, 컬렉션 처리 단계 수를 적절하게 제한하는 것이 좋다.
class Student(val name: String?) // 작동은 합니다.</description>
    </item>
    
  </channel>
</rss>
