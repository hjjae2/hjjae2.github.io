<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>KOTLIN on thisandthat</title>
    <link>https://hjjae2.github.io/docs/LANGUAGES/KOTLIN/</link>
    <description>Recent content in KOTLIN on thisandthat</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://hjjae2.github.io/docs/LANGUAGES/KOTLIN/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/LANGUAGES/KOTLIN/KOTLIN-Companion-object-&#43;-static/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/LANGUAGES/KOTLIN/KOTLIN-Companion-object-&#43;-static/</guid>
      <description>Java에서 &amp;lsquo;static&amp;rsquo;은 다양한 이유로 사용할 수 있다. &amp;lsquo;메모리 관리&amp;rsquo;를 위해 &amp;lsquo;공유&amp;rsquo;를 위해 (클래스 선언 정보와 함께 메모리 영역에 올라간다.) companion object # 코틀린에서는 static 키워드가 없다.
이를 대체하기 위해 companion object 를 많이 사용한다.
(다른 말로 표현하면) (companion) object 를 통해 조금 더 (OOP와 적절한 방식으로)구현할 수 있다.
예시 코드 # class MyClass { companion object { fun doSomething() { } } } public final class MyClass { // 결국에 object 로 만들어서 사용하는 것인데, 이는 OOP 의 방향성에 아주 적절하다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/LANGUAGES/KOTLIN/KOTLIN-Naming-Convetion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/LANGUAGES/KOTLIN/KOTLIN-Naming-Convetion/</guid>
      <description>Source code organization # Source file names # UpperCamelCase
Source file organization # Placing multiple declarations (classes, top-level functions or properties) in the same Kotlin source file is encouraged as long as these declarations are closely related to each other semantically, and the file size remains reasonable (not exceeding a few hundred lines). In particular, when defining extension functions for a class which are relevant for all clients of this class, put them in the same file with the class itself.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/LANGUAGES/KOTLIN/KOTLIN-Nullable-types-and-non-null-types/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/LANGUAGES/KOTLIN/KOTLIN-Nullable-types-and-non-null-types/</guid>
      <description>코틀린에서는 nullable, non-nullable 타입을 구분하여 사용한다. # non-nullable # var a: String = &amp;#34;abc&amp;#34; a = null // X : 불가능 (컴파일 오류 발생) 변수 a 에는 non-null 이 보장되기에 아래와 같은 문법 사용 가능하다.
println(a.length) // O nullable # var a: String? = &amp;#34;abc&amp;#34; a = null // O : 가능 변수 a 에는 non-null 이 보장되지 않기에 아래와 같은 문법 사용 불가능하다.
println(a.length) // X : 불가능 (컴파일 오류 발생) 아래(nullable) 예시의 경우, property 를 접근/사용하기 위한 3가지 방법이 있다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/LANGUAGES/KOTLIN/KOTLIN-Scope-Functions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/LANGUAGES/KOTLIN/KOTLIN-Scope-Functions/</guid>
      <description>(객체의 컨텍스트 내에서) 임시 scope 를 생성하여 코드 블록(일련의 코드들)을 실행하기 위한 기능
다음과 같이 5개의 범위 함수(scope function)가 존재한다. # 공식 문서 - scope-functions/function-selection
Function Object reference Return value Is extension function? (TIP) 선택 기준 let it Lambda result O 1. non-null 객체의 lambda 실행 시 2. local 범위의 변수로 표현식 사용 시 run this Lambda result O 1. 객체 configuration + result 계산(반환) run - Lambda result X called without the context object 1.</description>
    </item>
    
  </channel>
</rss>
