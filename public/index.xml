<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>thisandthat</title>
    <link>https://hjjae2.github.io/</link>
    <description>Recent content on thisandthat</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://hjjae2.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/AWS/OpenSearch/01.-%EA%B0%9C%EC%9A%94/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/AWS/OpenSearch/01.-%EA%B0%9C%EC%9A%94/</guid>
      <description>OpenSearch # ES의 라이센스가 변경되면서, AWS 커뮤니티에서 개발/관리하는 (AWS 기반의)ES 프로젝트가 생겨났다. (참고 : 히스토리)
해당 (ES)라이선스는 오픈 소스가 아니며 사용자에게 동일한 자유를 제공하지 않습니다. 오픈 소스 커뮤니티와 고객이 계속해서 안전하고 고품질에 완전한 오픈 소스 검색과 분석 제품군을 사용할 수 있도록 AWS는 커뮤니티 주도적이며 오픈 소스 Elasticsearch 및 Kibana의 ALv2 라이선스 갈래인 OpenSearch 프로젝트를 도입했습니다.
이 AWS Elasticsearch 의 후속 서비스가 AWS OpenSearch 이다.
ISM (Index Statement Management, 인덱스 관리) # ISM(Index Statement Management)을 통해, 커스텀한 관리 정책(custom management policies)을 정의할 수 있다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-01.-%EA%B0%80%EB%B3%80%EC%84%B1%EC%9D%84-%EC%A0%9C%ED%95%9C%ED%95%98%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-01.-%EA%B0%80%EB%B3%80%EC%84%B1%EC%9D%84-%EC%A0%9C%ED%95%9C%ED%95%98%EB%9D%BC/</guid>
      <description>아이템 01. 가변성을 제한하라. # val # val 은 읽기 전용 프로퍼티지만, immutable 을 의미하는 것은 아니다. setter 를 제공하지 않을 뿐이다. (혼동하지 말 것)
immutable 이 필요하다면 final 키워드를 사용한다.
컬렉션 다운캐스팅 # 컬렉션 다운캐스팅은 계약을 위반하고, 추상화를 무시하는 행위다.
아래는 컬렉션 다운캐스팅의 간단한 예시이다.
val list = listOf(1,2,3) if (list is MutableList) { list.add(4) } JVM에서 listOf 는 자바의 List 인터페이스를 구현한 Array.ArrayList 객체를 리턴한다.
자바의 List 인터페이스는 add, set 과 같은 메서드를 제공하니까 코틀린에서 MutableList 로 변경될 수 있다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-02.-%EB%B3%80%EC%88%98%EC%9D%98-%EC%8A%A4%EC%BD%94%ED%94%84%EB%A5%BC-%EC%B5%9C%EC%86%8C%ED%95%98%ED%95%98%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-02.-%EB%B3%80%EC%88%98%EC%9D%98-%EC%8A%A4%EC%BD%94%ED%94%84%EB%A5%BC-%EC%B5%9C%EC%86%8C%ED%95%98%ED%95%98%EB%9D%BC/</guid>
      <description>변수의 스코프를 최소화하라 # 프로퍼티보다는 지역 변수를 사용하는 것이 좋다. 최대한 좁은 스코프를 갖게 변수를 사용한다. (예를 들어, 블록 내에서만 변수가 사용된다면 블록 내에서만 변수를 사용하는 것이 좋다.) 스코프를 좁게 만들어야 하는 가장 중요한 이유는 코드를 추적하고 관리하기 쉽기 때문이다.
변수를 정의할 때 초기화되는 것이 가장 좋다. (코틀린의) if, when, try-catch, Elvis 표현식, 구조분해 선언 등을 활용하여 변수 정의-초기화를 최대한 함께 처리할 수 있다.
캡처링 # 위의 예시 처럼 변수 선언 위치에 따라 결과가 달라지는 경우도 있다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-03.-%EC%B5%9C%EB%8C%80%ED%95%9C-%ED%94%8C%EB%9E%AB%ED%8F%BC-%ED%83%80%EC%9E%85%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EB%A7%90%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-03.-%EC%B5%9C%EB%8C%80%ED%95%9C-%ED%94%8C%EB%9E%AB%ED%8F%BC-%ED%83%80%EC%9E%85%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EB%A7%90%EB%9D%BC/</guid>
      <description>최대한 플랫폼 타입을 사용하지 말라 # 코틀린은 자바 등의 다른 프로그래밍 언어에서 넘어온 타입들을 특수하게 다룬다. 이 타입을 플랫폼 타입(platform type) 이라고 부른다.
플랫폼 타입은 ! 기호를 붙여서 표기한다. 예를 들면, String! 과 같다.
플랫폼 타입은 코틀린에서 non-nullable, nullable, platform type 변수로 받아 사용할 수 있다.
// 자바 public User getUser() { ... } // 코틀린 val user = getUser() // User! val user = getUser() // User val user = getUser() // User?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-04.-inferred-%ED%83%80%EC%9E%85%EC%9C%BC%EB%A1%9C-%EB%A6%AC%ED%84%B4%ED%95%98%EC%A7%80-%EB%A7%90%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-04.-inferred-%ED%83%80%EC%9E%85%EC%9C%BC%EB%A1%9C-%EB%A6%AC%ED%84%B4%ED%95%98%EC%A7%80-%EB%A7%90%EB%9D%BC/</guid>
      <description>inferred 타입으로 리턴하지 말라 # 타입 추론은 코틀린의 대표적인 특징이다. 다만, 타입 추론을 사용할 때 몇 가지 위험한 부분들이 있다.
(assign 구문에서) 타입 추론 시 슈퍼클래스 또는 인터페이스로 설정되지 않는다. # (assign 구문에서) 타입 추론 시 정확하게 오른쪽에 있는 피연산자에 맞게 설정된다.
슈퍼클래스, 혹은 인터페이스로 설정되지 않는다.
open class Animal class Zebra: Animal() fun main() { var animal = Zebra() // animal 타입은 Zebra animal = Animal() // 오류 : Type mismatch } 타입을 명시하면 아래와 같다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-05.-%EC%98%88%EC%99%B8%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%B4-%EC%BD%94%EB%93%9C%EC%97%90-%EC%A0%9C%ED%95%9C%EC%9D%84-%EA%B1%B8%EC%96%B4%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-05.-%EC%98%88%EC%99%B8%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%B4-%EC%BD%94%EB%93%9C%EC%97%90-%EC%A0%9C%ED%95%9C%EC%9D%84-%EA%B1%B8%EC%96%B4%EB%9D%BC/</guid>
      <description>예외를 활용해 코드에 제한을 걸어라 # &amp;quot; 확실하게 어떤 기능으로(형태로) 동작해야 하는 코드가 있다면, 예외를 활용해 제한을 걸어주는 것이 좋습니다. &amp;ldquo;
예외(제한)을 통해 가독성, 빠른 실패의 이점을 취할 수 있겠다.
코틀린에서는 제한을 걸 때 아래 기능을 사용할 수 있다.
기능 설명 require argument 를 대상으로 한다. argument에 제한을 건다. check 상태를 대상으로 한다. 상태를 확인(제한)할 때 사용할 수 있다. assert 말 그대로 assertion assert 블록은 테스트 모드에서만 작동한다. (?, 밑에 내용을 살펴보면 코틀린/JVM에서만 테스트 코드가 아닌 곳에서 사용할 수 있다고 한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-06.-%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EC%9D%98-%EC%98%A4%EB%A5%98%EB%B3%B4%EB%8B%A4%EB%8A%94-%ED%91%9C%EC%A4%80-%EC%98%A4%EB%A5%98%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-06.-%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%A0%95%EC%9D%98-%EC%98%A4%EB%A5%98%EB%B3%B4%EB%8B%A4%EB%8A%94-%ED%91%9C%EC%A4%80-%EC%98%A4%EB%A5%98%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/</guid>
      <description>사용자 정의 오류보다는 표준 오류를 사용하라 # 가능하다면, 직접 오류를 정의(커스텀 Exception)하는 것보다는 최대한 표준 라이브러리의 오류를 사용하는 것이 좋다. 표준 라이브러리의 사용은 범용성↑ 을 의미한다. (많은 개발자가 이미 알고 있다.)
잘 만들어진 규약을 재사용하는 것은 코드(API)를 더 쉽게 만드는 것이라고 볼 수 있다.
일반적으로 사용되는 Exception # 일반적으로 많이 사용되는 Exception 몇 가지를 살펴본다.
Exception 설명 IllegalArgumentException 생략 IllegalStateException 생략 IndexOutOfBoundsException 생략 ConcurrentModificationException 동시 수정(concurrent modification)을 금지했으나, 발생한 경우 UnsupportedOperationException 사용자가 사용하려는 메서드가 현재는 사용할 수 없는 상태(지원되지 않는 상태) 단, 기본적으로 사용할 수 없는 메서드는 코드(클래스)에 없는 것이 좋다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-07.-%EA%B2%B0%EA%B3%BC-%EB%B6%80%EC%A1%B1%EC%9D%B4-%EB%B0%9C%EC%83%9D%ED%95%A0-%EA%B2%BD%EC%9A%B0-null%EA%B3%BC-Failure%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-07.-%EA%B2%B0%EA%B3%BC-%EB%B6%80%EC%A1%B1%EC%9D%B4-%EB%B0%9C%EC%83%9D%ED%95%A0-%EA%B2%BD%EC%9A%B0-null%EA%B3%BC-Failure%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/</guid>
      <description>결과 부족이 발생할 경우 null과 Failure를 사용하라 # 함수가 원하는 결과를 만들어 낼 수 없는 경우가 있다. 이런 상황을 처리하는 메커니즘은 크게 두 가지가 있다.
null 또는 Failure를 나타내는 seald 클래스 예외 throw 위 두 가지는 중요한 차이점이 있다.
Exception (예외) # 예외는 정보를 전달하는 방법으로 사용해서는 안된다. 예외는 잘못된 특별한 상황을 나타내고 처리해야 한다.
immutable 컬렉션의 경우 명시적으로 Exception 을 사용하지 않던가&amp;hellip;🤔 어떻게 보느냐가 중요할 것 같다. 메시지 전달을 포함하여 잘못된 상황을 처리하는 것이기도 하니까.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-08.-%EC%A0%81%EC%A0%88%ED%95%98%EA%B2%8C-null%EC%9D%84-%EC%B2%98%EB%A6%AC%ED%95%98%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-08.-%EC%A0%81%EC%A0%88%ED%95%98%EA%B2%8C-null%EC%9D%84-%EC%B2%98%EB%A6%AC%ED%95%98%EB%9D%BC/</guid>
      <description>적절하게 null을 처리하라 # null은 &amp;lsquo;값이 부족하다(lack of value)&amp;lsquo;를 의미한다. 프로퍼티가 null이 라는 것은 값이 제대로 설정되지 않았다거나, 제거됐다는 것을 의미한다.
nullable 은 최대한 명확하게 처리해야한다. (String.toIntOrNull(), Iterable&amp;lt;T&amp;gt;.firstOrNull(() -&amp;gt; Boolean))
기본적으로 nullable 타입은 3 가지 방법으로 처리한다.
?., ?:, 스마트 캐스팅 등을 활용해서 처리한다. 오류를 throw 한다. (함수, 프로퍼티 리팩터링하여) non-nullable로 변경한다. null 안전하게 처리 # safe call (?., ?:), 스마트 캐스팅을 활용해서 null 을 안전하게 처리할 수 있다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-09.-use%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%EB%A6%AC%EC%86%8C%EC%8A%A4%EB%A5%BC-%EB%8B%AB%EC%95%84%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-09.-use%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%EB%A6%AC%EC%86%8C%EC%8A%A4%EB%A5%BC-%EB%8B%AB%EC%95%84%EB%9D%BC/</guid>
      <description>use를 사용하여 리소스를 닫아라 # java 의 try-with-resources 와 동일한 기능이겠다.
코틀린에서는 java의 try-with-resources 와 같은 기능으로 use, useLines 등을 사용할 수 있다.
모든 Closable 객체에 사용할 수 있다.
fun countCharactersInFile(path: String): Int { val reader = BufferedReader(FileReader(path)) reader.use { return reader.lineSequence().sumBy { it.length } } } fun countCharactersInFile(path: String): Int { BufferedReader(FileReader(path)).use { return reader.lineSequence().sumBy { it.length } } } fun countCharactersInFile(path: String): Int { File(path).useLines { lines -&amp;gt; return lines.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-10.-%EB%8B%A8%EC%9C%84-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-10.-%EB%8B%A8%EC%9C%84-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%9D%BC/</guid>
      <description>단위 테스트를 만들어라 # 이 아이템의 내용은 생략</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-11.-%EA%B0%80%EB%8F%85%EC%84%B1%EC%9D%84-%EB%AA%A9%ED%91%9C%EB%A1%9C-%EC%84%A4%EA%B3%84%ED%95%98%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-11.-%EA%B0%80%EB%8F%85%EC%84%B1%EC%9D%84-%EB%AA%A9%ED%91%9C%EB%A1%9C-%EC%84%A4%EA%B3%84%ED%95%98%EB%9D%BC/</guid>
      <description>코틀린은 간결성을 목표로 설계된 프로그래밍 언어가 아니라, 가독성을 좋게 하는 데 목표를 두고 설계된 프로그래밍 언어입니다.
간결성과 가독성을 혼동하지 말자. (책에서 말하는)간결성은 &amp;lsquo;짧음&amp;rsquo;과 조금 더 관계가 있다. 가독성은 &amp;lsquo;읽기 좋음&amp;rsquo;과 관계가 있다.
가독성을 목표로 설계하라 # 프로그래밍은 쓰기보다 읽기가 중요하다. (e.g. &amp;quot; 개발자가 코드를 작성하는 데는 1분 걸리지만, 이를 읽는 데는 10분이 걸린다. &amp;ldquo;)
인식 부하 감소 # 사용 빈도가 적은 관용구는 코드를 복잡하게 만든다. 이런 관용구들을 한 문장 내부에 조합해서 사용하면 복잡성은 훨씬 빠르게 증가한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-12.-%EC%97%B0%EC%82%B0%EC%9E%90-%EC%98%A4%EB%B2%84%EB%A1%9C%EB%93%9C%EB%A5%BC-%ED%95%A0-%EB%95%8C%EB%8A%94-%EC%9D%98%EB%AF%B8%EC%97%90-%EB%A7%9E%EA%B2%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-12.-%EC%97%B0%EC%82%B0%EC%9E%90-%EC%98%A4%EB%B2%84%EB%A1%9C%EB%93%9C%EB%A5%BC-%ED%95%A0-%EB%95%8C%EB%8A%94-%EC%9D%98%EB%AF%B8%EC%97%90-%EB%A7%9E%EA%B2%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/</guid>
      <description>연산자 오버로드를 할 때는 의미에 맞게 사용하라 # 연산자 오버로딩은 그 이름의 의미에 맞게 사용하자. 적절하게 사용하지 못할 것 같다면, 오버로딩을 하지 않는 것이 좋다. (이때는 일반 함수를 쓰자)
연산자 같은 형태로 사용하고 싶다면 infix 확장 함수, Top-Level 함수를 활용할 수 있다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-13.-Unit%EC%9D%84-%EB%A6%AC%ED%84%B4%ED%95%98%EC%A7%80-%EB%A7%90%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-13.-Unit%EC%9D%84-%EB%A6%AC%ED%84%B4%ED%95%98%EC%A7%80-%EB%A7%90%EB%9D%BC/</guid>
      <description>Unit? 을 리턴하지 말라 # fun keyIsCorrect(key: String): Boolean = //... if(!keyIsCorrect(key)) { // 로직 } fun keyIsCorrect(key: String): Unit? = //... keyIsCorrect(key) ?: // 로직 위 코드를 보면, Unit? 의 경우에도 ?:, ?.let 등을 활용해 Boolean 처럼 쓸 수 있다.
하지만 이 형태는 좋지 않다. 예측하기 어려운 오류를 만들어 낼 수 있다.
예시
getData()?.let { view.showData(it) } ?: view.showError() 위 코드에서 getData 가 null 이 아니고, showData(it)가 null 인 상황이면 showData, showError 가 모두 호출된다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-14.-%EB%B3%80%EC%88%98-%ED%83%80%EC%9E%85%EC%9D%B4-%EB%AA%85%ED%99%95%ED%95%98%EC%A7%80-%EC%95%8A%EC%9D%80-%EA%B2%BD%EC%9A%B0-%ED%99%95%EC%8B%A4%ED%95%98%EA%B2%8C-%EC%A7%80%EC%A0%95%ED%95%98%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-14.-%EB%B3%80%EC%88%98-%ED%83%80%EC%9E%85%EC%9D%B4-%EB%AA%85%ED%99%95%ED%95%98%EC%A7%80-%EC%95%8A%EC%9D%80-%EA%B2%BD%EC%9A%B0-%ED%99%95%EC%8B%A4%ED%95%98%EA%B2%8C-%EC%A7%80%EC%A0%95%ED%95%98%EB%9D%BC/</guid>
      <description>변수 타입이 명확하지 않은 경우 확실하게 지정하라 # 코틀린의 타입 추론 시스템은 매우 편리하다.
하지만 타입을 명확하게 보여주지 않는 것은 좋지 않다.
// data 의 타입이 무엇인지 바로 알 수 없다. val data = getSomeData() // 다음과 같이 표현하는 것이 좋다. val data: UserData = getSomeData() 가독성을 위해 코드를 작성/설계할 때는 읽는 사람에게 중요한 정보를 숨겨선 안된다. 가독성 향상 이외에 안전을 위해서라도 타입을 지정하는 것이 좋다.
함수 정의를 보면 되지 않나?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-15.-%EB%A6%AC%EC%8B%9C%EB%B2%84%EB%A5%BC-%EB%AA%85%EC%8B%9C%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%B0%B8%EC%A1%B0%ED%95%98%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-15.-%EB%A6%AC%EC%8B%9C%EB%B2%84%EB%A5%BC-%EB%AA%85%EC%8B%9C%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%B0%B8%EC%A1%B0%ED%95%98%EB%9D%BC/</guid>
      <description>리시버를 명시적으로 참조하라 # 여러 개의 리시버 # 스코프 내부에 둘 이상의 리시버가 있는 경우, 리시버를 명시적으로 나타내면 좋다. 즉 리시버가 헷갈릴 수 있는 경우, 명시적으로 표현하자.
또, 리시버가 중첩되는 경우 목적에 맞는 함수를 잘 구분해서 쓰자. (e.g. let, apply, also, with, run)
class Node(val name: String) { fun makeChild(childName: String) { create(&amp;#34;$name.$childName&amp;#34;).apply { print(&amp;#34;Created ${this?.name} in ${this@Node.name}&amp;#34;) // this@Node와 같이 label 을 활용할 수 있다. } } } label 없이 리시버 사용하면, 가장 가까운 리시버를 의미한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-16.-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EB%8A%94-%EB%8F%99%EC%9E%91%EC%9D%B4-%EC%95%84%EB%8B%88%EB%9D%BC-%EC%83%81%ED%83%9C%EB%A5%BC-%EB%82%98%ED%83%80%EB%82%B4%EC%95%BC-%ED%95%9C%EB%8B%A4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-16.-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EB%8A%94-%EB%8F%99%EC%9E%91%EC%9D%B4-%EC%95%84%EB%8B%88%EB%9D%BC-%EC%83%81%ED%83%9C%EB%A5%BC-%EB%82%98%ED%83%80%EB%82%B4%EC%95%BC-%ED%95%9C%EB%8B%A4/</guid>
      <description>프로퍼티는 동작이 아니라 상태를 나타내야 한다. # 코틀린의 프로퍼티는 자바의 필드랑 비슷해 보이지만, 서로 완전히 다른 개념이다.
둘 다 데이터를 저장한다는 점은 같다. 하지만 프로퍼티에는 더 많은 기능이 있다.
프로퍼티 # 사용자 정의 getter/setter 가질 수 있다. val 프로퍼티에는 백킹 필드가 만들어지지 않는다. 필드가 필요 없다. 프로퍼티는 개념적으로 &amp;lsquo;접근자&amp;rsquo;를 나타낸다. 따라서 코틀린에서는 인터페이스에서도 프로퍼티를 정의할 수 있다. (아래 &amp;lsquo;예시 1&amp;rsquo; 참고) 위임(property delegate)할 수 있다. 프로퍼티는 본질적으로 함수이다. 확장 프로퍼티를 만들 수 있다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-17.-%EC%9D%B4%EB%A6%84-%EC%9E%88%EB%8A%94-%EC%95%84%EA%B7%9C%EB%A8%BC%ED%8A%B8%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-17.-%EC%9D%B4%EB%A6%84-%EC%9E%88%EB%8A%94-%EC%95%84%EA%B7%9C%EB%A8%BC%ED%8A%B8%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/</guid>
      <description>이름 있는 아규먼트를 사용하라 # 장점은 다음과 같다.
이름을 기반으로 값이 무엇을 나타내는지 알 수 있다. 파라미터 입력 순서와 상관 없으므로 안전하다. 함수 타입 파라미터 # 함수 타입 파라미터는 마지막 위치에 배치하는 것이 좋다.
:thinking: (책에서 이렇게 말한)이유가 무엇인지?
참고로, 코틀린에서는 마지막에 위치한 함수 타입의 경우 람다를 이용할 수 있다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-18.-%EC%BD%94%EB%94%A9-%EC%BB%A8%EB%B2%A4%EC%85%98%EC%9D%84-%EC%A7%80%EC%BC%9C%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-18.-%EC%BD%94%EB%94%A9-%EC%BB%A8%EB%B2%A4%EC%85%98%EC%9D%84-%EC%A7%80%EC%BC%9C%EB%9D%BC/</guid>
      <description>코딩 컨벤션을 지켜라 # 코드는 마치 한 사람이 작성한 것 처럼 작성돼야 한다.
코딩 컨벤션을 지켜야 하는 이유는 다음과 같다.
이해하기 쉽다. (인지 부하 감소) 코드 병합, 리팩터링이 쉬워진다. IntelliJ 의 경우 Code Style - Kotlin - Predefined style/Kotlin style guide 를 이용할 수 있다. (= 공식 코딩 컨벤션 스타일)</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-19.-knowledge%EB%A5%BC-%EB%B0%98%EB%B3%B5%ED%95%98%EC%97%AC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EB%A7%90%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-19.-knowledge%EB%A5%BC-%EB%B0%98%EB%B3%B5%ED%95%98%EC%97%AC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EB%A7%90%EB%9D%BC/</guid>
      <description>knowledge를 반복하여 사용하지 말라 # &amp;quot; 프로젝트에서 이미 있던 코드를 복사해서 붙여넣고 있다면, 무언가가 잘못된 것이다. &amp;quot;
규모가 작은 것들(예를 들어, 함수, 단일 클래스 등)은 재사용할 수 있게 잘 추출해서 정리하고 있다. 다만, 최근에 규모가 큰 것(패키지 단위)에 대해서 복붙한 경험이 있다. 공통 모듈로 분리할 수 있었지만 깊이 있게 고민하지 않고 넘어갔다. :thinking:
DRY, WET 안티패턴(We Enjoy Typing, Waste Everyone&amp;rsquo;s Time or Write Everthing Twice), SSOT(Single Source of Truth)</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-20.-%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9D%B8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%84-%EB%B0%98%EB%B3%B5%ED%95%B4%EC%84%9C-%EA%B5%AC%ED%98%84%ED%95%98%EC%A7%80-%EB%A7%90%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-20.-%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9D%B8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%84-%EB%B0%98%EB%B3%B5%ED%95%B4%EC%84%9C-%EA%B5%AC%ED%98%84%ED%95%98%EC%A7%80-%EB%A7%90%EB%9D%BC/</guid>
      <description>일반적인 알고리즘을 반복해서 구현하지 말라 # 여기서 말하는 알고리즘은 특정 프로젝트에 국한된 것이 아니라 정말 일반적인(수학 연산과 같은)것들을 말한다.
(깨알 TIP) 아래 코드는 권장되지 않는 코드다. 팩토리 메서드를 활용하거나 기본 생성자를 활용하는 것이 좋다.
item.sources.forEach { var sourceEntity = SourceEntity() sourceEntity.id = it.id sourceEntity.category = it.category ... } 널리 알려진, 일반적으로 모두 이해할 수 있는 것들은(수학 연산과 같은), 꼭 여러 번 재사용되지 않는다고 해도 공통으로 추출하는 것이 좋다. 예를 들면 아래와 같다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-21.-%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9D%B8-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%ED%8C%A8%ED%84%B4%EC%9D%80-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%9C%84%EC%9E%84%EC%9C%BC%EB%A1%9C-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-21.-%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9D%B8-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%ED%8C%A8%ED%84%B4%EC%9D%80-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%9C%84%EC%9E%84%EC%9C%BC%EB%A1%9C-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%9D%BC/</guid>
      <description>일반적인 프로퍼티 패턴은 프로퍼티 위임으로 만들어라 # 프로퍼티 위임을 사용하면 일반적인 프로퍼티 행위를 추출해서 재사용할 수 있다. 또, 프로퍼티 위임 메커니즘을 통해 다양한 패턴들을 만들 수 있다.
프로퍼티 위임은 프로퍼티 패턴을 추출하는 일반적인 방법이라 많이 사용되고 있다.
lazy, observable, 뷰, 리소스 바인딩, 의존성 주입, 데이터 바인딩 등의 사용 예시가 있겠다.
// 예시 : lazy val value by lazy { createValue() } // 예시 : observable var items: List&amp;lt;Item&amp;gt; by Delegates.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-22.-%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9D%B8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%84-%EA%B5%AC%ED%98%84%ED%95%A0-%EB%95%8C-%EC%A0%9C%EB%84%A4%EB%A6%AD%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-22.-%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9D%B8-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%84-%EA%B5%AC%ED%98%84%ED%95%A0-%EB%95%8C-%EC%A0%9C%EB%84%A4%EB%A6%AD%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/</guid>
      <description>일반적인 알고리즘을 구현할 때 제네릭을 사용하라 # 타입 아규먼트를 사용하면 함수에 타입을 전달할 수 있다. 타입 아규먼트를 사용하는 함수를 제네릭 함수라고 부른다.
&amp;quot; 제네릭은 List 또는 Set 처럼 구체적인 타입으로 컬렉션을 만들 수 있게 클래스와 인터페이스에 도입된 기능입니다. &amp;ldquo;
제네릭 제한 # 구체적인 타입의 서브타입만 허용하도록 제한할 수도 있다.
// 콜론 뒤에 상위 타입 명시 `T: Comparable&amp;lt;T&amp;gt;` fun &amp;lt;T : Comparable&amp;lt;T&amp;gt;&amp;gt; Iterable&amp;lt;T&amp;gt;.sorted(): List&amp;lt;T&amp;gt; { ... 많이 사용하는 제한 타입으로 Any 가 있다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-23.-%ED%83%80%EC%9E%85-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EC%9D%98-%EC%84%80%EB%8F%84%EC%9E%89%EC%9D%84-%ED%94%BC%ED%95%98%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-23.-%ED%83%80%EC%9E%85-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EC%9D%98-%EC%84%80%EB%8F%84%EC%9E%89%EC%9D%84-%ED%94%BC%ED%95%98%EB%9D%BC/</guid>
      <description>타입 파라미터의 섀도잉을 피하라 # interface Tree class Birch: Tree class Spruce: Tree class Forest&amp;lt;T: Tree&amp;gt; { fun &amp;lt;T: Tree&amp;gt; addTree(tree: T) { // ... } } Forest와 addTree의 타입 파라미터는 독립적이다. (관계가 없다.)
val forest = Forest&amp;lt;Birch&amp;gt;() forest.addTree(Birch()) forest.addTree(Spruce()) (아마도 대부분의 경우) 위 코드는 개발자가 의도한 것이 아닐 것이다. 따라서 오류가 발생한다는 것을 알아차리기 쉽지 않다.
[수정 1] 다음과 같이 작성하는 것이 올바를 것이다.
class Forest&amp;lt;T: Tree&amp;gt; { fun addTree(tree: T) { // 클래스의 타입 파라미터를 사용하도록 수정한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-24.-%EC%A0%9C%EB%84%A4%EB%A6%AD-%ED%83%80%EC%9E%85%EA%B3%BC-variance-%ED%95%9C%EC%A0%95%EC%9E%90%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%98%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-24.-%EC%A0%9C%EB%84%A4%EB%A6%AD-%ED%83%80%EC%9E%85%EA%B3%BC-variance-%ED%95%9C%EC%A0%95%EC%9E%90%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%98%EB%9D%BC/</guid>
      <description>제네릭 타입과 variance 한정자를 활용하라 # class Cup&amp;lt;T&amp;gt; 위 코드에서 (타입 파라미터)T는 variacne 한정자(out 또는 in)가 없으므로, invariant(불공변성)이다.
invariant 는 제네릭 타입으로 만들어지는 타입들이 서로 아무 관계가 없다는 것을 의미한다. (e.g., Cup&amp;lt;Coffee&amp;gt;, Cup&amp;lt;Int&amp;gt;, Cup&amp;lt;Any&amp;gt;, Cup&amp;lt;Nothing&amp;gt;)
만약 제네릭 타입으로 만들어지는 타입에 관련성을 원한다면, variance 한정자(out 또는 in)를 사용한다.
variance 설명 out covariance (공변성) in contravariant(반변성) out (covariance) # class Cup&amp;lt;out T&amp;gt; open class Dog class Puppy: Dog() fun main(args: Array&amp;lt;String&amp;gt;) { val a: Cup&amp;lt;Dog&amp;gt; = Cup&amp;lt;Puppy&amp;gt;() // OK val b: Cup&amp;lt;Puppy&amp;gt; = Cup&amp;lt;Dog&amp;gt;() // ERROR } in (contravariant) # class Cup&amp;lt;in T&amp;gt; open class Dog class Puppy: Dog() fun main(args: Array&amp;lt;String&amp;gt;) { val a: Cup&amp;lt;Dog&amp;gt; = Cup&amp;lt;Puppy&amp;gt;() // ERROR val b: Cup&amp;lt;Puppy&amp;gt; = Cup&amp;lt;Dog&amp;gt;() // OK } variant, invariant 정리 # 함수 타입 # 함수타입은 파라미터 타입과 리턴 타입에 따라 서로 어떤 관계를 갖는다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-25.-%EA%B3%B5%ED%86%B5-%EB%AA%A8%EB%93%88%EC%9D%84-%EC%B6%94%EC%B6%9C%ED%95%B4%EC%84%9C-%EC%97%AC%EB%9F%AC-%ED%94%8C%EB%9E%AB%ED%8F%BC%EC%97%90%EC%84%9C-%EC%9E%AC%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-25.-%EA%B3%B5%ED%86%B5-%EB%AA%A8%EB%93%88%EC%9D%84-%EC%B6%94%EC%B6%9C%ED%95%B4%EC%84%9C-%EC%97%AC%EB%9F%AC-%ED%94%8C%EB%9E%AB%ED%8F%BC%EC%97%90%EC%84%9C-%EC%9E%AC%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/</guid>
      <description> 공통 모듈을 추출해서 여러 플랫폼에서 재사용하라 # 함께 사용하기 # 코틀린/JVM 을 사용한 백엔드 개발 : Spring, Ktor 등 코틀린/JVM 을 사용한 데스크톱(애플리케이션) 개발 : TornatoFX 등 코틀린/JVM 을 사용한 안드로이드 개발 : Android SDK 등 코틀린/JS 을 사용한 프론트 개발 : React 등 코틀린/네이티브 을 사용한 IOS 개발 코틀린/네이티브 을 사용한 라즈베리파이, 리눅스, macOS 프로그램 개발 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-26.-%ED%95%A8%EC%88%98-%EB%82%B4%EB%B6%80%EC%9D%98-%EC%B6%94%EC%83%81%ED%99%94-%EB%A0%88%EB%B2%A8%EC%9D%84-%ED%86%B5%EC%9D%BC%ED%95%98%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-26.-%ED%95%A8%EC%88%98-%EB%82%B4%EB%B6%80%EC%9D%98-%EC%B6%94%EC%83%81%ED%99%94-%EB%A0%88%EB%B2%A8%EC%9D%84-%ED%86%B5%EC%9D%BC%ED%95%98%EB%9D%BC/</guid>
      <description>&amp;quot; 컴퓨터 과학에서 추상화는 복잡한 자료, 모듈, 시스템 등으로부터 핵심적인 개념 또는 기능을 간추려 내는 것을 말한다. &amp;hellip; 조금 간단하게 표현하면, 추상화는 복잡성을 숨기기 위해 사용되는 방식을 의미한다. &amp;ldquo;
인터페이스는 클래스라는 복잡한 것에서 메서드, 프로퍼티만 추출해서 간단하게 만들었으므로 클래스의 추상화라고 볼 수 있다.
추상화를 하려면 무엇을 감추고 무엇을 노출해야 하는지 결정해야 한다. (잘 결정하지 못하면 추상화 능력이 떨어진다고 볼 수 있다.)
일반적으로 프로그래밍에서는 다음과 같은 목적으로 추상화를 사용한다.
복잡성을 숨기기 위해 코드를 체계화 하기 위해 만드는 사람에게 변화의 자유를 주기 위해 = 쉽게 확장할 수 있고, 수정할 수 있도록 하기 위해 함수 내부의 추상화 레벨을 통일하라 # 계층이 잘 분리되면 좋은 점은 다음과 같다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-27.-%EB%B3%80%ED%99%94%EB%A1%9C%EB%B6%80%ED%84%B0-%EC%BD%94%EB%93%9C%EB%A5%BC-%EB%B3%B4%ED%98%B8%ED%95%98%EB%A0%A4%EB%A9%B4-%EC%B6%94%EC%83%81%ED%99%94%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-27.-%EB%B3%80%ED%99%94%EB%A1%9C%EB%B6%80%ED%84%B0-%EC%BD%94%EB%93%9C%EB%A5%BC-%EB%B3%B4%ED%98%B8%ED%95%98%EB%A0%A4%EB%A9%B4-%EC%B6%94%EC%83%81%ED%99%94%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/</guid>
      <description>변화로부터 코드를 보호하려면 추상화를 사용하라 # &amp;quot; 함수와 클래스 등의 추상화로 실질적인 코드를 숨기면, 사용자가 세부 사항을 알지 못해도 괜찮다는 장점이 있습니다. 그리고 이후에 실질적인 코드를 원하는대로 수정할 수도 있습니다. &amp;ldquo;
&amp;rdquo; 추상화는 더 많은 자유를 주지만, 이를 정의하고, 사용하고, 이해하는 것이 조금 어려워질 수 있습니다. &amp;ldquo;
추상화 사례 1. 상수 # 리터럴은 아무것도 설명하지 않는다.
리터럴을 상수 프로퍼티로 변경하면 해당 값에 의미를 부여할 수 있다. 그래서 두 번 이상 사용되는 값은 상수 프로퍼티(변수)로 만드는 것이 좋다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-28.-API-%EC%95%88%EC%A0%84%EC%84%B1%EC%9D%84-%ED%99%95%EC%9D%B8%ED%95%98%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-28.-API-%EC%95%88%EC%A0%84%EC%84%B1%EC%9D%84-%ED%99%95%EC%9D%B8%ED%95%98%EB%9D%BC/</guid>
      <description>API 안전성을 확인하라 # API 또는 API의 일부가 불안정하다면, 작성자/개발자가 이를 명확하게 알려줘야 한다.
일반적으로 버전을 활용해서 라이브러리, 모듈의 안전성을 나타낸다.
많은 버저닝 시스템이 있지만 일반적으로 사용되는 것은 **시멘틱 버저닝(Semantic Versioning, SemVer)**이다.
시멘틱 버저닝의 표기법은 {MAJOR}.{MINOR}.{PATCH} 이다. 각각의 부분은 0 이상의 정수로 구성되고, 변경 마다 1씩 증가시킨다.
구분 설명 비고 MAJOR 호환되지 않는 수준의 API 변경 MAJOR 증가 시, MINOR, PATCH 는 0으로 초기화한다. MINOR 이전 변경과 호환되는 기능 추가 MINOR 증가 시, PATCH 는 0으로 초기화한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-29.-%EC%99%B8%EB%B6%80-API%EB%A5%BC-%EB%9E%A9wrap%ED%95%B4%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-29.-%EC%99%B8%EB%B6%80-API%EB%A5%BC-%EB%9E%A9wrap%ED%95%B4%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/</guid>
      <description>외부 API를 랩(wrap)해서 사용하라 # &amp;quot; API 설계자가 안전하지 않다고 하거나 API 설계자가 안전하다고 해도 우리가 그것을 제대로 신뢰할 수 없다면, 해당 API는 불안정한 것입니다. &amp;ldquo;
불안정한, 신뢰할 수 없는 API를 사용하는 것은 위험하다. 어쩔 수 없이 이런 API를 활용해야 한다면, 최대한 우리의 제품(로직)과 직접적인 결합을 만들지 않는 것이 좋다.
그래서 많은 프로젝트가 (잠재적으로 불안한 API에 대해서) 랩(wrap)해서 사용한다.
랩해서 사용하면 다음과 같은 장,단점이 있다.
장점 단점 - (해당 API에) 문제 발생 시, 래퍼(wrapper)만 변경하면 되므로 API 변경에 쉽게 대응할 수 있다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-50.-%EC%BB%AC%EB%A0%89%EC%85%98-%EC%B2%98%EB%A6%AC-%EB%8B%A8%EA%B3%84-%EC%88%98%EB%A5%BC-%EC%A0%9C%ED%95%9C%ED%95%98%EB%9D%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%EC%BD%94%ED%8B%80%EB%A6%B0/%EC%95%84%EC%9D%B4%ED%85%9C-50.-%EC%BB%AC%EB%A0%89%EC%85%98-%EC%B2%98%EB%A6%AC-%EB%8B%A8%EA%B3%84-%EC%88%98%EB%A5%BC-%EC%A0%9C%ED%95%9C%ED%95%98%EB%9D%BC/</guid>
      <description>컬렉션 처리 단계 수를 제한하라 # 모든 컬렉션 처리 메서드는 비용이 발생한다.
&amp;quot; 표준 컬렉션 처리는 내부적으로 요소들을 활용해 반복문을 돌며, 계산을 위해 추가적인 컬렉션을 만들어 사용합니다. 시퀀스 처리도 시퀀스 전체를 wrap하는 객체가 만들어지며, 조작을 위해서 또 다른 추가적인 객체를 만들어 냅니다. 두 처리 모두 요소의 수가 많다면, 꽤 큰 비용이 들어갑니다. &amp;ldquo;
따라서 적절한 메서드를 활용해서, 컬렉션 처리 단계 수를 적절하게 제한하는 것이 좋다.
class Student(val name: String?) // 작동은 합니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-01.-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%99%80-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-%EA%B4%80%EA%B3%84-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-01.-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%99%80-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-%EA%B4%80%EA%B3%84-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/</guid>
      <description>&amp;quot; 타입스크립트는 인터프리터 언어로 실행되는 것도 아니고, (Java, C 같이)저수준 언어로 컴파일 되는 것도 아닙니다. 또 다른 고수준 언어인 &amp;lsquo;자바스크립트&amp;rsquo;로 컴파일되며, 실행 역시 타입스크립트가 아닌 자바스크립트로 이루어집니다. 그래서 타입스크립트와 자바스크립트의 관계는 필연적이며, 이 밀접한 관계 때문에 혼란스러운 일이 벌어지기도 합니다. &amp;quot; (1장 소개말 중)
아이템 1. 타입스크립트와 자바스크립트의 관계 이해하기 # 타입스크립트는 자바스크립트의 상위 집합 모든 &amp;lsquo;자바스크립트&amp;rsquo; 는 &amp;lsquo;타입스크립트&amp;rsquo; 이다. (참) 모든 &amp;lsquo;타입스크립트&amp;rsquo; 는 &amp;lsquo;자바스크립트&amp;rsquo; 이다. (거짓) 타입스크립트 중에는 자바스크립트가 아닌 프로그램이 존재한다고 한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-02.-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%84%A4%EC%A0%95-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-02.-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%84%A4%EC%A0%95-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/</guid>
      <description>아이템 2. 타입스크립트 설정 이해하기 # 타입스크립트 컴파일러(타입 체커)는 매우 많은 설정을 가지고 있다.
설정 방법 예시 커맨드 라인 (cli) tsc --noImplicitAny program.ts 파일 (file) tsconfig.json 참고 : tsc --init 통해 파일 생성 가능하다. 중요/권장 설정 : noImplicitAny
타입을 미리 정의하여 사용할 것인지 설정하는 것
값 설명 true 타입을 미리 정의해야 한다. 타입스크립트는 타입 정보를 설정/체크할 때 가장 효과적이기 때문에, 되도록 true 설정을 권장한다. false (기존 자바스크립트와 같이) 타입을 미리 정의하지 않아도 된다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-03.-%EC%BD%94%EB%93%9C-%EC%83%9D%EC%84%B1%EA%B3%BC-%ED%83%80%EC%9E%85%EC%9D%B4-%EA%B4%80%EA%B3%84%EC%97%86%EC%9D%8C%EC%9D%84-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-03.-%EC%BD%94%EB%93%9C-%EC%83%9D%EC%84%B1%EA%B3%BC-%ED%83%80%EC%9E%85%EC%9D%B4-%EA%B4%80%EA%B3%84%EC%97%86%EC%9D%8C%EC%9D%84-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/</guid>
      <description>아이템 3. 코드 생성과 타입이 관계없음을 이해하기 # 타입스크립트는 두 가지 역할(트랜스파일, 컴파일)을 수행한다. # 1. 최신 타입스크립트/자바스크립트를 (브라우저에서 동작할 수 있도록) 구버전의 자바스크립트로 트랜스파일(transpile)한다. 2. 코드의 타입 오류를 체크한다.
트랜스파일, 타입 체크는 완벽히 독립적이다. 트랜스파일이 잘못되어도 타입 체크는 실행될 수 있다. 타입 체크가 잘못되어도 트랜스파일은 실행될 수 있다. 타입 오류가 있는 코드도 컴파일(트랜스파일)이 가능하다. # » cat test.ts let x = &amp;#39;hello&amp;#39;; x = 1234; » tsc test.ts test.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-04.-%EA%B5%AC%EC%A1%B0%EC%A0%81-%ED%83%80%EC%9D%B4%ED%95%91%EC%97%90-%EC%9D%B5%EC%88%99%ED%95%B4%EC%A7%80%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-04.-%EA%B5%AC%EC%A1%B0%EC%A0%81-%ED%83%80%EC%9D%B4%ED%95%91%EC%97%90-%EC%9D%B5%EC%88%99%ED%95%B4%EC%A7%80%EA%B8%B0/</guid>
      <description>아이템 4. 구조적 타이핑에 익숙해지기 # 자바스크립트는 본질적으로 &amp;lsquo;덕 타이핑(duck typing)&amp;rsquo; 기반이다. # 덕타이핑이란? 어떤 값에 필요한 속성, 메서드가 존재한다면 그냥 사용하는 것을 의미한다.
타입스크립트는 자바스크립트의 런타임 동작을 모델링한다. 덕타이핑을 모델링하기 위해 &amp;lsquo;구조적 타이핑&amp;rsquo; 기법을 사용한다. (올바른 표현인가&amp;hellip;?)
interface Vector2D { x: number; y: number; } interface NamedVector2D { name: string; x: number; y: number; } function calculateLength(v: Vector2D) { return Math.sqrt(v.x * v.x + v.y * v.y); } » tsc example.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-05.-any-%ED%83%80%EC%9E%85-%EC%A7%80%EC%96%91%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-05.-any-%ED%83%80%EC%9E%85-%EC%A7%80%EC%96%91%ED%95%98%EA%B8%B0/</guid>
      <description>아이템 5. any 타입 지양하기 # 타입스크립트 타입 시스템은 &amp;lsquo;점진적(gradual)&amp;rsquo;, &amp;lsquo;선택적(optional)&amp;rsquo; 이다.
점진적 : 코드에 타입을 조금씩 추가할 수 있다. 선택적 : 언제든지 타입 체킹을 해제할 수 있다. 이 기능의 핵심은 &amp;lsquo;any&amp;rsquo; 타입이다.
하지만 (일부 특별한 경우를 제외하고는) any 를 사용하지 않는 것을 권장한다.
any 타입에는 &amp;lsquo;타입 안정성&amp;rsquo;이 없다. # 예시 : any 사용 X
let age: number; age = &amp;#39;12&amp;#39;; // 에러 발생 (error TS2322: Type &amp;#39;string&amp;#39; is not assignable to type &amp;#39;number&amp;#39;.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-06.-%ED%8E%B8%EC%A7%91%EA%B8%B0%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%ED%83%80%EC%9E%85-%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%83%90%EC%83%89%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-06.-%ED%8E%B8%EC%A7%91%EA%B8%B0%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%ED%83%80%EC%9E%85-%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%83%90%EC%83%89%ED%95%98%EA%B8%B0/</guid>
      <description>아이템 6. 편집기를 사용하여 타입 시스템 탐색하기 # 타입스크립트 설치 시, 다음 두 가지를 실행할 수 있다.
타입스크립트 컴파일러 : tsc 타입스크립트 서버 : tsserver &amp;quot; 보통은 타입스크립트 컴파일러를 실행하는 것이 주된 목적이지만, 타입스크립트 서버 또한 &amp;lsquo;언어 서비스&amp;rsquo;를 제공한다는 점에서 중요합니다. &amp;ldquo;
여기서 말하는 &amp;lsquo;언어 서비스&amp;rsquo;란? 자동 완성, 검색, 검사, 리팩터링 등을 의미한다. (예를 들면, IDE 에서 도와주는 기능들)
이번 아이템에서는 IDE, 편집기에서 제공하는 언어 서비스에 대해 설명한다.
상세한 내용은 생략한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-07.-%ED%83%80%EC%9E%85%EC%9D%B4-%EA%B0%92%EB%93%A4%EC%9D%98-%EC%A7%91%ED%95%A9%EC%9D%B4%EB%9D%BC%EA%B3%A0-%EC%83%9D%EA%B0%81%ED%95%98%EA%B8%B0-todo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-07.-%ED%83%80%EC%9E%85%EC%9D%B4-%EA%B0%92%EB%93%A4%EC%9D%98-%EC%A7%91%ED%95%A9%EC%9D%B4%EB%9D%BC%EA%B3%A0-%EC%83%9D%EA%B0%81%ED%95%98%EA%B8%B0-todo/</guid>
      <description>아이템 7. 타입이 갑들의 집합이라고 생각하기 # 7장은 다시 확인/이해가 필요하다.
&amp;lsquo;할당 가능한 값들의 집합(범위)&amp;rsquo; = &amp;lsquo;타입&amp;rsquo; 이라고 생각하면 된다. 예를 들어, 모든 숫자값의 집합(범위)는 number 타입이다. 1. 가장 작은 집합 = 아무 값도 포함하지 않는 공집합 = never
const x: neber = 12; // ~ &amp;#39;12&amp;#39; 형식은 &amp;#39;never&amp;#39; 형식에 할당할 수 없습니다. 2. 그 다음으로 작은 집합 = 한 가지 값만 포함하는 타입 = unit (literal)
type A = &amp;#39;A&amp;#39;; type B = &amp;#39;B&amp;#39;; type Twelve = &amp;#39;12&amp;#39;; 3.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-08.-%ED%83%80%EC%9E%85-%EA%B3%B5%EA%B0%84%EA%B3%BC-%EA%B0%92-%EA%B3%B5%EA%B0%84%EC%9D%98-%EC%8B%AC%EB%B2%8C-%EA%B5%AC%EB%B6%84%ED%95%98%EA%B8%B0-todo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-08.-%ED%83%80%EC%9E%85-%EA%B3%B5%EA%B0%84%EA%B3%BC-%EA%B0%92-%EA%B3%B5%EA%B0%84%EC%9D%98-%EC%8B%AC%EB%B2%8C-%EA%B5%AC%EB%B6%84%ED%95%98%EA%B8%B0-todo/</guid>
      <description>아이템 8. 타입 공간과 값 공간의 심벌 구분하기 # 타입스크립트의 심벌(symbol)은 타입 공간, 값 공간 중 한 곳에 존재한다.
쉽게 말하면, 같은 네이밍을 가진 심벌은 타입이 될 수도, 값이 될 수도 있다는 의미이다.
// &amp;#39;Cylinder&amp;#39; 라는 심볼은 &amp;#39;타입&amp;#39;이다. interface Cylinder { radius: number; height: number; } // &amp;#39;Cylinder&amp;#39; 라는 심볼은 &amp;#39;값&amp;#39;이다. const Cylinder = { radius: number, height: number} =&amp;gt; ({ radius, height }); 한 심벌이 &amp;lsquo;타입&amp;rsquo;인지, &amp;lsquo;값&amp;rsquo;인지 알기 위해서는 &amp;lsquo;문맥&amp;rsquo;을 살펴 알아냐애 한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-09.-%ED%83%80%EC%9E%85-%EB%8B%A8%EC%96%B8%EB%B3%B4%EB%8B%A4%EB%8A%94-%ED%83%80%EC%9E%85-%EC%84%A0%EC%96%B8%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-todo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-09.-%ED%83%80%EC%9E%85-%EB%8B%A8%EC%96%B8%EB%B3%B4%EB%8B%A4%EB%8A%94-%ED%83%80%EC%9E%85-%EC%84%A0%EC%96%B8%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-todo/</guid>
      <description>아이템 9. 타입 단언보다는 타입 선언을 사용하기 # 종류 설명 타입 선언 선언한 타입임을 명시한다. - alice: Person 타입 단언 (타입스크립트가 추론한 타입이 있더라도) 해당 타입으로 (강제로) 간주한다. - as Person 타입 단언보다 타입 선언을 사용하는 것이 좋다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-10.-%EA%B0%9D%EC%B2%B4-%EB%9E%98%ED%8D%BC-%ED%83%80%EC%9E%85-%ED%94%BC%ED%95%98%EA%B8%B0-todo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-10.-%EA%B0%9D%EC%B2%B4-%EB%9E%98%ED%8D%BC-%ED%83%80%EC%9E%85-%ED%94%BC%ED%95%98%EA%B8%B0-todo/</guid>
      <description> 아이템 10. 객체 래퍼 타입 피하기 # </description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-11.-%EC%9E%89%EC%97%AC-%EC%86%8D%EC%84%B1-%EC%B2%B4%ED%81%AC%EC%9D%98-%ED%95%9C%EA%B3%84-%EC%9D%B8%EC%A7%80%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-11.-%EC%9E%89%EC%97%AC-%EC%86%8D%EC%84%B1-%EC%B2%B4%ED%81%AC%EC%9D%98-%ED%95%9C%EA%B3%84-%EC%9D%B8%EC%A7%80%ED%95%98%EA%B8%B0/</guid>
      <description>아이템 11. 잉여 속성 체크의 한계 인지하기 # &amp;quot; 잉여 속성 체크를 이용하면 기본적으로 타입 시스템의 구조적 본질을 해치지 않으면서도 객체 리터럴에 알 수 없는 속성을 허용하지 않음으로써, 이번 아이템에서 다룰 Room이나 Options 예제 같은 문제점을 방지할 수 있습니다. (&amp;lsquo;엄격한 객체 리터럴 체크&amp;rsquo;라고 불립니다.) &amp;ldquo;
(구조적 타이핑 기반에서) 타입이 명시된 변수에 &amp;lsquo;객체 리터럴&amp;rsquo;을 할당할 때, 추가로 설정된/할당된 속성(잉여 속성)이 있는지 체크할 수 있다.
객체 리터럴로 할당 시 적용된다. # &amp;lsquo;객체 리터럴&amp;rsquo;로 값을 할당하려고 하면, &amp;lsquo;잉여 속성 체크&amp;rsquo;에 의해 에러를 확인할 수 있다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-14.-%ED%83%80%EC%9E%85-%EC%97%B0%EC%82%B0%EA%B3%BC-%EC%A0%9C%EB%84%88%EB%A6%AD-%EC%82%AC%EC%9A%A9%EC%9C%BC%EB%A1%9C-%EB%B0%98%EB%B3%B5-%EC%A4%84%EC%9D%B4%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-14.-%ED%83%80%EC%9E%85-%EC%97%B0%EC%82%B0%EA%B3%BC-%EC%A0%9C%EB%84%88%EB%A6%AD-%EC%82%AC%EC%9A%A9%EC%9C%BC%EB%A1%9C-%EB%B0%98%EB%B3%B5-%EC%A4%84%EC%9D%B4%EA%B8%B0/</guid>
      <description>아이템 14. 타입 연산과 제너릭 사용으로 반복 줄이기 # DRY(Don&amp;rsquo;t repeat yourself) 원칙에 따라 코드를 개선해볼 수 있다.
함수, 상수, Loop 를 통해 개선했다.
/** 원본 코드 (개선 전) */ console.log(&amp;#39;Cylinder 1 x 1 &amp;#39;, &amp;#39;Surface area: &amp;#39;, 6.283185 * 1 * 1 + 6.283185 * 1 * 1, &amp;#39;Volume: &amp;#39;, 3.14159 * 1 * 1 * 1 ) console.log(&amp;#39;Cylinder 1 x 2 &amp;#39;, &amp;#39;Surface area: &amp;#39;, 6.283185 * 1 * 1 + 6.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-15.-%EB%8F%99%EC%A0%81-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%97%90-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%8B%9C%EA%B7%B8%EB%8B%88%EC%B2%98-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-15.-%EB%8F%99%EC%A0%81-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%97%90-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%8B%9C%EA%B7%B8%EB%8B%88%EC%B2%98-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/</guid>
      <description>아이템 15. 동적 데이터에 인덱스 시그니처 사용하기 # // JS const rocket = { name: &amp;#39;Falcon 9&amp;#39;, variant: &amp;#39;v1.0&amp;#39;, thrust: &amp;#39;4,940 kN&amp;#39;, } // TS (인덱스 시그니처 사용 예시) // Rocket = {[property: string]: string}; const rocket: Rocket = { name: &amp;#39;Falcon 9&amp;#39;, variant: &amp;#39;v1.0&amp;#39;, thrust: &amp;#39;4,940 kN&amp;#39;, } 위 예시에서 {[property: string]: string} 부분이 인덱스 시그니처이다.
**세 가지 기능을 한다.** 기능 설명 키의 이름 키의 위치만 표시하는 용도 (* 타입 체커에서는 사용하지 않는다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-16.-number-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%8B%9C%EA%B7%B8%EB%8B%88%EC%B2%98%EB%B3%B4%EB%8B%A4%EB%8A%94-Array-%ED%8A%9C%ED%94%8C-ArrayLike%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-16.-number-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%8B%9C%EA%B7%B8%EB%8B%88%EC%B2%98%EB%B3%B4%EB%8B%A4%EB%8A%94-Array-%ED%8A%9C%ED%94%8C-ArrayLike%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/</guid>
      <description>&amp;ldquo;자바스크립트는 이상하게 동작하기로 유명한 언어입니다.&amp;rdquo;
아이템 16. number 인덱스 시그니처보다는 Array, 튜플, ArrayLike를 사용하기 # 자바스크립트에서 객체란 키/값 쌍의 모음입니다.
키 : 보통 문자열 (ES2015 이후로는 &amp;lsquo;심벌&amp;rsquo;도 가능) &amp;lsquo;숫자&amp;rsquo; 불가 : &amp;lsquo;숫자&amp;rsquo;를 키로 사용할 경우 런타임에 &amp;lsquo;문자열&amp;rsquo;로 변환됩니다. 값 : 어떤 것이든 가능 파이썬이나 자바에서 볼 수 있는 &amp;lsquo;해시 가능(hashable)&amp;rsquo; 객체라는 표현이 자바스크립트에서는 없습니다. 만약 더 복잡한 객체(심볼)을 &amp;lsquo;키&amp;rsquo;로 사용하려고 하면, toString 메서드가 호출되어 객체가 문자열로 변환됩니다.
배열 # 배열은 객체이다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-19.-%EC%B6%94%EB%A1%A0-%EA%B0%80%EB%8A%A5%ED%95%9C-%ED%83%80%EC%9E%85%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%B4-%EC%9E%A5%ED%99%A9%ED%95%9C-%EC%BD%94%EB%93%9C-%EB%B0%A9%EC%A7%80%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-19.-%EC%B6%94%EB%A1%A0-%EA%B0%80%EB%8A%A5%ED%95%9C-%ED%83%80%EC%9E%85%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%B4-%EC%9E%A5%ED%99%A9%ED%95%9C-%EC%BD%94%EB%93%9C-%EB%B0%A9%EC%A7%80%ED%95%98%EA%B8%B0/</guid>
      <description>아이템 19. 추론 가능한 타입을 사용해 장황한 코드 방지하기 # &amp;quot; 타입 구문을 생략하여, 방해되는 것들을 최소화하고 코드를 읽는 사람이 구현 로직에 집중할 수 있게 해주는 것이 좋습니다. &amp;ldquo;
대부분의 경우 타입스크립트에서 타입 구문은 불필요하다.
타입을 선언하는 것은 &amp;lsquo;비생상적&amp;rsquo;, &amp;lsquo;형편없는 스타일&amp;rsquo;로 여겨진다.
let x: number = 12; // vs // x: number = 12; (코드를 보면서) 타입을 확신하지 못한다면 편집기(IDE)를 통해 체크할 수 있다.
ㄴ 이 문장은 &amp;lsquo;타입이 명시적으로 있는 게 좋지 않은가?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-20.-%EB%8B%A4%EB%A5%B8-%ED%83%80%EC%9E%85%EC%97%90%EB%8A%94-%EB%8B%A4%EB%A5%B8-%EB%B3%80%EC%88%98-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-20.-%EB%8B%A4%EB%A5%B8-%ED%83%80%EC%9E%85%EC%97%90%EB%8A%94-%EB%8B%A4%EB%A5%B8-%EB%B3%80%EC%88%98-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/</guid>
      <description>아이템 20. 다른 타입에는 다른 변수 사용하기 # 결론 = 한 변수(명)를 무분별하게 재사용하지 말자.
자바스크립트에서는 한 변수에 다른 타입을 재사용할 수 있다.
타입스크립트에서는 한 변수에 다른 타입을 재사용할 수 없다. (= 타입 체커에서 걸린다.)
// js : O // ts : X let id = &amp;#34;12-34-56&amp;#34;; id = 123456; &amp;quot; 변수의 &amp;lsquo;값&amp;rsquo;은 바뀔 수 있지만 &amp;lsquo;타입&amp;rsquo;은 보통 바뀌지 않는다. &amp;ldquo;
타입을 바꿀 수 있는 한 가지 방법 : &amp;lsquo;(타입의)범위를 좁히는 것&amp;rsquo; # &amp;lsquo;타입을 더 작게 제한하는 것&amp;rsquo;을 의미한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-21.-%ED%83%80%EC%9E%85-%EB%84%93%ED%9E%88%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-21.-%ED%83%80%EC%9E%85-%EB%84%93%ED%9E%88%EA%B8%B0/</guid>
      <description>아이템 21. 타입 넓히기 # &amp;quot; 아이템 7에서 설명한 것처럼 런타임에 모든 변수는 유일한 값을 가집니다. &amp;ldquo;
런타임(=자바스크립트) 시에는 모든 변수가 값을 가진다. 그러나 타입스크립트가 작성된 코드를 체크하는 정적 분석 시점에는, 변수는 &amp;lsquo;가능한 값들의 집합&amp;rsquo;인 타입을 가진다.
넓히기 (widening) # 상수를 사용해서 변수를 초기화할 때, 타입을 명시하지 않으면 타입 체커는 타입을 추론/결정해야 한다. = &amp;lsquo;가능한 값들의 집합&amp;rsquo;(타입)을 추론해야 한다.
타입스크립트에서는 이 과정을 &amp;lsquo;넓히기(widening)&amp;rsquo; 라고 부른다.
&amp;lsquo;넓히기&amp;rsquo;가 진행될 때, 가능한 값의 범위를 최대한 좁히되 오류(잘못된 추론)는 발생하면 안된다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-23.-%ED%95%9C%EA%BA%BC%EB%B2%88%EC%97%90-%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-23.-%ED%95%9C%EA%BA%BC%EB%B2%88%EC%97%90-%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0/</guid>
      <description>아이템 23. 한꺼번에 객체 생성하기 # 변수의 값은 변경될 수 있지만, 타입스크립트의 타입은 (일반적으로) 변경되지 않는다.
즉, 객체를 생성할 때는 속성을 하나씩 추가하기보다는 여러 속성을 포함해서 &amp;lsquo;한꺼번에 생성해야 타입 추론에 유리&amp;rsquo;하다.
const pt = {}; pt.x = 3; pt.y = 4; » tsc example.ts example.ts:2:4 - error TS2339: Property &amp;#39;x&amp;#39; does not exist on type &amp;#39;{}&amp;#39;. 2 pt.x = 3; ~ example.ts:3:4 - error TS2339: Property &amp;#39;y&amp;#39; does not exist on type &amp;#39;{}&amp;#39;.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-24.-%EC%9D%BC%EA%B4%80%EC%84%B1-%EC%9E%88%EB%8A%94-%EB%B3%84%EC%B9%AD-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-24.-%EC%9D%BC%EA%B4%80%EC%84%B1-%EC%9E%88%EB%8A%94-%EB%B3%84%EC%B9%AD-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/</guid>
      <description>아이템 24. 일관성 있는 별칭 사용하기 # 별칭의 값을 변경하면 원래 속성값도 변경된다. 별칭 남발 시, 코드를 분석하기 어렵다. const borough = { name: &amp;#39;Brooklyn&amp;#39;, location: [40, -73] } const loc = borough.location // 별칭의 값을 변경하면 원래 속성값도 변경된다. loc[0] = 0; console.log(borough.location) // [0, -73] 타입 체크 시에도 신경써야한다. # function isPointinPolygon(polygon: Polygon, pt: Coordinate) { polygon.bbox; // 타입 : BoundingBox | undefined const box = polygon.bbox; // 타입 : BoundingBox | undefined if (polygon.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-25.-%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%BD%94%EB%93%9C%EC%97%90%EB%8A%94-%EC%BD%9C%EB%B0%B1-%EB%8C%80%EC%8B%A0-async-%ED%95%A8%EC%88%98-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-25.-%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%BD%94%EB%93%9C%EC%97%90%EB%8A%94-%EC%BD%9C%EB%B0%B1-%EB%8C%80%EC%8B%A0-async-%ED%95%A8%EC%88%98-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/</guid>
      <description>아이템 25. 비동기 코드에는 콜백 대신 async 함수 사용하기 # ES2015, 프로미스(promis) 개념이 도입되었다.
프로미스는 미래에 가능해질 어떤 것을 나타낸다. (future) ES2017, async/await 키워드가 도입되었다.
await : 각각의 프로미스가 처리(resolve)될 때까지 함수의 실행을 멈춘다. async : 함수 내에서 await 중인 프로미스가 거절(reject)되면 예외를 던진다. 이를 통해 일반적인 try/catch 구문을 사용할 수 있다. 아래 예시를 살펴보자. 콜백 지옥, 프로미스, async/await 를 사용하여 코드를 개선한 예시이다.
/** 예시 : 콜백 */ fetchURL(url1, function(response1) { fetchURL(url2, function(response2) { fetchURL(url3, function(response3) { //.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-26.-%ED%83%80%EC%9E%85-%EC%B6%94%EB%A1%A0%EC%97%90-%EB%AC%B8%EB%A7%A5%EC%9D%B4-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%82%AC%EC%9A%A9%EB%90%98%EB%8A%94%EC%A7%80-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-26.-%ED%83%80%EC%9E%85-%EC%B6%94%EB%A1%A0%EC%97%90-%EB%AC%B8%EB%A7%A5%EC%9D%B4-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%82%AC%EC%9A%A9%EB%90%98%EB%8A%94%EC%A7%80-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/</guid>
      <description>아이템 26. 타입 추론에 문맥이 어떻게 사용되는지 이해하기 # 이번 아이템에서 말하는 문맥이란, 상수를 그대로 사용하지 않고 변수(?), 별칭(?)과 같은 것(=문맥)을 의미한다.
문맥을 사용했을 때, 타입 추론이 다르다는 것을 이야기하는 내용이다.
아래 예시는, 문맥을 활용했을 때 타입추론이 어떻게 변하는지 보여주는 예시이다.
type Language = &amp;#39;Javascript&amp;#39; | &amp;#39;TypeScript&amp;#39; | &amp;#39;Python&amp;#39; function setLanguage(language: Language) { /* ... */ } // 예시 1 : 상수 직접 사용 setLanguage(&amp;#39;Javascript&amp;#39;); // 예시 2 : 문맥 활용 let language = &amp;#39;Javascript&amp;#39;; setLanguage(language); // ~~~~~~~~ &amp;#39;string&amp;#39; 형식의 인수는 // &amp;#39;Language&amp;#39; 형식의 매개변수에 할당될 수 없습니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-27.-%ED%95%A8%EC%88%98%ED%98%95-%EA%B8%B0%EB%B2%95%EA%B3%BC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EB%A1%9C-%ED%83%80%EC%9E%85-%ED%9D%90%EB%A6%84-%EC%9C%A0%EC%A7%80%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-27.-%ED%95%A8%EC%88%98%ED%98%95-%EA%B8%B0%EB%B2%95%EA%B3%BC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EB%A1%9C-%ED%83%80%EC%9E%85-%ED%9D%90%EB%A6%84-%EC%9C%A0%EC%A7%80%ED%95%98%EA%B8%B0/</guid>
      <description>아이템 27. 함수형 기법과 라이브러리로 타입 흐름 유지하기 # 라이브러리는 타입스크립트와 조합하여 사용하면 더욱 빛을 발휘한다.
이유는 타입 정보가 그대로 유지되면서 타입 흐름(flow)가 계속 전달되기 때문이다.
즉, 타입이 추론되고 추론된 타입이 계속 사용되고, 사용되고, 사용된다.
자바스크립트의 경우 라이브러리를 쓰는 것은 &amp;lsquo;고려 사항&amp;rsquo;이다. # 서드파티 라이브러리 종속성을 추가할 때 신중해야 한다.
서드파티 라이브러리를 통해 시간, 비용이 많이 든다면 사용하지 않는게 나을 것이다.
타입스크립트의 경우 라이브러리를 쓰는 것은 &amp;lsquo;필수&amp;rsquo;이다. (매우 권장) # 타입이 &amp;lsquo;정확하게&amp;rsquo; 추론된다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-28.-%EC%9C%A0%ED%9A%A8%ED%95%9C-%EC%83%81%ED%83%9C%EB%A7%8C-%ED%91%9C%ED%98%84%ED%95%98%EB%8A%94-%ED%83%80%EC%9E%85%EC%9D%84-%EC%A7%80%ED%96%A5%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-28.-%EC%9C%A0%ED%9A%A8%ED%95%9C-%EC%83%81%ED%83%9C%EB%A7%8C-%ED%91%9C%ED%98%84%ED%95%98%EB%8A%94-%ED%83%80%EC%9E%85%EC%9D%84-%EC%A7%80%ED%96%A5%ED%95%98%EA%B8%B0/</guid>
      <description>타입 시스템의 큰 장점 중 하나는 데이터 타입을 명확히 알 수 있어 코드를 이해하기 쉽다는 것이다. 4장(타입 설계)에서는 타입 자체의 설계에 대해 다룬다. 대부분 다른 언어에서도 적용될 수 있는 아이디어다.
아이템 28. 유효한 상태만 표현하는 타입을 지향하기 # 효과적으로 타입을 설계하려면, 유효한 상태만 표현할 수 있는 타입을 만들어 내는 것이 중요합니다.
interface State { pageText: string; isLoading: boolean; error?: string; } 위 타입이 페이지를 렌더링하는 상태를 나타낸다고 가정할 때, 이 타입은 애매하다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-29.-%EC%82%AC%EC%9A%A9%ED%95%A0-%EB%95%8C%EB%8A%94-%EB%84%88%EA%B7%B8%EB%9F%BD%EA%B2%8C-%EC%83%9D%EC%84%B1%ED%95%A0-%EB%95%8C%EB%8A%94-%EC%97%84%EA%B2%A9%ED%95%98%EA%B2%8C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-29.-%EC%82%AC%EC%9A%A9%ED%95%A0-%EB%95%8C%EB%8A%94-%EB%84%88%EA%B7%B8%EB%9F%BD%EA%B2%8C-%EC%83%9D%EC%84%B1%ED%95%A0-%EB%95%8C%EB%8A%94-%EC%97%84%EA%B2%A9%ED%95%98%EA%B2%8C/</guid>
      <description>아이템 29. 사용할 때는 너그럽게, 생성할 때는 엄격하게 # &amp;quot; 아이템 29의 제목은 TCP 관련해서 존 포스텔이 쓴 견고성 원칙(포스텔의 법칙)에서 따왔습니다. &amp;ldquo;
&amp;rdquo; TCP 구현체는 견고성의 일반적 원칙을 따라야 한다. 당신의 작업은 엄격하게 하고, 다른 사람의 작업은 너그럽게 받아들여야 한다. &amp;ldquo;
함수의 시그니처에도 비슷한 규칙을 적용해야 한다. # 함수의 매개변수는 타입의 범위가 넓어도 되지만, 결과를 반환할 때는 일반적으로 타입의 범위가 더 구체적이어야 한다.
어떤 함수의 반환타입의 범위가 넓으면 사용하기 불편하다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-30.-%EB%AC%B8%EC%84%9C%EC%97%90-%ED%83%80%EC%9E%85-%EC%A0%95%EB%B3%B4%EB%A5%BC-%EC%93%B0%EC%A7%80-%EC%95%8A%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-30.-%EB%AC%B8%EC%84%9C%EC%97%90-%ED%83%80%EC%9E%85-%EC%A0%95%EB%B3%B4%EB%A5%BC-%EC%93%B0%EC%A7%80-%EC%95%8A%EA%B8%B0/</guid>
      <description>아이템 30. 문서에 타입 정보를 쓰지 않기 # 주석을 통해 타입에 대해 설명하곤 한다.
/** * 0개 또는 1개의 매개변수를 받습니다. * 매개변수가 없을 때는 표준 전경색을 반환합니다. */ function getForegroundColor(page?: string) { return page === &amp;#39;login&amp;#39; ? {r: 127, g: 127, b: 127} : {r: 0, g: 0, b: 0}; } 코드와 주석의 정보가 맞지 않는다.
둘 중 어느것이 맞는지 판단해야하는 상황이 생긴다.
코드를 수정하면서 함께 수정하지 않는 경우가 많다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-31.-%ED%83%80%EC%9E%85-%EC%A3%BC%EB%B3%80%EC%97%90-null-%EA%B0%92-%EB%B0%B0%EC%B9%98%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-31.-%ED%83%80%EC%9E%85-%EC%A3%BC%EB%B3%80%EC%97%90-null-%EA%B0%92-%EB%B0%B0%EC%B9%98%ED%95%98%EA%B8%B0/</guid>
      <description>아이템 31. 타입 주변에 null 값 배치하기 # 값이 전부 null, null이 아닌 경우로 분명히 구분한다면 값이 섞여 있을 때보다 다루기 쉽다.
if 혹은 !(단언) 을 통해 쉽게 타입을 좁힐 수 있다. 추가로 undefined 를 포함하는 객체는 다루기 어렵고 절대 권장하지 않는다.
타입에 null 을 추가하는 방식으로 이러한 경우를 모델링할 수 있다.
function extent(nums: number[]) { let result: [number, number] | null = null; for (const num of nums) { if(!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-33.-string-%ED%83%80%EC%9E%85%EB%B3%B4%EB%8B%A4-%EB%8D%94-%EA%B5%AC%EC%B2%B4%EC%A0%81%EC%9D%B8-%ED%83%80%EC%9E%85-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/%EC%95%84%EC%9D%B4%ED%85%9C-33.-string-%ED%83%80%EC%9E%85%EB%B3%B4%EB%8B%A4-%EB%8D%94-%EA%B5%AC%EC%B2%B4%EC%A0%81%EC%9D%B8-%ED%83%80%EC%9E%85-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/</guid>
      <description>아이템 33. string 타입보다 더 구체적인 타입 사용하기 # string 타입의 범위는 매우 넓다.(&amp;ldquo;a&amp;rdquo;, &amp;ldquo;b&amp;rdquo;, &amp;ldquo;casdsad&amp;rdquo;, &amp;hellip;)
다음은 string 타입이 남발된 타입의 예시이다.
interface Album { artist: string; title: string; releaseDate: string; // 예를 들어, yyyy-mm-dd recordingType: string; // 예를 들어, &amp;#34;live&amp;#34; 또는 &amp;#34;studio&amp;#34; } string 은 다음과 같은 단점이 있다.
예를 들어,
recordingType 에 &amp;ldquo;Live&amp;rdquo; 값이 들어가도, 타입 체커는 완벽하게 체크할 수 없다. releaseDate 에 &amp;ldquo;asdsad&amp;rdquo; 값이 들어가도, 타입체커는 완벽하게 체크할 수 없다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9E%90%EB%B0%94-ORM-%ED%91%9C%EC%A4%80-JPA-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/03%EC%9E%A5_%EC%98%81%EC%86%8D%EC%84%B1%EA%B4%80%EB%A6%AC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9E%90%EB%B0%94-ORM-%ED%91%9C%EC%A4%80-JPA-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/03%EC%9E%A5_%EC%98%81%EC%86%8D%EC%84%B1%EA%B4%80%EB%A6%AC/</guid>
      <description>EntityManagerFactory, EntityManager # (보통) EntityManagerFactory를 생성할 때, 커넥션 풀을 만든다.
EntityManager는 EntityManagerFactory 에서 생성한다.
EntityManager는 데이터베이스 연결이 꼭 필요한 시점(like transaction)까지 커넥션(connection, conn)을 얻지 않는다.
영속성 컨텍스트란? # &amp;lsquo;엔티티를 영구히 저장하는 환경&amp;rsquo; 이다. (EntityManager 로) entity 를 저장, 조회하면 EntityManager 는 영속성 컨텍스트에 entity 를 보관/관리한다. EntityManager 를 생성하면 &amp;lsquo;영속성 컨텍스트&amp;rsquo; 라는 것이 (한 개) 같이 생성된다. EntityManager 를 통해 영속성 컨텍스트에 접근,관리할 수 있다.
즉, 애플리케이션과 DB 사이에서 객체를 보관하는 가상의 데이터베이스와 같은 역할을 한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9E%90%EB%B0%94-ORM-%ED%91%9C%EC%A4%80-JPA-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/04%EC%9E%A5_%EC%97%94%ED%8B%B0%ED%8B%B0%EB%A7%A4%ED%95%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9E%90%EB%B0%94-ORM-%ED%91%9C%EC%A4%80-JPA-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/04%EC%9E%A5_%EC%97%94%ED%8B%B0%ED%8B%B0%EB%A7%A4%ED%95%91/</guid>
      <description>4장. 엔티티 매핑 # JPA 에서 지원하는 매핑 어노테이션은 크게 4가지로 분류할 수 있다.
설명 어노테이션 객체 / 테이블 매핑 @Entity, @Table Primary 키 매핑 @Id 필드 / 컬럼 매핑 @Column 연관관계 매핑 @ManyToOne, @JoinColumn @Entity # 테이블과 매핑할 클래스에 @Entity 어노테이션을 사용한다.
@Entity가 붙은 클래스는 JPA 가 관리하는 것이며, 엔티티라 부른다.
주의사항
기본 생성자(Default Constructor, @NoArgsConstructor)는 필수 final, enum, interface, inner 클래스에는 사용할 수 없다. 매핑할 필드(컬럼)에 final 값을 사용할 수 없다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9E%90%EB%B0%94-ORM-%ED%91%9C%EC%A4%80-JPA-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/13%EC%9E%A5_%EC%9B%B9-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EA%B3%BC-%EC%98%81%EC%86%8D%EC%84%B1-%EA%B4%80%EB%A6%AC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9E%90%EB%B0%94-ORM-%ED%91%9C%EC%A4%80-JPA-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/13%EC%9E%A5_%EC%9B%B9-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EA%B3%BC-%EC%98%81%EC%86%8D%EC%84%B1-%EA%B4%80%EB%A6%AC/</guid>
      <description>&amp;quot; 컨테이너 환경(스프링)에서 동작하는 JPA 내부 동작 방식을 이해해보자 &amp;ldquo;
트랜잭션 범위의 영속성 컨텍스트 # 컨테이너의 도움 없이 순수 자바 환경에서 JPA 를 사용한다면, 아래와 같은 작업을 직접 처리해야 한다.
EntityManager 관리 트랜잭션(Transaction) 관리 컨테이너(스프링)는 위와 같은 작업을 대신해준다. 따라서, 컨테이너가 제공하는 방법/전략(영속성 컨텍스트, 트랜잭션과의 관계)을 이해할 필요가 있다.
스프링 컨테이너 기본 전략 : 트랜잭션 범위 = 영속성 컨텍스트 범위 # OSIV : false
트랜잭션 범위와 영속성 컨텍스트의 생존 범위가 같다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%9E%90%EB%B0%94-ORM-%ED%91%9C%EC%A4%80-JPA-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/16%EC%9E%A5_%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EA%B3%BC-%EB%9D%BD-2%EC%B0%A8%EC%BA%90%EC%8B%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%9E%90%EB%B0%94-ORM-%ED%91%9C%EC%A4%80-JPA-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/16%EC%9E%A5_%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EA%B3%BC-%EB%9D%BD-2%EC%B0%A8%EC%BA%90%EC%8B%9C/</guid>
      <description>트랜잭션과 락 # 2차 캐시 # 1차 캐시와 2차 캐시
영속성 컨텍스트 내부에 Entity 를 보관하는 저장소, 1차캐시가 있다.
1차캐시를 통해 얻을 수 있는 이점은 많이 있지만 일반적으로 1차캐시의 유효 범위는 짧기 때문에 큰 이점을 보기는 힘들다.
* 1차캐시는 트랜잭션 시작 ~ 끝에서 유효하다. OSIV 를 사용해도 클라이언트의 요청이 들어온 시점 ~ 끝날 때까지만 유효하다.
하이버네이트를 포함하여 대부분의 JPA 구현체는 애플리케이션 범위의 캐시를 지원한다. 이것을 &amp;lsquo;공유 캐시&amp;rsquo;, &amp;lsquo;2차 캐시&amp;rsquo;라고 한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%9D%B8-%EC%95%A1%EC%85%98/2%EC%9E%A5.-%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B8%B0%EC%B4%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%9D%B8-%EC%95%A1%EC%85%98/2%EC%9E%A5.-%EC%BD%94%ED%8B%80%EB%A6%B0-%EA%B8%B0%EC%B4%88/</guid>
      <description>기본적인 내용은 생략한다.
키워드 #프로퍼티 #변수 #함수 #클래스 #스마트캐스트 #예외처리
식 : 값을 만들어 내는 것 문장(문) : 값을 만들어내지 않는 것
2.1 기본 요소 : 함수와 변수 # 아래 내용을 통해 알 수 있는 것은 다음과 같다.
함수, 변수를 최상위 수준에 정의 가능 (꼭 클래스 내에 정의하는 것이 아니라) println : 코틀린 표준 라이브러리 → 표준 자바 라이브러리 함수를 간결하게 사용할 수 있도록 래핑 &amp;hellip; fun main(args: Array&amp;lt;String&amp;gt;) { println(&amp;#34;Hello, world!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%9D%B8-%EC%95%A1%EC%85%98/3%EC%9E%A5.-%ED%95%A8%EC%88%98-%EC%A0%95%EC%9D%98%EC%99%80-%ED%98%B8%EC%B6%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%9D%B8-%EC%95%A1%EC%85%98/3%EC%9E%A5.-%ED%95%A8%EC%88%98-%EC%A0%95%EC%9D%98%EC%99%80-%ED%98%B8%EC%B6%9C/</guid>
      <description>기본적인 내용은 생략한다.
키워드 # (자바와 다른) 함수 정의 / 함수 호출 확장 함수 (+ 프로퍼티) 3.1 코틀린에서 컬렉션 만들기 # 핵심 : 자바 컬렉션을 사용한다.
다양한 방법으로 컬렉션을 만들 수 있다.
val hashSet = hashSetOf(1, 7, 53) val arrayList = arrayListOf(1, 7, 53) val hashMap = hashMapOf(1 to &amp;#34;one&amp;#34;, 7 to &amp;#34;seven&amp;#34;, 53 to &amp;#34;fifty-three&amp;#34;) println(hashSet) // [1, 53, 7] | java.util.HashSet println(arrayList) // [1, 7, 53] | java.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%9D%B8-%EC%95%A1%EC%85%98/4%EC%9E%A5.-%ED%81%B4%EB%9E%98%EC%8A%A4-%EA%B0%9D%EC%B2%B4-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%9D%B8-%EC%95%A1%EC%85%98/4%EC%9E%A5.-%ED%81%B4%EB%9E%98%EC%8A%A4-%EA%B0%9D%EC%B2%B4-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/</guid>
      <description>기본적인 내용은 생략한다.
키워드 # 인터페이스 프로퍼티 선언 가능 클래스 final final public sealed 중첩 클래스 중첩 클래스 vs 내부 클래스 초기화 블록 data 클래스 위임(delegation) object 싱글턴 객체 동반 객체 객체 식 + 참고 : 스마트 캐스트는 val(불변)일 때에만 사용 가능하다.
4.1 클래스 계층 정의 # 기본 가시성 다르다.
java : default kotlin : public sealed 클래스는 상속을 제한한다. (중첩(?), 내부(?) 클래스만 허용한다.)
4.1.1 코틀린 인터페이스 # 추상 메서드 구현이 있는 메서드 (default 메서드) 상태(필드) 자바와 다른 점이다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%9D%B8-%EC%95%A1%EC%85%98/5%EC%9E%A5.-%EB%9E%8C%EB%8B%A4%EB%A1%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%BD%94%ED%8B%80%EB%A6%B0-%EC%9D%B8-%EC%95%A1%EC%85%98/5%EC%9E%A5.-%EB%9E%8C%EB%8B%A4%EB%A1%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/</guid>
      <description>기본적인 내용은 생략한다.
키워드 # 람다, 멤버 참조 sequence (지연 컬렉션 연산) 함수형 인터페이스 (SAM 인터페이) 수신 객체 지정 람다 + 참고 : 스마트 캐스트는 val(불변)일 때에만 사용 가능하다.
5장. 람다로 프로그래밍 # 람다(= 람다 식)은 기본적으로 다른 함수에 넘길 수 있는 작은 코드 조각을 뜻한다.
5.1 람다 식과 멤버 참조 # 5.1.1 람다 소개 : 코드 블록을 함수 인자로 넘기기 # button.setOnClickListener { /* 클릭 시 수행할 동작 */ } 5.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/DB/01.-Mysql-%EC%84%9C%EB%B2%84-Mysql%EC%97%94%EC%A7%84-&#43;-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%97%94%EC%A7%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/DB/01.-Mysql-%EC%84%9C%EB%B2%84-Mysql%EC%97%94%EC%A7%84-&#43;-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%97%94%EC%A7%84/</guid>
      <description>Mysql 서버는 아래와 같이 구분할 수 있습니다.
Mysql 엔진 스토리지 엔진 Mysql 엔진(Mysql Engine) # 클라이언트의 요청을 받거나, 쿼리를 파싱하거나 캐싱하는 등의 전반적인 기능을 담당합니다.
disk와의 직접적인 접근을 제외한 전반적인 역할을 수행합니다.
커넥션 핸들러 : 커넥션 및 쿼리 요청을 처리합니다. SQL 인터페이스 : DML, DDL, Procedure, View 등 SQL 인터페이스를 제공합니다. SQL 파서 : SQL 쿼리 파싱(토큰화)합니다. 이 과정에서 SQL 문법 오류를 탐지할 수 있습니다. SQL 옵티마이저 : 쿼리를 최적화합니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/DB/02.-Mysql-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/DB/02.-Mysql-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0/</guid>
      <description>메모리 구조는 아래와 같이 구분됩니다.
Global Memory Area(글로벌 메모리 영역) Local Memory Area(Session Memory Area) Global Memory Area # Mysql 데몬이 뜨는 순간 OS로부터 할당받는 메모리 영역입니다.
모든 쓰레드에서 공유되는 영역입니다.
Buffer Pool (InnoDB) Key Cache (MyISAM) Query Cache (쿼리 캐시) Binlog Buffer (바이너리 로그 버퍼) Log Buffer (로그 버퍼) Table Cache (테이블 캐시) 대게 1개의 공간으로 할당되지만, 필요에 따라 2개의 공간이 할당될 수 있습니다.
Local Memory Area # Client Thread(Foreground Thread(?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/DB/03.-Mysql-%EC%93%B0%EB%A0%88%EB%93%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/DB/03.-Mysql-%EC%93%B0%EB%A0%88%EB%93%9C/</guid>
      <description>Mysql 서버는 쓰레드 기반으로 동작합니다.
Foreground Thread Background Thread Foreground Thread (Client Thread, 사용자 쓰레도) # Client의 커넥션/요청을 처리하기 위해 존재하는 쓰레드입니다. 즉, 최소한 클라이언트가 접속된 만큼 쓰레드가 존재합니다.
Client가 커넥션을 종료하면, Thread Pool로 되돌아갑니다.
Foreground Thread는 데이터를 Mysql의 캐시나 버퍼로부터 데이터를 읽어옵니다. 캐시/버퍼에 데이터가 없으면 디스크로부터 데이터를 읽어옵니다.
스토리지엔진(InnoDb, MyISAM)에 따라 Foreground Thread가 디스크의 쓰기 역할이 다릅니다.
InnoDB 디스크 쓰기 작업은 Background Thread 가 처리합니다. MyISAM 디스크로 쓰기 작업은 Foreground Thread 가 처리합니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/DB/04.-Replication/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/DB/04.-Replication/</guid>
      <description>Replication 에 대해 이해해보기
Replication # 회사에서 대용량의, 중요한 테이블에 대한 스키마 변경 작업을 하게 되었다. 작업을 진행하기 전 Replication 에 대한 개념이 부족하여 replication 에 대해 공부해보고 정리해보고자 한다.
Replication 은 말그대로 &amp;lsquo;복제&amp;rsquo;이다. DB에 데이터를 insert, update, delete 하면 그 내용을 그대로 (여분의, 추가의)DB에 저장해놓는 것이다.
이렇게 복제된 DB는 백업용으로 사용할 수도 있고, select query를 처리해줄 수도 있다. 예를 들어, select query를 slave DB에 위임하면 메인 DB의 부하를 감소시킬 수 있을 것이다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/DB/05.-%EC%9D%B8%EB%8D%B1%EC%8A%A4Index/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/DB/05.-%EC%9D%B8%EB%8D%B1%EC%8A%A4Index/</guid>
      <description>인덱스(Index) # 테이블의 검색 성능(속도)를 향상시켜주기 위해 사용되는 기술(혹은 자료 구조)입니다.
데이터들을 정렬된 상태로 관리하여, 검색 시 이점이 있습니다.
Order by 효율성 : 이미 정렬되어 있기에 인덱스에서 관리된 형태 그대로 가져올 수 있다. Min, Max 효율성 : 첫 번째 값, 마지막 값을 가져와 사용할 수 있다. Where 효율성 : 테이블의 데이터들은 내부적으로는 정렬되지 않은 상태로 저장되기 때문에 인덱스 없는 검색 시 Full-Scan이 필요하다. 인덱스 사용 시에는 정렬된 형태로 값을 저장하기 때문에 빠르게 데이터를 검색할 수 있다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/DB/06.-%EC%BF%BC%EB%A6%AC-%EC%8B%A4%ED%96%89-%EC%88%9C%EC%84%9C-%EB%B0%8F-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/DB/06.-%EC%BF%BC%EB%A6%AC-%EC%8B%A4%ED%96%89-%EC%88%9C%EC%84%9C-%EB%B0%8F-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD/</guid>
      <description>SELECT 쿼리 실행 순서 # 드라이빙 테이블 (where 적용 / 조인 실행) 드리븐 테이블1 드리븐 테이블2 -&amp;gt; GROUP BY -&amp;gt; DISTINCT -&amp;gt; HAVING -&amp;gt; ORDER BY -&amp;gt; LIMIT // 주로 group by 없이 order by만 적용된 쿼리에서 사용될 수 있는 순서이다. 드라이빙 테이블 -&amp;gt; ORDER BY -&amp;gt; 드리븐 테이블1, 드리븐 테이블2 (were 적용 / 조인 실행) -&amp;gt; LIMIT 적용 인덱스 컬럼의 값을 변환/조작하지 않는다. # 인덱스를 사용하지 않는 경우</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/DB/07.-Lock-%EB%82%99%EA%B4%80%EC%A0%81-%EB%9D%BD-%EB%B9%84%EA%B4%80%EC%A0%81-%EB%9D%BD/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/DB/07.-Lock-%EB%82%99%EA%B4%80%EC%A0%81-%EB%9D%BD-%EB%B9%84%EA%B4%80%EC%A0%81-%EB%9D%BD/</guid>
      <description>정리하면 아래와 같을 수 있을 것 같음
낙관적 락 : CAS
비관적 락 : Lock
Optimistic Lock (낙관적 락) # 트랜잭션 충돌이 발생하지 않는다고 가정하는 것
DB 제공하는 Lock 을 사용하지 않고, Application Level(e.g. JPA)에서 버전 관리 직접함
&amp;gt; 버전 관리 : version, timestamp, hashcode 등
CAS 개념으로 볼 수 있을 것 같다.
Lock 을 사용하지 않기 때문에, 트랜잭션 충돌이 많지 않은 상황에 사용하면 성능 향상
Lock vs CAS 의 비교로도 볼 수 있을 듯</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/DB/08.-Charset-Collation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/DB/08.-Charset-Collation/</guid>
      <description>Mysql 기준
Mysql에서 제공하는 Charset 종류 # 아래의 명령어로 확인할 수 있다.
show character set ; 대표적으로 아래와 같다.
utf8 utf8mb4 ascii euckr 특징 (중요!!) # Mysql utf8은 3byte까지 지원한다. 4byte 문자를 사용하기 위해서는 utf8mb4를 사용한다. utf16, utf32도 4byte를 지원한다. Mysql에서 제공하는 Collation 종류 # 아래의 명령어로 확인할 수 있다.
show collation ; 대표적으로 아래와 같다.
utf8_bin, utf8mb4_bin (utf8, utf8mb4) binary 값(hex)으로 비교한다. utf8_general_ci, utf8mb4_general_ci (utf8, utf8mb4) a, b, &amp;hellip; 순서 (즉 휴머니스틱하게 정렬) utf8_unicode_ci, utf8mb4_unicode_ci (utf8, utf8mb4) utf8_general_ci 보다 조금 더 휴머니스틱하게 정렬한다고 한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/DB/09.-GTID/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/DB/09.-GTID/</guid>
      <description>GTID 에 대해 이해해보기
GTID(Global Transaction IDentifier) (작성중) # 형태 : 고유한 식별자(ID):TRANSACTION ID
Master,Slave 복제 기준이 되었던 binlog, pos 대신 GTID 를 사용할 수 있다. Master 의 binglog file, pos 를 따라가지 않아도 된다. GTID 정보만으로 Master, Slave 간의 일관성을 쉽게 확인할 수 있다. GTID 트랜잭션은 mysql.gtid_executed 로 관리되기에, 중복 수행되지 않는다. 트랜잭션이 commit 되면 GTID 를 할당 받고 binlog 에 기록한다. 할당된 GTID 는 gtid_executed system variable, mysql.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/DB/10.-InnoDB-auto_increment-%EC%B4%88%EA%B8%B0%ED%99%94-%EB%B0%A9%EC%8B%9D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/DB/10.-InnoDB-auto_increment-%EC%B4%88%EA%B8%B0%ED%99%94-%EB%B0%A9%EC%8B%9D/</guid>
      <description>InnoDB 엔진, auto_increment 초기화 방식 # (InnoDB 엔진을 사용할 때) Mysql 5.7과 이전버전에서, 서버 재시작 시 auto_increment 의 값은 아래와 같이 초기화된다.
이유는 auto_increment 값을 메모리 상에서 관리하기 때문.
&amp;quot; In MySQL 5.7 and earlier, the auto-increment counter is stored in main memory, not on disk. To initialize an auto-increment counter after a server restart, InnoDB would execute the equivalent of the following statement on the first insert into a table containing an AUTO_INCREMENT column.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/DEV/AWS-Community-Day-2022/Amazon-CloudFront%EC%99%80-AWS-Lambda@Edge%EB%A1%9C-SPA%EC%97%90%EC%84%9C-%EB%8F%99%EC%A0%81-SEO-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/DEV/AWS-Community-Day-2022/Amazon-CloudFront%EC%99%80-AWS-Lambda@Edge%EB%A1%9C-SPA%EC%97%90%EC%84%9C-%EB%8F%99%EC%A0%81-SEO-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0/</guid>
      <description>OpenGraph # SPA 는 왜 링크마다 OpenGraph 적용이 안될까? # OpenGraph 스크랩 봇의 행동 강령 : JS는 버린다. (JS 를 읽는데에 시간이 많이 쓰이기 때문에)
이건 별도로 찾아보자. SPA 는 기본 뼈대가 아주 단순한 구조이다.
대처 방법은? # SSR, Static 웹으로 제공할 수 있다.
다만 위 방법도 단점은 있다. 동적으로 제공하기 힘들다.
코드 레벨이 아닌 인프라로 해결할 수 있을까? # 인프라로 해결할 수 있다. 웹 앱 앞에 프록시를 두고 메타 태그를 추가할 수 있다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/DEV/AWS-Community-Day-2022/AWS-Lambda-Container%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EC%84%9C%EB%B2%84%EB%A6%AC%EC%8A%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EB%B0%B0%ED%8F%AC-%EB%B0%8F-%EC%84%B1%EB%8A%A5-%ED%96%A5%EC%83%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/DEV/AWS-Community-Day-2022/AWS-Lambda-Container%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EC%84%9C%EB%B2%84%EB%A6%AC%EC%8A%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EB%B0%B0%ED%8F%AC-%EB%B0%8F-%EC%84%B1%EB%8A%A5-%ED%96%A5%EC%83%81/</guid>
      <description>Introduction # Fargate Kinesis (Data Firehost, Stream) S3 SQS Lambda Step Functions 구조화된 Lambda workflow 를 구성하고 있다. Why Lambda Container? # Data 처리 &amp;amp; Lambda 사용에 있어서 용량 제한으로 인해 다양한 라이브러리 사용에 제한이 있었다. 라이브러리 용량이 조금만 커도 사용에 제한이 있었다.
기존 labmda 기반 아키텍처를 유지하면서 conatiner 기반으로 변경할 수 있어야 했다.
Lambda Container with Serverless Framework # 도커 이미지 필요하다. AWS 에서 제공하는 이미지를 사용하는게 제일 속 편하다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/DEV/AWS-Community-Day-2022/AWS-Nitro-Enclave%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EC%95%88%EC%A0%84%ED%95%98%EA%B2%8C-%EA%B3%A0%EA%B0%9D-%EC%A0%95%EB%B3%B4-%EB%8B%A4%EB%A3%A8%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/DEV/AWS-Community-Day-2022/AWS-Nitro-Enclave%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EC%95%88%EC%A0%84%ED%95%98%EA%B2%8C-%EA%B3%A0%EA%B0%9D-%EC%A0%95%EB%B3%B4-%EB%8B%A4%EB%A3%A8%EA%B8%B0/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/DEV/AWS-Community-Day-2022/AWS%EC%97%90%EC%84%9C-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EC%9A%B4%EC%98%81%ED%95%98%EA%B8%B0.-%EA%B7%B8%EB%A6%AC%EA%B3%A0-ROSA/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/DEV/AWS-Community-Day-2022/AWS%EC%97%90%EC%84%9C-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EC%9A%B4%EC%98%81%ED%95%98%EA%B8%B0.-%EA%B7%B8%EB%A6%AC%EA%B3%A0-ROSA/</guid>
      <description>PaaS # AWS Lightsail AWS Elastic Beanstalk serverless # 대표적으로 아래와 같은 서비스를 제공합니다.
AWS Lambda What is cold-start (issue)? AWS App Runner AWS Fargate orchestration # 대표적으로 아래와 같은 서비스를 제공합니다.
AWS ECS AWS EKS AWS ECS # EKS에 비해 단순함 을 강조한 서비스
AWS EKS # ECS 에 비해 조금 복잡하지만 유연성(확장성) 을 강조한 서비스
입문자 입장에서는 ECS를 사용하다가 EKS를 사용하는 것을 권장한다.
ROSA # RedHat + OpenShift + AWS</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/DEV/AWS-Community-Day-2022/CDK-for-Terraform%EC%9C%BC%EB%A1%9C-%EB%82%98%EB%A7%8C%EC%9D%98-AWS-Resource-%EC%A0%95%EC%9D%98%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/DEV/AWS-Community-Day-2022/CDK-for-Terraform%EC%9C%BC%EB%A1%9C-%EB%82%98%EB%A7%8C%EC%9D%98-AWS-Resource-%EC%A0%95%EC%9D%98%ED%95%98%EA%B8%B0/</guid>
      <description>IaC의 장점 # Infrastructure 버전을 관리할 수 있다. Infrastructure 선언적으로 관리할 수 있다. Infrastructure 여러 벌(set) 배포할 수 있다. 각 리소스의 필수 요소들을 파악하기 쉽다. 리소스가 대체될 것이라는 warning 문구를 표시해주기도 하고, replace 할 것인지 확인 여부를 묻는 기능도 있다. (approval 하면 실제 배포되는 것) 예상치 못한 과금을 예방할 수 있다. 비즈니스 로직 작성에 집중할 수 있다. CDK for TF # AWS CDK 개발진이 Hashi Corp와 함께 개발한 IaC Kit Generally Available at 2022.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/DEV/AWS-Community-Day-2022/%EA%B4%91%EA%B3%A0-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%88%98%EC%A7%91%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%9D%B8%ED%94%84%EB%9D%BC-%EA%B5%AC%EC%B6%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/DEV/AWS-Community-Day-2022/%EA%B4%91%EA%B3%A0-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%88%98%EC%A7%91%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%9D%B8%ED%94%84%EB%9D%BC-%EA%B5%AC%EC%B6%95/</guid>
      <description>https://jybaek.tistory.com/
Agenda # 광고 도메인 설명 # 굉장히 많은 (수십 개의) 매체에서 데이터를 수집하고 있다.
광고주마다 성과측정의 기준이 되는 기여기간이 다르다. 각 매체가 관리하는 광고 지면들로부터 뒤늦게 데이터가 집계되는 경우도 있다. (예를 들어, 시간이 지나면서 클릭수가 막 변경된다.) 수집 : (다양한 매체의) 대용량 광고 데이터 수집 # ECS 서비스를 사용하고 있다.
왼쪽부터 1번 순서로 진행된다. RDS 에서 스케줄러가 데이터 읽고, 키 정보? 조회 하여 Cache에 보낸다. Cache 에 보내지면 Collector 가 일겅와?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/DEV/AWS-Community-Day-2022/%EC%98%A4%ED%94%88-%EC%86%8C%EC%8A%A4-Karpenter%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-Amazon-EKS-%ED%99%95%EC%9E%A5-%EC%9A%B4%EC%98%81-%EC%A0%84%EB%9E%B5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/DEV/AWS-Community-Day-2022/%EC%98%A4%ED%94%88-%EC%86%8C%EC%8A%A4-Karpenter%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-Amazon-EKS-%ED%99%95%EC%9E%A5-%EC%9A%B4%EC%98%81-%EC%A0%84%EB%9E%B5/</guid>
      <description>Karpenter
오토스케일링 솔루션에 대한 고민 # 무신사는 ASG를 적극적으로 활용하고 있다.
(평소의)트래픽에 대한 예측이 (나름) 가능하다. 많이 들어오는 비슷하다. 트래픽 증가 폭이 완만하다. 평소에는 ASG 활용해서 CPU 사용률을 기반으로 점진적으로 스케일링 한다. 서비스 마다 CPU, 메모리 사용률이 제각각이기에 다양한 인스턴스 타입을 사용 중이다. 다만, 이벤트 기간에는 다르다.
사전에 미리 스케일 아웃 해둔다. 사전에 인지 못해도, 가능한 빨리 스케일 아웃될 수 있어야 한다. :zap: 따라서, 스케일 인/아웃 모두 빠르면서 서비스에 적합한 인스턴스를 비용-효율적으로 운영해야 한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/DEV/ifkakaodev-2022/Batch-Performance-%EA%B7%B9%ED%95%9C%EC%9C%BC%EB%A1%9C-%EB%81%8C%EC%96%B4%EC%98%AC%EB%A6%AC%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/DEV/ifkakaodev-2022/Batch-Performance-%EA%B7%B9%ED%95%9C%EC%9C%BC%EB%A1%9C-%EB%81%8C%EC%96%B4%EC%98%AC%EB%A6%AC%EA%B8%B0/</guid>
      <description>배치 코드의 경우 (비교적)운영 중 모니터링, 성능에 관심을 기울이지 않게 되는 것 같다.
READ # 성능 개선의 첫 걸음, Reader 개선
대부분의 배치에서 writer 보다 reader 가 차지하는 비중이 크다.
예를 들어, 위 그림과 같이 10억 건 중 100만 건을 추출해야 할 때 select 쿼리의 수정만으로도 큰 효과를 볼 수 있을 것이다.
Chunk Processing # 대용량에서는 chunk processing 이 필수이다. (절대적으로 사용될 것이다.)
문제점 : Pagination
Pagination 을 주로 사용할텐데 성능 관점에서 좋지 않다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/DEV/ifkakaodev-2022/JVM-warm-up/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/DEV/ifkakaodev-2022/JVM-warm-up/</guid>
      <description>카카오 계정 서버의 API 배포 과정 # Rolling update
Application Ready - Warm Up 사이에 n초 delay를 줄 수 있다.
Compilation Level # JIT # 위 과정에서 C1, C2는 별도 쓰레드로 동작한다.
C2 컴파일러의 큐가 가득차면, C1의 Level2 로 컴파일한다. 이후 여유가 생기면 Level3, 4 컴파일 처리가 진행된다.
Level2 컴파일이 많이 발생한다면, C2 컴파일러 큐가 가득찼다는 것을 알 수 있겠다. 이때는 C2 컴파일러 쓰레드 수를 조정할 필요가 있겠다.
Code Cache # 초기 캐시 사이즈와 최대 사이즈 조정이 가능하다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/DEV/ifkakaodev-2022/%EC%B9%B4%EC%B9%B4%EC%98%A4%ED%86%A1-%EB%A9%94%EC%8B%9C%EC%A7%95-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%9E%AC%EA%B1%B4%EC%B6%95-%EC%9D%B4%EC%95%BC%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/DEV/ifkakaodev-2022/%EC%B9%B4%EC%B9%B4%EC%98%A4%ED%86%A1-%EB%A9%94%EC%8B%9C%EC%A7%95-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%9E%AC%EA%B1%B4%EC%B6%95-%EC%9D%B4%EC%95%BC%EA%B8%B0/</guid>
      <description>카카오톡 메시징시스템 # 기준 값 평균 트래픽(TPS) 500K 최고 트래픽(TPS) 6.5M 평균 연결 세션 수 40M C++ 사용 이유 : 대량 트래픽 다루기 위해
C++ 백엔드 서버 애플리케이션 # epoll 기반의 비동기 입출력 지원 쓰레드 별로 미리 할당한 메모리 버퍼 사용 system call 호출(지연)을 줄이기 위해 미리 메모리 버퍼를 할당 받아 놓음 대당 500K 이상의 세션 관리 앞으로의 10년도 커버 가능할까? # 현재까지의 구조는 최적화에 목적을 둔, 하지만 유지보수하기는 힘든 구조였다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/DEV/int%EB%8A%94-%EB%AA%87-%EB%B0%94%EC%9D%B4%ED%8A%B8-%EC%9D%B8%EA%B0%80%EC%9A%94/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/DEV/int%EB%8A%94-%EB%AA%87-%EB%B0%94%EC%9D%B4%ED%8A%B8-%EC%9D%B8%EA%B0%80%EC%9A%94/</guid>
      <description>https://devocean.sk.com/blog/techBoardDetail.do?ID=164788
결론 # 1. 언어마다 다를 수 있다.
2. 시스템(플랫폼)마다 다를 수 있다.
C/C++ : 4 or 8 Byte # 시스템(플랫폼)에 의존적이다.
LLP64, LP64 등 데이터 모델에 따라 다르다.
Java : 4 Byte 고정 # 플랫폼에 독립적인 가상머신(JVM)에서 동작하기에 플랫폼의 영향을 받지 않는다.
4Byte 로 고정되어 있다.
Python : 8 Byte ~ # Python 의 경우 int 의 크기가 정해져 있지 않다.
sys.maxsize 의 경우, 시스템에 의존적인 형태라고 볼 수 있을 것 같다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/DEV/NGINX-%EA%B8%B0%EC%88%A0-%EB%B6%80%EC%B1%84%EA%B0%80-%EB%90%98%EC%A7%80-%EC%95%8A%EC%9C%BC%EB%A0%A4%EB%A9%B4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/DEV/NGINX-%EA%B8%B0%EC%88%A0-%EB%B6%80%EC%B1%84%EA%B0%80-%EB%90%98%EC%A7%80-%EC%95%8A%EC%9C%BC%EB%A0%A4%EB%A9%B4/</guid>
      <description>로드밸런서 # GSLB, LSLB, CSLB
요약 # Nginx 설정도 저장소에서 관리하자. 배포까지 자동화할 수 있다. 주석은 꼼꼼히 작성하자. 주기적으로 확인하여 필요하지 않은 설정은 제거하자. (계속해서 관리하자.) mirror # nginx 설정은 업데이트를 한다. 기존 설정이 변경되다보니 항상 걱정하게 된다.
mirror 는 들어온 요청을 그대로 복제해서 또 다른 upstream 서버 / block 으로 보내주는 역할을 한다.
이를 통해 기존 로직을 손대지 않고 설정 테스트가 가능하다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/DEV/Reactive-Programming/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/DEV/Reactive-Programming/</guid>
      <description>Reactive Programming # 참고
https://gngsn.tistory.com/223 https://en.wikipedia.org/wiki/Reactive_programming Keywords
Data Stream Functional Programming Asynchronous Declarative Programming Paradigm Reactive programming is a declarative programming paradigm concerned with data streams and the propagation of change.
&amp;quot; Reactive Programming은 데이터 스트림을 비동기 처리하는 선언형 프로그래밍입니다. 선언형 프로그래밍이란 기존의 명령형 프로그래밍 방식과 대비되는 새로운 프로그래밍 패러다임으로, 라인 단위의 프로그래밍 과정과 달리 특정 목적과 같이 무엇을 하는 지를 명시하여 개발하는 과정입니다. 리액티브 프로그래밍은 아래 3가지(Data Stream, Functional Programming, Asynchronous) 측면으로 기존 프로그래밍 방식의 문제점들을 해결합니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/DEV/The-NIST-Model-for-Role-Based-Access-Control-Towards-A-Unified-Standard/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/DEV/The-NIST-Model-for-Role-Based-Access-Control-Towards-A-Unified-Standard/</guid>
      <description>1. INTRODUCTION # The lack of standards for RBAC has led to roles being implemented in different ways, impeding the advance of RBAC technology.
The goal of this paper is to provide a standard in this arena.
The basic role concept is simple: establish permissions based on the functional roles in the enterprise, and then appropriately assign users to a role or set of roles
Roles colud represent the tasks, responsibilities, and qualifications associated with an enterprise.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/DEV/Top-10-Architecture-Characteristics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/DEV/Top-10-Architecture-Characteristics/</guid>
      <description>Top 10 Architecture Characteristics # 참고 : https://medium.com/@abd0hrz/top-10-architecture-characteristics-non-functional-requirements-with-cheatsheet-f639458d357d
1. Scalability # Scalability is a achievable with horizontal/vertical scaling of the machine.
Traffic Pattern # Understand the traffic pattern of the system. :star:
Pattern Diurnal Pattern Traffic increases in the morning and decreases in the evening for a particular region. Global / Regional Regional Heavy usage of the application. Thundering Herd These could occur during peak time or in densely populated areas.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/DEV/Woowa-course-%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/DEV/Woowa-course-%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0/</guid>
      <description>1. getter 대신에 객체에 물어보는 형태로 작성해보자.
* 적절한 예시인지 모르겠다. 아무튼 getter 보다 최대한 객체의 method 를 활용해보는 것? 이 포인트 인 것 같다.
Man man = new Man(); ... // A if(man.getAge() &amp;gt; 10) { ... } // B if(man.isOverTenAge()) { ... } 2. 될 수 있으면 숫자, 문자열 값에 대한 상수(변수) 처리를 하자.
혹은 Enum 클래스를 사용하도록 하자.
3. 한 테스트 함수(코드)에서 여러 개를 테스트하지 말자.
n 개를 테스트하고자 한다면, n 개의 테스트 함수를 만들자.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/DEV/%EB%B8%94%EB%9E%99%EC%9E%AD-%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0-%EA%B8%80%EC%9D%84-%EC%9D%BD%EA%B3%A0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/DEV/%EB%B8%94%EB%9E%99%EC%9E%AD-%EC%BD%94%EB%93%9C%EB%A6%AC%EB%B7%B0-%EA%B8%80%EC%9D%84-%EC%9D%BD%EA%B3%A0/</guid>
      <description>Okky fender, jojoldu 님의 글을 읽고 느껴지는 부분, 공감되는 부분에 대해서 정리해보기
초보 개발자에게 권장하는 객체지향 모델링 공부 방법
객체지향 좀 더 이해하기 - 블랙잭 게임 구현(1)
아래 코드에서 개선할 수 있는 부분은 무엇이 있을지 생각해본다. # public Card draw(){ int size = cards.size(); int select = (int)(Math.random()*size); Card selectedCard = cards.get(select); cards.remove(select); return selectedCard; } 위의 코드는 (카드덱)객체에서
가지고 있는 카드 리스트 중 랜덤한 카드 한장을 뽑고 그 카드는 리스트에서 제거하는 코드이다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/DEV/%EC%98%88%EC%99%B8-%EC%B2%98%EB%A6%AC-%EC%A0%84%EB%9E%B5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/DEV/%EC%98%88%EC%99%B8-%EC%B2%98%EB%A6%AC-%EC%A0%84%EB%9E%B5/</guid>
      <description> 예외 처리 전략 # 예외 복구 다른 작업의 흐름을 유도한다.
예외 처리 회피 처리하지 않고 호출한 쪽으로 예외를 던진다.
예외 전환 명확한 의미의 예외로 전환하여 예외를 던진다.
Reference
https://www.nextree.co.kr/p3239/ </description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/DEV/%EC%9A%B0%EC%95%84%ED%95%9C-%ED%85%8C%ED%81%AC-%EC%84%B8%EB%AF%B8%EB%82%98-%EC%96%B4%EB%94%94-%EA%B0%80%EC%84%9C-%EC%BD%94%ED%94%84%EB%A7%81-%EB%A7%A4%EC%9A%B0-%EC%95%8C%EC%9D%80-%EC%B2%B4%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/DEV/%EC%9A%B0%EC%95%84%ED%95%9C-%ED%85%8C%ED%81%AC-%EC%84%B8%EB%AF%B8%EB%82%98-%EC%96%B4%EB%94%94-%EA%B0%80%EC%84%9C-%EC%BD%94%ED%94%84%EB%A7%81-%EB%A7%A4%EC%9A%B0-%EC%95%8C%EC%9D%80-%EC%B2%B4%ED%95%98%EA%B8%B0/</guid>
      <description>DSL (Domain Specific Language) : 도메인에 특화된 언어, 즉 범용적인 언어가 아닌 (해당 도메인에 대해서만) 사용되는 언어.
이번 세미나의 내용은 간략하게 아래의 내용을 포함하고 있다.
Kotlin DSL 에 대해 살펴보고 Kotlin 사용 시 주의사항 (with SpringBoot) 개요 # 코틀린은 JVM, 안드로이드, Javascript, 네이티브 등에서 동작할 수 있는 (혹은 이것들을 대상으로 하는) 컴파일 언어이다. OO(Object-Oriented), FP(Functional-Programmin) 두 스타일 모두 활용할 수 있다. 간결하고, 실용적이다. (+ 최근에 &amp;lsquo;코루틴&amp;rsquo; 이라는 것이 주목받고 있다고 한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/DEV/%EC%9A%B0%EC%95%84%ED%95%9C-%ED%85%8C%ED%81%AC-%EC%84%B8%EB%AF%B8%EB%82%98-%EC%9A%B0%EC%95%84%ED%95%9C-Redis-2019/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/DEV/%EC%9A%B0%EC%95%84%ED%95%9C-%ED%85%8C%ED%81%AC-%EC%84%B8%EB%AF%B8%EB%82%98-%EC%9A%B0%EC%95%84%ED%95%9C-Redis-2019/</guid>
      <description>우아한 테크 세미나 : 우아한 Redis (2019) # 이번 세미나에서 다루지 않는 것들
Redis Persistence(RDB, AOF) Redis Pub/Sub Redis Stream 확률적 자료구조 Hyperlog Redis Module Redis 소개 # In-Memory 데이터 저장소 Open Source (BSD 3 License) 지원하는 자료구조 String Set Sorted-Set Hash List Hyperloglog Bitmap Geospatial index Stream Only 1 Commiter Cache 란? # 결과를 미리 저장해두었다가 빠르게 제공하는 것
ex : (dp) factorial Disk Memory L3 cache L2 cache L1 cache core Cache 아키텍처 #1 : Look-Aside Cache # Client - Server - DB ㄴ Cache 캐시를 먼저 조회한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/DEV/%EC%9A%B0%EC%95%84%ED%95%9C-%ED%85%8C%ED%81%AC-%EC%84%B8%EB%AF%B8%EB%82%98-%EC%9A%B0%EC%95%84%ED%95%9C%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-2019/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/DEV/%EC%9A%B0%EC%95%84%ED%95%9C-%ED%85%8C%ED%81%AC-%EC%84%B8%EB%AF%B8%EB%82%98-%EC%9A%B0%EC%95%84%ED%95%9C%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-2019/</guid>
      <description>2019년 &amp;ldquo;우아한Tech - 우아한객체지향 by 조영호님&amp;rdquo; 유투브 세미나를 듣고 내용 정리하기
제목 : &amp;lsquo;우아한 객체지향 의존성을 이용해 설계 진화시키키&amp;rsquo;
설계에서 가장 중요한 것은 &amp;lsquo;의존성&amp;rsquo;이다. &amp;lsquo;의존성&amp;rsquo;을 어떻게 설정,관리하느냐에 따라 설계가 많이 달라진다.
의존성(Dependency)
설계는 코드를 어떻게 배치할 것인가? 어떤 코드를 어디에 넣을 것인가? 어떤 코드를 어디 클래스에, 어디 패키지에 넣을건지 등에 대한 고민을 하는 것이다.
변경에 초점을 맞춰야한다. 같이 변경되는 코드를 같이 넣어줘야하고, 같이 변경되지 않는 것은 따로 넣는다. (= 결국에는 의존성과 관련이 있다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/DEV/%EC%9A%B0%EC%95%84%ED%95%9C-%ED%85%8C%ED%81%AC-%EC%84%B8%EB%AF%B8%EB%82%98-%EC%9A%B0%EC%95%84%ED%95%9C%EC%8A%A4%ED%94%84%EB%A7%81%EB%B0%B0%EC%B9%98-2019/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/DEV/%EC%9A%B0%EC%95%84%ED%95%9C-%ED%85%8C%ED%81%AC-%EC%84%B8%EB%AF%B8%EB%82%98-%EC%9A%B0%EC%95%84%ED%95%9C%EC%8A%A4%ED%94%84%EB%A7%81%EB%B0%B0%EC%B9%98-2019/</guid>
      <description>@ConditionalOnProperty 사용 여부 # 개요 : Job(Bean) 수가 많아짐에 따라, 초기 로딩 속도가 느려질 수 있음
현재 실행할 Job 만 Bean 으로 띄우기 위해 @ConditionalOnProperty 사용
= 필요한 Bean 만 등록 -&amp;gt; 초기 로딩 속도 빨라짐 = 단, @ConditionalOnProperty 사용 시 테스트 코드 실행 시 속도가 느려짐
@ConditionalOnProperty 사용 시 마다 (테스트)컨텍스트를 다시 띄움 결론
목적 사용 여부 실제 동작에 우선순위가 있을 때
빠르게 Job 을 띄우고 실행할 때 @ConditionalOnProperty 사용 O 테스트 코드에 우선순위가 있을 때</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/DEV/%EC%9A%B0%EC%95%84%ED%95%9C-%ED%85%8C%ED%81%AC-%EC%BD%94%EC%8A%A4-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EB%82%B4%EC%97%90-%EC%99%B8%EB%B6%80-%EB%A6%AC%EC%86%8C%EC%8A%A4-%EC%9A%94%EC%B2%AD%EC%9D%B4-%EB%8B%B4%EA%B8%B0%EA%B2%8C-%EB%90%98%EB%A9%B4-%EC%96%B4%EB%96%A4-%EB%AC%B8%EC%A0%9C%EA%B0%80-%EB%B0%9C%EC%83%9D%ED%95%A0%EA%B9%8C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/DEV/%EC%9A%B0%EC%95%84%ED%95%9C-%ED%85%8C%ED%81%AC-%EC%BD%94%EC%8A%A4-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EB%82%B4%EC%97%90-%EC%99%B8%EB%B6%80-%EB%A6%AC%EC%86%8C%EC%8A%A4-%EC%9A%94%EC%B2%AD%EC%9D%B4-%EB%8B%B4%EA%B8%B0%EA%B2%8C-%EB%90%98%EB%A9%B4-%EC%96%B4%EB%96%A4-%EB%AC%B8%EC%A0%9C%EA%B0%80-%EB%B0%9C%EC%83%9D%ED%95%A0%EA%B9%8C/</guid>
      <description>출처 : 트랜잭션 내에 외부 리소스 요청이 담기게 되면 어떤 문제가 발생할까?
간단 요약 # DB 트랜잭션 시, 꼭 필요한 부분(범위)에만 트랜잭션이 걸릴 수 있도록 한다.
불필요한 부분(예를 들어, DB 트랜잭션과 관련 없는 외부 API 호출 등)은 분리한다.
예시 # OutGoingService : 외부API호출서비스.class DBTxService : 꼭필요한DB트랜잭션서비스.class
class DBTxService { @Transactional void save() { ... } } class OutGoingService { private final DBTxService dbTxService; void save() { // 외부 API 호출 로직 dbTxService.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/DEV/%EC%B9%B4%EC%B9%B4%EC%98%A4%ED%86%A1-Java-App-Server-Refactoring-%ED%9B%84%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/DEV/%EC%B9%B4%EC%B9%B4%EC%98%A4%ED%86%A1-Java-App-Server-Refactoring-%ED%9B%84%EA%B8%B0/</guid>
      <description>객체를 수정하기 위해서, (메서드에서) 객체를 파라미터로 받아 메서드 내부에서 해당 객체를 수정하지 말자. # 어떤 클래스를 파라미터로 받으면 결합도가 높아진다.
다음은 (Car 객체를 필드로 갖는) CarContext 객체의 Car 필드를 새로운 값으로 설정하는 예시이다.
&amp;quot; 아래와 같이, 함수 내부에서 만드는 새로운 값 또는 상태를 함수의 안에서 외부 객체의 상태 변경에 직접 적용하는 것은 좋지 않습니다. 가능하면 리턴으로 받아서 처리하는 방식이 좋습니다. &amp;quot;
// Bad Result createCar(CarContext carContext, Something A, Something B) { .</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/DEV/%EC%BA%90%EC%8B%B1-%EC%A0%84%EB%9E%B5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/DEV/%EC%BA%90%EC%8B%B1-%EC%A0%84%EB%9E%B5/</guid>
      <description>6-Caching Strategies to Remember while designing Cache System
Key Metrics # 캐시 히트율 (cache hit ratio) 응답 시간 (latency) 처리량 (throughput) 캐시 사이즈 (cache size) 캐시 미스율 (cache miss ratio) Read Intensive Application Caching # Cache-aside Cache-through Refresh-ahead Cache-aside # 캐시가 미스됐을 때, 3번의 trip 이 발생해 급격한 딜레이가 생길 수 있다. 데이터베이스에 업데이트하고 캐시에는 업데이트를 누락하여 캐시의 데이터가 낡은 상태로 유지될 수 있다. &amp;quot; Data might become stale if someone updates the database without writing to the cache.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/ETC/01.-AB-%ED%85%8C%EC%8A%A4%ED%8A%B8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/ETC/01.-AB-%ED%85%8C%EC%8A%A4%ED%8A%B8/</guid>
      <description>A/B 테스트 # 전체 대상자를 대조군과 실험군(A, B)로 나누어 변수(UI, 알고리즘 등)를 실험하는 것 = 더 가치 있는 변수를 식별 → 최고의 시안을 선정하는 것
예를 들어, 웹사이트의 디자인, 마케팅, 광고에서 &amp;lsquo;가장 좋은 효과를 낼 수 있는 전략&amp;rsquo;을 선택하기 위해 실험하는 것이다.
용어 설명 대조군 (control group) 현재 사용 중이거나 주로 사용되어온 변경되지 않은 버전 실험군(Experimental Group) 처리군 (Treatment Group) 챌린저 (Challenger) 새롭게 실험할(시도할) 버전 챔피언 (champion) (AB 테스트 실행 후 얻은) 목표에 근접한 버전 방식 방법 특징 적합한 사용 노출 분산 방식 A, B 의 노출을 &amp;lsquo;일정 비율&amp;rsquo;로 노출한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/ETC/02.-Blocking-NonBlocking-Sync-Async/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/ETC/02.-Blocking-NonBlocking-Sync-Async/</guid>
      <description>Blocking-NonBlocking-Synchronous-Asynchronous 글을 참고합니다.
관심사의 차이 # 키워드 관심사 Blocking / Non-Blocking 함수가 바로 응답하는지, 안하는지 Blocking : 함수 호출 후 함수가 완료될 때까지 기다린다. Non-Blocking : 함수 호출 후 함수가 완료되는 것을 기다리지 않는다.
= 즉, 함수를 호출한 곳에 제어권을 곧바로 넘겨준다. = 즉, 함수를 호출한 곳은 다른 일을 할 수 있다. Sync / Async 함수의 &amp;lsquo;완료&amp;rsquo;를 누가 신경쓰는지 Sync : 함수의 완료(응답)을 호출한 쪽에서 신경쓴다. Async : 함수의 완료(응답)을 호출당한 쪽에서 신경쓴다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/ETC/03.-DB-Trigger/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/ETC/03.-DB-Trigger/</guid>
      <description>트리거에 대해 찾아본 내용 정리해보기
트리거란? # (데이터베이스에서) 데이터의 입력, 수정, 삭제 등의 이벤트가 발생할 때 자동으로 수행되는 (사용자 정의)프로시저이다.
(즉, 이벤트에 반응하여 실행되는 프로그램)
트리거는 TABLE 에 종속되는 개념이 아니라, DATABASE 에 종속되는 개념이다.
(즉, DATABASE에 저장된다.)
트리거는 VIEW 가 아닌 실제 TABLE 에 관해서만 작성(정의)할 수 있다.
보통 제약조건으로 명시할 수 없는 무결성 제약조건을 지키기 위해(무결성 보장), 혹은 관련 테이블의 데이터를 일치(수정)시켜야 할 때(DB 관리 자동화) 등의 목적으로 사용된다고 한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/ETC/04.-Docker-multi-arch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/ETC/04.-Docker-multi-arch/</guid>
      <description>Multi-platform images # 도커 이미지는 여러 플랫폼(아키텍처)를 지원할 수 있다. 즉 하나의 단일 이미지는 여러 개의 아키텍처, OS 환경에서 동작할 수 있다.
(멀티 아키텍처의 이미지는) 이미지가 실행될 때, 자동적으로 맞는 OS, 아키텍처를 선택하여 구동된다.
Docker images can support multiple platforms, which means that a single image may contain variants for different architectures, and sometimes for different operating systems, such as Windows.
When running an image with multi-platform support, docker automatically selects the image that matches your OS and architecture.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/ETC/05.-FTP-active-vs-passive/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/ETC/05.-FTP-active-vs-passive/</guid>
      <description>FTP active vs passive # FTP 는 2개의 포트를 사용한다.
Command 포트: 주로 21번 포트를 사용하며, 연결 시에 사용되는 포트 Data 포트: 주로 20번 포트를 사용하며, 데이터 전송 시에 사용되는 포트 Active 모드 # Client -&amp;gt; Server: 연결 시도 (21번 포트) Server -&amp;gt; Client: OK 응답 Server -&amp;gt; Client: Data 채널 연결 요청 &amp;lt;&amp;mdash; active Client -&amp;gt; Server: OK 응답 흔히, Client -&amp;gt; Server 로 연결을 시도하는 방식과 달리, Server -&amp;gt; Client 로 연결을 시도한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/ETC/06.-Lettuce-ReadFrom/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/ETC/06.-Lettuce-ReadFrom/</guid>
      <description>ReadFrom # Defines from which Redis nodes data is read.
read 커맨드, write 커맨드 식별 방법 # io.lettuce.core.cluster.ReadOnlyCommands 클래스 참고
redis 커맨드를 기준으로 식별한다.
lua script # 스크립트는 eval, evalsha 커맨드로 실행 -&amp;gt; read 커맨드로 판단한다.
REPLICA_PREFERRED vs MASTER_PREFERRED # master(write)커넥션, replica(reader)커넥션을 리스트에 저장한다. reader 커넥션을 가져올 때 1번의 리스트 중 0번째 인덱스에서 가져온다. 분류 컬렉션 내 커넥션 순서 REPLICA_PREFERRED 0번째 인덱스 : reader 1번째 인덱스 : writer MASTER_PREFERRED 0번째 인덱스 : writer 1번째 인덱스 : reader MASTER_PREFERRED</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/ETC/07.-LocalDate-OpenJDK-Suggestion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/ETC/07.-LocalDate-OpenJDK-Suggestion/</guid>
      <description>SUGGESTION # A DESCRIPTION OF THE PROBLEM : I think a lot of people write the following code to get tomorrow and yesterday.
LocalDate tomorrow = LocalDate.now().plusDays(1); LocalDate yesterday = LocalDate.now().minusDays(1); I think supporting tomorrow() and yesterday() functions will make it more convenient, meaningful, and more readable.
For example we can get &amp;rsquo;tomorrow&amp;rsquo;, &amp;lsquo;yesterday&amp;rsquo; like following code.
LocalDate tomorrow = LocalDate.tomorrow(); // or LocalDate.tomorrow(zone); or LocalDate.tomorrow(clock); LocalDate yesterday = LocalDate.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/ETC/08.-Locale-vs-TimeZone/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/ETC/08.-Locale-vs-TimeZone/</guid>
      <description>Locale TimeZone The place where something happens. The set of settings related to the language and region in which a computer program executes. Examples are language, paper format, currency and time formats, character encoding etc. 프로그램이 실행되는 언어(language), 지역(region)과 관련된 설정
(예시) 언어, 통화, 시간 형식, 문자 인코딩 등 A vertical region of the globe that somewhat corresponds to longitude, that uses the same time. 출처 : https://wikidiff.com/timezone/locale
LOCALE # 프로그램이 실행되는 언어(language), 지역(region)과 관련된 설정</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/ETC/09.-MQTT/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/ETC/09.-MQTT/</guid>
      <description>MQTT (Message Queueing Telemetry Transport) # Telemetry : 원격 측정(법)
다음과 같은 상황에서 사용될 수 있는 메시지 송/수신 프로토콜이다.
(1) 작은 코드 공간에서 동작하기 위해서 (2) 제한된 네트워크 대역폭에서 동작하기 위해서 (ex: IoT) (3) 대규모 트래픽 전송을 위해서
TCP/IP 위에서 동작하지만 굉장히 가볍고, 많은 통신 제약들을 해결해준다고 한다.
MQTT 는 Bluetooth, Zigbee 처럼 별도의 모듈 / 별도의 대역폭을 갖는 통신 규약이 아닌, WiFi와 같은 인터넷을 통해 TCP/IP 기반의 메시지 송수신 프로토콜이다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/ETC/10.-non_blocking_vs_blocking/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/ETC/10.-non_blocking_vs_blocking/</guid>
      <description>https://nodejs.org/ko/docs/guides/blocking-vs-non-blocking/
https://velog.io/@codemcd/Sync-VS-Async-Blocking-VS-Non-Blocking-sak6d01fhx
http://homoefficio.github.io/2017/02/19/Blocking-NonBlocking-Synchronous-Asynchronous/</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/ETC/11.-OKR/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/ETC/11.-OKR/</guid>
      <description>&amp;quot; OKR이 간단해 보이지만 헷갈리는 이유는 &amp;lsquo;이니셔티브&amp;rsquo;를 구분하지 않기 떄문입니다. &amp;ldquo;
Objectives (목표) # = 이루고자 하는 &amp;lsquo;목표(목적)&amp;rsquo;
목표는 영감을 주어야하며, 회사의 우선순위에 부합해야 한다. 목표는 수치보다 정성적 문구로 표현하여 구성원의 동기를 부여한다. 책마다, 글마다 의견이 다른 것 같기도하다. (아래 예시처럼 책에서는 구체적인 수치를 제시한다.)
예시 # O1. 온라인 판매의 매출 신기록을 세운다.
O2. 하루 시청 시간을 10억 시간으로 늘린다. (2016년까지)
O3. 2040년까지 전 세계 말라리아 퇴치한다.
Key Results (핵심 결과) # = 목표를 이루기 위해 얻어야하는 &amp;lsquo;결과&amp;rsquo;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/ETC/12.-Pinpoint/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/ETC/12.-Pinpoint/</guid>
      <description>Pinpoint # 대규모 분산 시스템 추적 플랫폼, Pinpoint
&amp;quot; 다양한 도구와 APM(application performance management)을 사용하고 있었으나 이것으로는 부족했다. 결국 시스템 복잡도가 높아지며 발생하는 문제를 해결하기 위해 n계층 아키텍처를 효과적으로 추적할 수 있는 새로운 플랫폼을 개발하기로 했다. &amp;ldquo;
분산 시스템에서 (1)성능을 분석하고, (2)문제를 진단, 처리하는 플랫폼이다.
다음과 같은 특징/기능이 있다.
특징 / 기능 설명 분산 트랜잭션 추적 분산 애플리케이션에서 메시지를 추적할 수 있다. 애플리케이션 토폴로지 자동 발견 애플리케이션의 구성을 자동으로 파악할 수 있다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/ETC/13.-PR-%ED%9B%84%EA%B8%B0-Admin2-Free-Admin-Template/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/ETC/13.-PR-%ED%9B%84%EA%B8%B0-Admin2-Free-Admin-Template/</guid>
      <description>PR 을 날려보았다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/ETC/14.-Trigger-vs-ApplicationBusiness-Logic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/ETC/14.-Trigger-vs-ApplicationBusiness-Logic/</guid>
      <description>트리거 vs Application Logic 비교해보기
인터넷들의 글/댓글들을 읽어 종합해본 내용입니다.
Trigger # 개발자 입장에서 유지보수가 어렵다.
(반대로) 예전 글(2010년대 초반)을 보면 Trigger 가 유지보수가 더 쉽다는 의견/글들이 있는 것 같다.
빌드/배포 시간에 제약이 없다.
Application -&amp;gt; DB call 횟수가 줄어든다.
성능(처리율, 속도) 우수하다.
(Application Logic 반대 의견) (한 액션 시 여러 개의 DB Table 에 삽입/수정 등이 이뤄질 때) Application Logic 으로 관리하면 Exception, Transaction 등을 신경써줘야 한다.
Application Logic # 개발자 입장에서 유지보수가 쉽다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/ETC/15.-Useful-Tips-for-naming-variables/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/ETC/15.-Useful-Tips-for-naming-variables/</guid>
      <description>https://medium.com/better-programming/useful-tips-for-naming-your-variables-8139cc8d44b5</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/ETC/16.-UTF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/ETC/16.-UTF/</guid>
      <description>평면(Plain)
0 ~ 2^16 범위를 표현하는 코드표(세트) 총 17개(0 ~ 16개)의 평면(plaon) 존재 BMP(Basic multilingual plane) : 0번째 평면(plain) 거의 대부분의 문자는 BMP 에 속함 다만 이모지와 같은 최근에 사용되기 시작한 문자들은 속하지 않음 UCS-2 (Universal Character Set) # BMP(기본 다국어 평면)만 인코딩 (고정 사이즈) 문자당 2byte 표현 &amp;lsquo;평면&amp;rsquo; 을 구분하는데 2byte가 사용되는데, UCS-2는 BMP 고정이기 때문에 평면 구분 byte가 없어도 됨 BMP 외의 문자는 표현할 수 없음 UTF-32 (Unicode Transformation Format) # (고정 사이즈) 4byte 인코딩 방식 : 평면 구분(2byte) + 문자(2byte) 모든 유니코드 문자 표현할 수 있음 (단점) 용량 차지 1byte로 표현할 수 있는 것도 4byte 고정 거의 사용되고 있지 않음 UTF-16 # 가변 사이즈(2byte, 4byte) 인코딩 2byte : BMP 4byte : BMP 외의 유니코드 문자 (UTF32 와 같은 형태가 아님에 주의!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/ETC/17.-UTF8-4byte-%EB%AC%B8%EC%9E%90-%EC%B2%B4%ED%81%AC%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/ETC/17.-UTF8-4byte-%EB%AC%B8%EC%9E%90-%EC%B2%B4%ED%81%AC%ED%95%98%EA%B8%B0/</guid>
      <description>[DB] Charset &amp;amp; Collation 글과 연관이 있습니다.
Mysql UTF8의 경우 3byte로 디자인되었다. 4byte 문자를 처리하기 위해서는 아래와 같은 방법이 있다.
DB 스키마 변경 : charset/collation (e.g. utf8mb4) Application 처리 : (utf8)4byte 문자 확인 / 제거 등 이번 글에서는 2번의 방법을 살펴본다.
(UTF8) 4byte 문자의 종류 # UTF8 4byte로 된 문자는 아래 링크에서 확인할 수 있다.
https://design215.com/toolbox/utf8-4byte-characters.php
이모지, musical symbols 등의 다양한 문자가 있다.
(UTF8) 4byte 문자를 체크하는 방법 # 간단하게는, BMP 영역에 있는지를 체크하면 된다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/ETC/18.-WebSocket%EA%B3%BC-Socket.io/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/ETC/18.-WebSocket%EA%B3%BC-Socket.io/</guid>
      <description>WebSocket과 Socket.io 내용을 정리합니다.
웹 소켓의 등장 배경 # 전형적인 브라우저 상의 동작 방식, 서비스 제공 방식은 (1) 클라이언트 요청 -&amp;gt; (2) 서버 응답 (Client-Server 구조) 의 방식에서 벗어나지 않았다.
(시간이 지남에 따라, 더 나은 상호작용을 위해)Polling, Long Polling 등의 방법을 사용했지만 모두 클라이언트가 요청을 보내고 서버가 응답하는 &amp;lsquo;단방향 통신&amp;rsquo; 이다. (= 상호작용하는 서비스를 만들기 위해 복잡하고 어려운 코드를 구현해야 했다.)
보다 쉽게 상호작용할 수 있는 서비스, 기능을 제공하기 위해 &amp;lsquo;양방향 통신&amp;rsquo; 이 필요했고, WebSocket이 등장했다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/ETC/19.-%EB%AC%B4%EC%96%B4%EC%9D%98-%EB%B2%95%EC%B9%99/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/ETC/19.-%EB%AC%B4%EC%96%B4%EC%9D%98-%EB%B2%95%EC%B9%99/</guid>
      <description>무어의 법칙을 상기한다.
출처 : https://www.epnc.co.kr/news/articleView.html?idxno=200319
무어의 법칙 : 2년 혹은 18개월 마다 반도체의 집적도는 2배가 된다. # 사실 &amp;lsquo;법칙&amp;rsquo;이라는 말이 조금 어색하다고 한다.
반도체 업계에서 무어의 법칙은 경쟁에서 살아남기 위해 달성해야 하는 &amp;lsquo;규칙&amp;rsquo;으로 받아들였다고 한다.
다만, 최근 들어(약 2016년 이후) 인텔은 무어의 법칙(규칙) 개발 방식을 폐기했다.
2년 주기의 틱톡(TICK-TOCK) 개발 전략을 폐기하고, 3년 주기의 개발 사이클을 추진할 것이라고 발표했다고 한다.
참고로, 무어는 인텔 공동 설립자이다.
이유 : 기술의 한계 + 돈 # 업계에서 무어의 법칙이 더 이상 받아들여지지 않는 이유는 &amp;lsquo;기술의 한계&amp;rsquo;와 &amp;lsquo;돈&amp;rsquo;이다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/ETC/20.-%EC%82%AC%EB%82%B4%EC%97%90%EC%84%9C-%EC%82%AC%EC%84%A4-%EC%9D%B8%EC%A6%9D%EC%84%9C%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/ETC/20.-%EC%82%AC%EB%82%B4%EC%97%90%EC%84%9C-%EC%82%AC%EC%84%A4-%EC%9D%B8%EC%A6%9D%EC%84%9C%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0/</guid>
      <description>개요 # (사내)로컬 환경에서 개발을 할 때, HTTP 통신과 관련된 부분에서 종종 &amp;lsquo;SSL 인증서가 유효하지 않다&amp;rsquo; 라는 오류가 발생하곤 한다.
그때마다 1. HTTPS(443)통신을 HTTP(80)통신으로 수정한다거나 2. (HTTP API Library 에서 제공하는) Certification Verification 체크를 하지 않는다거나 3. 혹은 운이 좋게도 다른 분들이 먼저 설정해놓은 설정 값들이 있다면 그것들을 가져와 그대로 사용하곤 했다.
이번에도 동일한 문제가 발생했는데, 이번에는 이 부분에 대해서 정확히 이해하고 싶었다.
&amp;lsquo;여기&amp;rsquo;에서 관련된 내용이 너무나도 상세히 잘 설명되어 있다!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/ETC/21.-%EC%95%94%EB%8B%AC%EC%9D%98-%EB%B2%95%EC%B9%99/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/ETC/21.-%EC%95%94%EB%8B%AC%EC%9D%98-%EB%B2%95%EC%B9%99/</guid>
      <description>암달의 법칙을 상기한다.
[출처]
https://ko.wikipedia.org/wiki/%EC%95%94%EB%8B%AC%EC%9D%98_%EB%B2%95%EC%B9%99 https://namu.wiki/w/%EC%95%94%EB%8B%AC%EC%9D%98%20%EB%B2%95%EC%B9%99 암달의 법칙 : 컴퓨터 시스템의 일부를 개선했을 때 전체적으로 얼마만큼의 최대 성능 향상이 있었는지 계산하는 공식이다. # 전체 시스템 중 P%의 부분에서 S배의 성능 향상이 되었을 때, 전체 시스템의 성능 향상은 다음과 같다.
1 ----------------- (1 - P) + (P / S) 개선에 의해 영향을 받는 실행 시간 개선 후 실행시간 = ---------------------------------- 성능 향상 비율 + 영향을 받지 않는 실행 시간 &amp;lsquo;병목 현상&amp;rsquo;을 설명하기 위한 공식으로도 사용될 수 있다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/ETC/22.-%EC%95%95%EC%B6%95Compression/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/ETC/22.-%EC%95%95%EC%B6%95Compression/</guid>
      <description>압축 (Compression) # HTTP 압축 (1) : 성능 향상을 위한 다른 접근 기법 글을 읽어보면, 왜 압축이 필요한지? 어떤 상황에서 적절한지? 등에 대해 이해할 수 있다.
간단하게 요약하면,
압축을 적용하는 것이 모든 상황에서 이점을 주지 않을 수 있다. (최근에는 옛날에 비해 네트워크 환경이 좋아지면서 압축의 중요성이 떨어질 수도 있으려나..? 싶다.) 다만, (성능 향상을 위해) 충분히 고려해볼만한 요소이다. HTTP 압축 (2) : HTTP 압축 작동 원리 글을 읽어보면, (서버-클라이언트 사이에서의) &amp;lsquo;압축&amp;rsquo;에 대한 협상 과정을 살펴볼 수 있다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/ETC/23.-%EC%9C%A0%EB%8B%89%EC%8A%A4-%EC%8B%9C%EA%B0%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/ETC/23.-%EC%9C%A0%EB%8B%89%EC%8A%A4-%EC%8B%9C%EA%B0%84/</guid>
      <description>철도 시간표가 유닉스 시간이 되기까지 글을 읽고 정리한 내용
GMT # 19세기 초 지역마다 각자의 지방 평균시(Local Mean Time, LMT)를 사용했다.
지방 평균시란,
각자의 지역에서 태양이 최고 고도에 이르는 시각을 기준으로 삼는 시간 체계이다.
지방 평균시의 경우, 지역에 따라 시간이 달라질 수 있다.
(다양한 이유가 있겠지만, 글을 기반으로 하여) 철도 이슈로 인해 GMT 를 사용하자고 권고했다. (이렇게 GMT가 표준으로써 사용되기 사작한다.)
GMT 는 그리니치 천문대에서 관측한 평균시다.
본초 자오선은 그리니치를 지나는 자오선을 의미한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/ETC/24.-%EC%9D%B8%EC%BD%94%EB%94%A9-%EC%A0%95%EA%B7%9C%ED%99%94/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/ETC/24.-%EC%9D%B8%EC%BD%94%EB%94%A9-%EC%A0%95%EA%B7%9C%ED%99%94/</guid>
      <description>개요 # (최근에 회사 업무 중에) 고객이 업로드한 파일 이름의 자모음이 분할되어 저장되는 문제가 있었다. Mac 환경의 클라이언트가 해당 기능을 사용할 때 한글이 분할되는 현상이었다.
예를 들어, 클라이언트에서 가나다라.jpg 라는 파일을 업로드하면 ㄱㅏㄴㅏㄷㅏㄹㅏ.jpg의 이름으로 저장이 되었다.
관련된 내용을 찾아보니 인코딩, 정규화와 같은 키워드로 많은 내용이 있었다. 이것들을 읽고 내용을 정리해보고자 한다!
문자코드표, 문자인코딩 # 컴퓨터는 데이터를 바이트(혹은 숫자) 단위로 처리한다. 그러므로 &amp;lsquo;문자/글자&amp;rsquo;를 나타내려면 바이트/숫자 &amp;lt;&amp;ndash;&amp;gt; 문자/글자를 매칭시켜줘야한다. 어떤 기준으로, 어떻게 매칭시켜야 할 지에 대해 규칙을 정해놓은 것들이 ASCII, Unicode, UTF-8, EUC-KR 등인 것이다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/ETC/25.-%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%A1%9C%EB%94%A9-%EC%86%8D%EB%8F%84-%EA%B0%9C%EC%84%A0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/ETC/25.-%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%A1%9C%EB%94%A9-%EC%86%8D%EB%8F%84-%EA%B0%9C%EC%84%A0/</guid>
      <description>개요 # 고객이 메시지를 발송하면 그 기록을 관리툴에서 보여준다. 대략적으로 아래와 같이 생겼다.
발송 결과 리스트페이지
발송 결과 상세페이지
문제 # 특정 고객이 &amp;lsquo;발송 결과 상세페이지&amp;rsquo;에 접근할 때 20~40초 가량의 로딩 시간이 걸린다는 문의가 접수되었다.
급히 해당 부분에 대한 로직을 살펴보았는데 불필요한 for-loop, method 호출 등 많은 부분들에서 개선이 필요해보였다. 이 중 가장 효과적인 수정이 어떤 것일지 고민했다.
우선 쿼리부터 확인했다. 쿼리는 인덱스 힌트를 통해 인덱스를 탈 수 있도록 되어 있었다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/ETC/26.-%ED%95%98%EC%9D%B4%ED%8D%BC%EB%B0%94%EC%9D%B4%EC%A0%80/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/ETC/26.-%ED%95%98%EC%9D%B4%ED%8D%BC%EB%B0%94%EC%9D%B4%EC%A0%80/</guid>
      <description>개요 # 호스트 컴퓨터에서 다수의 운영 체제를 동시에 실행시키기 위한 기술(플랫폼) 단일 하드웨어에서 여러 개의, 다른 가상 머신을 실행시킬 수 있는 프로그램 게스트 운영 체제(Guest)에 가상 운영 플랫폼을 제공/관리하는 역할 예를 들어, 물리적인 리소스(CPU/Processor, RAM) 등을 분리/제공/관리 2가지의 종류 : Natvie/Bare-Metal , Hosted &amp;lsquo;VMM&amp;rsquo; 이라 불리우기도 한다. 가상화 머신 모니터(Virtual Machine Monitor) 가상화 머신 매니저(Virtual Machine Manager) 하이퍼바이저 유형 1 : Natvie / Bare-Metal # 하드웨어에 직접 설치되는 구조 호스트 OS 없음 즉, 하이퍼바이저가 호스트 OS 에 종속되지 않음 VM에 설치된 게스트 OS 들은 하드웨어 바로 위에서 구동 유형 2(Type2)보다는 성능 향상 다만, 유형 2(Type2) 보다는 설치, 구성 불편 (하드웨어 드라이버 세팅&amp;hellip;?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/ETC/27.-netty-resolver-dns-native-macos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/ETC/27.-netty-resolver-dns-native-macos/</guid>
      <description>로컬 환경 : m1 arm64
Caused by: java.io.FileNotFoundException: META-INF/native/libnetty_resolver_dns_native_macos_aarch_64.jnilib # Spring Cloud Gateway + Mock API 구성 후 간단한 테스트 시 다음과 같은 오류가 발생한다.
java.lang.reflect.InvocationTargetException: null at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) ~[na:na] at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) ~[na:na] ... at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74) ~[netty-common-4.1.78.Final.jar:4.1.78.Final] at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30) ~[netty-common-4.1.78.Final.jar:4.1.78.Final] at java.base/java.lang.Thread.run(Thread.java:829) ~[na:na] Caused by: java.lang.UnsatisfiedLinkError: failed to load the required native library at io.netty.resolver.dns.macos.MacOSDnsServerAddressStreamProvider.ensureAvailability(MacOSDnsServerAddressStreamProvider.java:110) ~[netty-resolver-dns-classes-macos-4.1.78.Final.jar:4.1.78.Final] at io.netty.resolver.dns.macos.MacOSDnsServerAddressStreamProvider.&amp;lt;init&amp;gt;(MacOSDnsServerAddressStreamProvider.java:120) ~[netty-resolver-dns-classes-macos-4.1.78.Final.jar:4.1.78.Final] ... 125 common frames omitted Caused by: java.lang.UnsatisfiedLinkError: could not load a native library: netty_resolver_dns_native_macos_aarch_64 at io.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/ETC/28.-serverless-framework/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/ETC/28.-serverless-framework/</guid>
      <description>serverless frameowkr 의 전반적인 컨셉과 내용은 Serverless Framework Concepts 문서를 참고한다.
작성 방법에 대한 예시는 Usage 문서 하위 내용을 참고하면 좋다. (+ Serverless.yml Reference)</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/ETC/29.-terraform/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/ETC/29.-terraform/</guid>
      <description>Terraform # Infrastructure as Code ( = Infrastructure 관리 도구 )
tfenv # 테라폼 버전 매니저
nvm 같은 버전 매니저
기본 개념 # 프로비저닝
프로세스, 서비스를 실행하기 위한 준비 단계
네트워크, 컴퓨팅 자원 준비 작업 (준비된 컴퓨팅 자원에) 사이트 패키지, 애플리케이션 의존성 준비 작업 명확한 경계는 불분명하지만 테라폼은 주로 전자(네트워크, 컴퓨팅 자원 준비)를 주로 다룬다.
프로바이더
테라폼 ⇿ 외부 서비스(프로바이더) 연결해주는 모듈
예를 들어, 테라폼으로 AWS 컴퓨팅 자원을 생성한다면 &amp;lsquo;aws 프로바이더&amp;rsquo; 프로바이더 종류 분류 AWS 클라우드 서비스 GCP 클라우드 서비스 Azure 클라우드 서비스 Github 특정 기능을 제공하는 서비스 Datadog 특정 기능을 제공하는 서비스 DNSimple 특정 기능을 제공하는 서비스 MySQL 로컬 서비스 RabbitMQ 로컬 서비스 Docker 로컬 서비스 &amp;hellip; &amp;hellip; 리소스(자원)</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/ETC/30.-Prometheus-PromQL/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/ETC/30.-Prometheus-PromQL/</guid>
      <description>프로메테우스는 실시간으로 시계열 데이터를 선택해 집계할 수 있는 PromQL(함수형 쿼리 언어)를 제공한다.
Type (Expression Language Data Types) # 프로메테우스의 표현식 언어에서, 표현식 또는 하위 표현식은 다음 타입 중 하나로 평가될 수 있다.
Instant vector : 같은 타임스탬프 상에 있는 시계열 셋으로, 각 시계열마다 단일 샘플을 가지고 있다. Range vector : 특정 시간 범위에 있는 시계열 셋으로, 각 시계열마다 시간에 따른 데이터 포인트들을 가지고 있다. Scalar : 간단한 부동 소수점 숫자 String : (현재 사용 X) 간단한 문자열 값 표현식을 사용하는 방식(e.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/ETC/31.-Prometheus/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/ETC/31.-Prometheus/</guid>
      <description>https://prometheus.io/docs/prometheus/latest/storage/#storage</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/ETC/99.-%EA%B7%B8%EB%A0%88%EC%9D%B4%EB%93%A4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/ETC/99.-%EA%B7%B8%EB%A0%88%EC%9D%B4%EB%93%A4/</guid>
      <description>:zap: compilePath &amp;amp; runtimeClasspath # :zap: testCompilePath &amp;amp; testRuntimeClasspath # &amp;quot; Configuration inheritance is heavily used by Gradle core plugins like the Java plugin. For example the testImplementation configuration extends the implementation configuration. &amp;ldquo;
출처 : Configuration inheritance and composition
:zap: example # dependencies { ... implementation &amp;#39;org.springframework.boot:spring-boot-starter-data-jpa&amp;#39; ... compileOnly &amp;#39;org.projectlombok:lombok&amp;#39; ... runtimeOnly &amp;#39;com.h2database:h2&amp;#39; runtimeOnly &amp;#39;mysql:mysql-connector-java&amp;#39; ... annotationProcessor &amp;#39;org.projectlombok:lombok&amp;#39; ... testImplementation &amp;#39;org.springframework.security:spring-security-test&amp;#39; ... } 참고 # [Spring] Gradle 파일 implementation, api, runtimeOnly, compileOnly&amp;hellip; 등에 대해 [Gradle] build.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/KAFKA/KAFKA-Kafka-Connect-Intro/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/KAFKA/KAFKA-Kafka-Connect-Intro/</guid>
      <description>Kafka Connect Cluster: An Introduction 글을 읽고, 요약한 내용
Kafka 를 사용하다보면, 카프카 클러스터에 없는 데이터를 처리해야하는 경우가 많이 있다.
예를 들어, 아래와 같은 곳에 존재하는 데이터를 처리해야하는 경우이다.
DB 외부 파일 외부 스토리지 ---&amp;gt; Kafka 외부 스토리지 &amp;lt;--- Kafka 이를 처리하기 위한 2가지 방법이 있다. # 1. 카프카 Producer 애플리케이션을 작성한다.
애플리케이션 생성 코드 작성 실패 처리 (해야한다.) scalability, polling 2. Kafka Connect 를 사용한다.
1번과 동일한 기능을 한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/KAFKA/KAFKA-Schema-Registry/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/KAFKA/KAFKA-Schema-Registry/</guid>
      <description> https://docs.confluent.io/platform/current/ schema-registry/index.html#schemas-subjects-and-topics
Apache Avro # &amp;quot; Apache Avro™ is the leading serialization format for record data, and first choice for streaming data pipelines. It offers excellent schema evolution, and has implementations for the JVM (Java, Kotlin, Scala, …), Python, C/C++/C#, PHP, Ruby, Rust, JavaScript, and even Perl. &amp;ldquo;
&amp;rdquo; Apache Avro™ is a data serialization system.&amp;quot;
Compatibility # https://medium.com/@gaemi/kafka-%EC%99%80-confluent-schema-registry-%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C-%EC%8A%A4%ED%82%A4%EB%A7%88-%EA%B4%80%EB%A6%AC-1-cdf8c99d2c5c
참고 # https://medium.com/@gaemi/kafka-%EC%99%80-confluent-schema-registry-%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C-%EC%8A%A4%ED%82%A4%EB%A7%88-%EA%B4%80%EB%A6%AC-1-cdf8c99d2c5c </description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/LANGUAGES/CPP/99.-unordered_map-vs-map/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/LANGUAGES/CPP/99.-unordered_map-vs-map/</guid>
      <description>결론 # 데이터가 많다면 unordered_map 을 사용하자. 대게 unordered_map 이 우수하다. 개념 # map
Red-Black Tree (RB Tree) 기반 key 정렬 키 값이 고르지 못할 경우, balancing 비용 커짐 O(logN) unordered_map
Hash Table 기반 O(1) 비교 # 대소비교 비용, 해싱 비용을 비교하여 예상할 수 있다.
Key 타입: 숫자
성능: unordered_map &amp;gt; map
Key 타입: 문자열
성능: unordered_map ?? map
문자열 비교 vs 문자열 해싱의 경우 문자열 비교의 비용이 클 수도, 작을 수도 있다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-Acquire-a-Lock-by-a-Key-in-Java/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-Acquire-a-Lock-by-a-Key-in-Java/</guid>
      <description>https://www.baeldung.com/java-acquire-lock-by-key
1. Simple Mutex Lock Example # public class MyLockClass { private static Set&amp;lt;String&amp;gt; usedKeys = ConcurrentHashMap.newKeySet(); public boolean tryLock(String key) { return usedKeys.add(key) } public void unlock(String key) { usedKeys.remove(key); } } String key = &amp;#34;key&amp;#34;; MyLockClass lock = new MyLockClass(); try { lock.tryLock(key); // 처리해야 할 코드 } catch(Exception e) { } finally { lock.unlock(key); } 2. Simple Mutex Lock Example V2 (not refuse, wait until release the lock) # The application flow will be:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-Callable-vs-Runnable/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-Callable-vs-Runnable/</guid>
      <description>Callable, Runnable 에 대해서 이해해보기
Java는 Multi-Threading 이라는 기술(기능)을 제공한다.
Runnable, Callable 인터페이스를 통해 Multi-Threading 기능을 설계할 수 있다.
Runnable : Multi-Threading 을 위해 제공되는 interface 이다. Callable : Runnable의 개선된 버전이다. (자바 5에서 추가) 두 인터페이스 모두 Multi-Threading 을 위한 것이다.
특징 Runnable Callable RETURN 리턴 타입 X 리턴 타입 O EXCEPTION Exception 발생 X Exception 발생 O 비고 Multi-Threading 을 위해 제공되는 interface 이다.
Thread, ExecutorService 클래스 등을 통해 사용될 수 있다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-Future/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-Future/</guid>
      <description>Future # (미래에) 결국에는 반환받을 결과를 표현하기 위해 사용되는 인터페이스이다.
&amp;quot; The Future interface is an interface that represents a result that will eventually be returned in the future. &amp;ldquo;
package java.util.concurrent; public interface Future&amp;lt;V&amp;gt; { boolean cancel(boolean var1); boolean isCancelled(); boolean isDone(); V get() throws InterruptedException, ExecutionException; V get(long var1, TimeUnit var3) throws InterruptedException, ExecutionException, TimeoutException; } 메서드 설명 get() 결과를 가져온다. 결과가 아직 반환되지 않았다면, 기다린다. 결과를 받기 전에 get() 호출하여 기다리게 된다면, 결과를 받을 때까지 &amp;lsquo;block&amp;rsquo; 한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-Garbage-Collection-%EA%B8%B0%EB%B3%B8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-Garbage-Collection-%EA%B8%B0%EB%B3%B8/</guid>
      <description>Garbage Collection # 사용 중이지 않은 객체(= Garbage)를 식별하여 정리(= 메모리 해제)
종류 # Serial GC Parallel GC &amp;hellip; CMS(Concurrent Mark Sweep) GC G1GC ZGC Mark &amp;amp; Sweep # Mark # 사용되는 메모리(객체)와 사용되지 않는 메모리(객체)를 식별하는 작업 (= reachability 를 판별하는 작업)
root set(객체에 대한 최초의 참조) 가 될 수 있는 요소
Java Stack (지역변수, 파라미터 등) Java Native Interface(= Native Stack) JNI에 의해 생성된 객체들이 있을 때 Method(Staic) Area (정적 변수) root set으로부터 시작해서 참조로 연결되어 있는 모든 객체들을 탐색한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-Garbage-Collection-%EC%A2%85%EB%A5%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-Garbage-Collection-%EC%A2%85%EB%A5%98/</guid>
      <description>Garbage Collection 종류 # Serial GC (-XX:+UseSerialGC) # Marking → Sweeping → Compaction 싱글 코어(쓰레드)를 위한 GC 절대 사용하지 않는 것을 권장 Parallel GC (Throughput GC) (-XX:+UseParallelGC) # Serial GC 알고리즘 동일 Serial GC 알고리즘 + 멀티 쓰레드 메모리가 충분, 코어 수가 많을 때 유리 Parallel Old GC (-XX:+UseParallelOldGC) # Marking → Summary → Compaction Parallel GC와 비교하여 Old 영역의 GC 알고리즘만 다르다. Summray 단게는 앞서 GC를 수행한 영역에 대해서 별도로 살아있는 객체를 식별한다?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-Interface-default-method/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-Interface-default-method/</guid>
      <description>Java 8 부터 Interface 에서 default method 를 구현할 수 있게 되었다.
추상 클래스와의 차이점 ?? # 용도/목적이 다르다.
abstract class 는 말 그대로 &amp;lsquo;클래스&amp;rsquo; 이다. extends 하는 것이다. 멤버변수, 접근제어 등의 기능을 갖는다. interface 는 말그대로 &amp;lsquo;인터페이스&amp;rsquo;이다. implements 하는 것이다. 인터페이스 다중 구현에서 Default 메서드가 중복일 때 # A 라는 클래스가 Interface1, Interface2 를 다중 구현하고 있는데, Interface1, Interface2 가 동일한 이름의 default 메소드를 갖고있다면 어떻게 될까.
결론 : (컴파일)에러가 난다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-Java-ClassPath/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-Java-ClassPath/</guid>
      <description> classpath 에 대해 정리해보기
CLASSPATH # (Windows의 시스템 환경 변수 처럼) Java 실행 시 클래스 파일들(.class)의 위치/경로 classpath에 실행하고자 하는 패키지(클래스)의 루트를 등록 예시 # /home/user/me/com/example/Test.class 를 실행하고자 할 때, 이 클래스가 위치한 경로로 찾아가지 않고 (java Teset 명령어를 통해)아무곳에서나 사용하고 싶다.
&amp;gt; vim .zshrc CLASSPATH=&amp;#34;/home/user/me/com/example&amp;#34; &amp;gt; java Test Hello, World! </description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-Java-Stream/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-Java-Stream/</guid>
      <description>Stream 에 대해 정리해보기
Stream # Java8 에서 java.util.stream 패키지에 Stream API 추가
다양한 데이터 소스(source)를 표준화된 방법으로 다루기 위한 기술
Stream API 의 특징은 다음과 같다. # 데이터(컬렉션, 배열 등)을 표준화된/하나의 방법을 통해 연산, 조작할 수 있다.
데이터를 스트림으로 만들고 나면 표준화된(하나의) 방법으로 조작할 수 있다. 내부 반복(internal interation) 을 통해 작업을 수행한다.
스트림은 일회용이다.
최종 연산(소모)을 통해 스트림이 끝났다면, 다시 스트림 생성/조작해야 한다. 원본 데이터(original data)를 변경하지 않는다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-Java-String-Pool/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-Java-String-Pool/</guid>
      <description>String Pool 에 대해 이해해보기
Java에서 String 객체를 생성하는 2가지 방법 # new 연산자 String str = new String(&amp;quot;안녕하세요&amp;quot;); String Literal String str = &amp;quot;안녕하세요&amp;quot; 두 방식 모두 Heap 에 생성되지만, 차이점도 존재한다고 한다.
new 연산자 # (값이 같아도, 달라도) 서로 다른 주소(reference value)를 가진다. 즉, 계속해서 새롭게 생성한다. String str1 = new String(&amp;#34;안녕하세요&amp;#34;); // Heap 영역에 &amp;#34;안녕하세요&amp;#34; 라는 객체가 새롭게 저장된다. String str2 = new String(&amp;#34;안녕하세요&amp;#34;); // Heap 영역에 &amp;#34;안녕하세요&amp;#34; 라는 객체가 새롭게 저장된다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-JVM-%EC%9D%B8%EC%A6%9D%EC%84%9C-%EC%A0%81%EC%9A%A9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-JVM-%EC%9D%B8%EC%A6%9D%EC%84%9C-%EC%A0%81%EC%9A%A9/</guid>
      <description>JVM 에 신뢰할 수 있는 인증서 추가하기
개요 # &amp;lsquo;사내(사설) SSL을 사용하는 이유&amp;rsquo; 글에서 잠깐 적었는데, (로컬 환경)개발을 하면서 이 사내 인증서 때문에 통신 문제가 발생했다.
원인 # 테스트하고자 하는 작업의 흐름은 간단하게 다음과 같다.
Exception 이 터진다. Exception 에 대한 내용을 (사설 인증서가 적용된)Sentry 쪽으로 보낸다. Sentry 에 내용이 쌓이고, 사용자(개발자)에게 알림을 보내준다. 위의 2번의 과정에서 오류가 발생했고, 내가 이해한 원인은 다음과 같다.
(외부에서 받아온)JVM 은 당연히도 사내에서 사용하고 있는 사설 인증서 정보를 가지고 있지 않다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/LANGUAGES/JAVA/Java-JVM/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/LANGUAGES/JAVA/Java-JVM/</guid>
      <description>JVM # 자바 가상 머신(Java Virtual Machine)이다. (스택 기반의 가상 머신이다.)
* 여기서 가상 머신이란? 프로그램을 실행하기 위해 물리적인 기계(머신)와 유사한 (논리적인? 가상의?) 머신을 소프트웨어로 구현한 것이다.
Java Application 을 클래스 로더를 통해 읽어 들이고, Java API 와 함께 실행한다.
Java 와 OS 사이에서 중개 역할을 한다. Java 가 OS 에 구애받지 않고 사용할 수 있는 환경을 제공한다.
이 외 메모리 관리, GC 을 수행한다.
자바 프로그램의 실행 과정 # 프로그램이 실행되면 JVM 이 OS 로부터 메모리를 할당 받는다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-Lock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-Lock/</guid>
      <description>https://www.baeldung.com/java-concurrent-locks</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-Map/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-Map/</guid>
      <description>Map # 흔히 사용되는 구현체
HashMap LinkedHashMap HashTable ConcurrentHashMap TreeMap HashMap # // jdk 11 기준 public class HashMap&amp;lt;K, V&amp;gt; extends AbstractMap&amp;lt;K, V&amp;gt; implements Map&amp;lt;K, V&amp;gt;, Cloneable, Serializable { private static final long serialVersionUID = 362498820763181265L; static final int DEFAULT_INITIAL_CAPACITY = 16; // &amp;lt;-- 초기 사이즈 ... final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { HashMap.Node[] tab; int n; if ((tab = this.table) == null || (n = tab.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-MDC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-MDC/</guid>
      <description>다음 내용을 참고하자.
https://mangkyu.tistory.com/266 https://bcho.tistory.com/1316 https://logback.qos.ch/manual/mdc.html 출처: https://bcho.tistory.com/1316
요약하면, (ThreadLocal 기반으로 동작하며) CorrelationID + 메타 데이터를 Map 형태로 관리할 수 있다.
관리되는 메타 데이터들을 로깅 시 함께 남겨 애플리케이션 로그 추적을 쉽게 한다. (%X{placeholder} 패턴으로 남길 수 있다.)</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-Multi-Threading/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-Multi-Threading/</guid>
      <description>HW 관점에서의 Thread # CPU, Core, Thread
core : (CPU 내의) 물리적인 코어 thread : 논리적인 코어 &amp;ldquo;동시에 실행가능한 스레드 개수&amp;rdquo; 예시
CPU 2개 4코어 8스레드 -&amp;gt; 8개의 작업을 동시에 처리할 수 있음 SW(Java) 관점에서의 Thread # 이전부터 (HW 관점에서의)1코어 1스레드 환경에서, Java 는 n 개의 스레드를 사용할 수 있었음 -&amp;gt; &amp;lsquo;동시성&amp;rsquo;과 관련
&amp;lsquo;동시성&amp;rsquo; : 여러 개의 작업들이 짧은 시간 내에 번갈아 처리됨 -&amp;gt; 동시에 처리되는 것처럼 보여짐 컨텍스트스위칭 발생 &amp;lsquo;병렬성&amp;rsquo; : 작업들이 병렬적으로 처리되는 것 Java Thread 는 &amp;lsquo;동시성&amp;rsquo;을 가지는 것</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-Netty/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-Netty/</guid>
      <description>Channel # &amp;quot; A nexus to a network socket or a component which is capable of I/O operations such as read, write, connect, and bind. &amp;ldquo;
I/O(read, write, connect, bind) 작업을 할 수 있는 네트워크 소켓, 컴포넌트와의 연결점이다.
다음 기능을 제공한다.
channel 의 현재 상태 channel 의 구성 파라미터 (configuration parameters) channel 이 지원하는 I/O 작업 (read, write, connect, bind) channel 과 관련된 모든 I/O 이벤트, requests 를 핸들링하는 ChannelPipeline 모든 I/O 작업은 비동기이다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-Open-JDK/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-Open-JDK/</guid>
      <description>OpenJDK 공식 사이트
&amp;ldquo;썬 마이크로시스템즈는 라이선스에 문제가 있는 몇몇 모듈을 제외하고 openjdk.org에 JDK 코드 제공하였다. 이 코드는 공개되었다.&amp;rdquo;
OpenJDK 에는 여러 배급처(Vendor)가 존재한다.
JCP(Java Community Process) 를 통해 JSR(Java Specification Request) 표준이 정의된다.
JSR 내용을 기반으로 각 배급처(Vendor)가 구현한다.
TCK(Technology Compatibility Kit) 를 이용해, JSR 표준에 잘 맞춰져 개발이 되었는지 검증/테스트 한다.
OpenJDK 종류 # Community / Vendor Product name OSS / Commercial Architecture Description Oracle Oracle JDK Commercial Hotspot - OpenJDK.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-Optional-orElse-vs-orElseGet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-Optional-orElse-vs-orElseGet/</guid>
      <description>orElse(T other) vs orElseGet(Supplier&amp;lt;? extends T&amp;gt; other) # 간단 요약 # orElse() : Optional null 여부에 상관없이 메서드를 호출하여 (메서드의) 값을 반환한다.
orElseGet() : Optional null 인 경우에만 메스드를 호출(supplier.get() 호출)하여 (메서드의) 값을 반환한다.
메서드의 인자를 보면 명확한 차이점이 있다. (Supplier의 Lazy Evaluation) (T other) vs (Supplier&amp;lt;? extends T&amp;gt; other)
/** * Return the value if present, otherwise return {@code other}. * * @param other the value to be returned if there is no value present, may * be null * @return the value, if present, otherwise {@code other} */ public T orElse(T other) { return value !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-Reflection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-Reflection/</guid>
      <description>Reflection # 로드된 클래스의 정보를 찾을 수 있게 지원합니다.
구체적인 클래스(구현 클래스, 구현체)의 타입을 몰라도 그 클래스의 정보(변수, 타입, Method)에 접근할 수 있게 해주는 API입니다.
//참조 클래스 구체적인 클래스 Object obj = new Car(); 동작 원리 # 동작원리는 다음과 같습니다.
JVM이 실행되면, 클래스로더에 의해 사용자가 작성한 클래스가 Method area(Class area, Static area)에 저장됩니다. Reflection API 는 이 정보를 활용합니다. 예시 # 아래는 Reflection API 를 사용한 예제입니다.
// Reflection API 예제 Object obj = new Car(); Class carClass = Car.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-Stack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-Stack/</guid>
      <description>Thread-safe
Vector 클래스 상속 push, size =&amp;gt; Vector 클래스의 메서드 사용 synchronized 키워드 사용 method level push() : (Vector) synchronized pop() : synchronized peek() : synchronized empty() : (Vector) synchronized search() : synchronized public class Stack&amp;lt;E&amp;gt; extends Vector&amp;lt;E&amp;gt; { ... public E push(E item) { addElement(item); // (Vector) synchronized return item; } // synchronized public synchronized E pop() { E obj; int len = size(); obj = peek(); removeElementAt(len - 1); return obj; } // synchronized public synchronized E peek() { int len = size(); if (len == 0) throw new EmptyStackException(); return elementAt(len - 1); } public boolean empty() { return size() == 0; // (Vector) synchronized } // synchronized public synchronized int search(Object o) { int i = lastIndexOf(o); // (Vector) synchronized if (i &amp;gt;= 0) { return size() - i; } return -1; } } </description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-Static-method-Overriding-Hiding/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-Static-method-Overriding-Hiding/</guid>
      <description>Static method Overriding # JVM은 메서드를 호출할 때, 객체 메서드(instance method)의 경우 (런타임 시에) 해당 메서드를 구현하고 있는 실제 객체를 찾아 호출한다.
하지만 스태틱 메서드(static method)에 대해서는 실제 객체를 찾는 작업을 하지 않는다. 따라서 Static method의 경우 컴파일 시점에 선언된 타입의 메서드를 호출한다.
즉 Static method 에 대해서는 오버라이딩이 적용되지 않는다. 또, 이때에는 Overriding이 아닌 Hiding 이라고 부른다고 한다.
예시 코드 # public class A{ public static void test() { System.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/LANGUAGES/JAVA/Java-String/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/LANGUAGES/JAVA/Java-String/</guid>
      <description> contains() # public boolean contains(CharSequence s) { return this.indexOf(s.toString()) &amp;gt;= 0; } public static int indexOf(byte[] value, int valueCount, byte[] str, int strCount, int fromIndex) { byte first = str[0]; int max = valueCount - strCount; for(int i = fromIndex; i &amp;lt;= max; ++i) { if (value[i] != first) { do { ++i; } while(i &amp;lt;= max &amp;amp;&amp;amp; value[i] != first); } if (i &amp;lt;= max) { int j = i + 1; int end = j + strCount - 1; for(int k = 1; j &amp;lt; end &amp;amp;&amp;amp; value[j] == str[k]; ++k) { ++j; } if (j == end) { return i; } } } return -1; } 시작 인덱스부터 for-loop 탐색 시작 첫 글자 같다면, 검사 시작 중간에 틀리면 다시 2번부터 시작 같다면 시작 인덱스 반환 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-Throwable-Error-Exception/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-Throwable-Error-Exception/</guid>
      <description>Throwable # &amp;quot; The Throwable class is the superclass of all errors and exceptions in the Java language. Only objects that are instances of this class (or one of its subclasses) are thrown by the Java Virtual Machine or can be thrown by the Java throw statement. Similarly, only this class or one of its subclasses can be the argument type in a catch clause. For the purposes of compile-time checking of exceptions, Throwable and any subclass of Throwable that is not also a subclass of either RuntimeException or Error are regarded as checked exceptions.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-Valve-Tomcat/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/LANGUAGES/JAVA/JAVA-Valve-Tomcat/</guid>
      <description>https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&amp;blogId=gallechess&amp;logNo=221047184041</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/LANGUAGES/KOTLIN/KOTLIN-Companion-object-&#43;-static/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/LANGUAGES/KOTLIN/KOTLIN-Companion-object-&#43;-static/</guid>
      <description>Java에서 &amp;lsquo;static&amp;rsquo;은 다양한 이유로 사용할 수 있다. &amp;lsquo;메모리 관리&amp;rsquo;를 위해 &amp;lsquo;공유&amp;rsquo;를 위해 (클래스 선언 정보와 함께 메모리 영역에 올라간다.) companion object # 코틀린에서는 static 키워드가 없다.
이를 대체하기 위해 companion object 를 많이 사용한다.
(다른 말로 표현하면) (companion) object 를 통해 조금 더 (OOP와 적절한 방식으로)구현할 수 있다.
예시 코드 # class MyClass { companion object { fun doSomething() { } } } public final class MyClass { // 결국에 object 로 만들어서 사용하는 것인데, 이는 OOP 의 방향성에 아주 적절하다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/LANGUAGES/KOTLIN/KOTLIN-Naming-Convetion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/LANGUAGES/KOTLIN/KOTLIN-Naming-Convetion/</guid>
      <description>Source code organization # Source file names # UpperCamelCase
Source file organization # Placing multiple declarations (classes, top-level functions or properties) in the same Kotlin source file is encouraged as long as these declarations are closely related to each other semantically, and the file size remains reasonable (not exceeding a few hundred lines). In particular, when defining extension functions for a class which are relevant for all clients of this class, put them in the same file with the class itself.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/LANGUAGES/KOTLIN/KOTLIN-Nullable-types-and-non-null-types/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/LANGUAGES/KOTLIN/KOTLIN-Nullable-types-and-non-null-types/</guid>
      <description>코틀린에서는 nullable, non-nullable 타입을 구분하여 사용한다. # non-nullable # var a: String = &amp;#34;abc&amp;#34; a = null // X : 불가능 (컴파일 오류 발생) 변수 a 에는 non-null 이 보장되기에 아래와 같은 문법 사용 가능하다.
println(a.length) // O nullable # var a: String? = &amp;#34;abc&amp;#34; a = null // O : 가능 변수 a 에는 non-null 이 보장되지 않기에 아래와 같은 문법 사용 불가능하다.
println(a.length) // X : 불가능 (컴파일 오류 발생) 아래(nullable) 예시의 경우, property 를 접근/사용하기 위한 3가지 방법이 있다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/LANGUAGES/KOTLIN/KOTLIN-Scope-Functions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/LANGUAGES/KOTLIN/KOTLIN-Scope-Functions/</guid>
      <description>(객체의 컨텍스트 내에서) 임시 scope 를 생성하여 코드 블록(일련의 코드들)을 실행하기 위한 기능
다음과 같이 5개의 범위 함수(scope function)가 존재한다. # 공식 문서 - scope-functions/function-selection
Function Object reference Return value Is extension function? (TIP) 선택 기준 let it Lambda result O 1. non-null 객체의 lambda 실행 시 2. local 범위의 변수로 표현식 사용 시 run this Lambda result O 1. 객체 configuration + result 계산(반환) run - Lambda result X called without the context object 1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/LANGUAGES/PHP/PHP-CodeIgniter-Library-%EB%A1%9C%EB%94%A9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/LANGUAGES/PHP/PHP-CodeIgniter-Library-%EB%A1%9C%EB%94%A9/</guid>
      <description>이번 글은 CodeIgniter 2.x 기준으로 작성된 글이며, 커스터마이징 되어 있는 부분이 있기에 일반적인 상황과 조금은 다를 수 있습니다.
개요 # (팀에서) PHP 프레임워크 CodeIgniter(2.x, 3.x)를 사용하고 있다.
CodeIgniter는 MVC 패턴으로, 대부분이 그렇듯 controller 는 client 의 요청을 받고, view 는 화면 노출을 위해 사용되며 model 은 DB I/O 역할을 수행한다.
여기에 추가로 Library 라는 개념(디렉터리 구조에 포함)이 있다. Library 는 말그대로 공통으로 사용될 기능들에 대한 클래스(library)를 만들어두고 사용하기 위해 존재한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/LANGUAGES/PHP/PHP-CodeIgniter-xss_clean/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/LANGUAGES/PHP/PHP-CodeIgniter-xss_clean/</guid>
      <description>CodeIgniter xss_clean() 메서드 살펴보기
개요 # 오픈소스에서 제공하는 xss_clean() 메서드를 사용하고 있는데, 오탐으로 인해 사용자가 입력한 데이터가 변경되어 문제가 발생했다.
문제가 발생한 문자열은 아래와 같다.
원본 데이터
... HgrSLy0VBO71Kjbr3Co7h76WU0QB1rVT61QGGT5/M/9pPf/muYF3eSdTkxDOZkXZT8vFUwbZiUyX BGVvMC1epaCn329BFB4G3B+gJPa5k2OjlfogcT0jYWA0sUe1O/7bmW6sEfMwoTqh/VbGQLc/Eawz mB8+Oxgvkhri175eT62jHhCKyseBKZU4JvyOLNzyMh4g3UU6TkuzKdLdc2Lmk4uEDT5qOs2Kkqnf KuJyrG3L5oNFuRw= -----END NEW CERTIFICATE REQUEST----- 변경된 데이터
... HgrSLy0VBO71Kjbr3Co7h76WU0QB1rVT61QGGT5/M/9pPf/muYF3eSdTkxDOZkXZT8vFUwbZiUyX BGVvMC1epaCn329BFB4G3B+gJPa5k2OjlfogcT0jYWA0sUe1O/7bmW6sEfMwoTqh/VbGQLc/Eawz mB8+Oxgvkhri175eT62jHhCKyseBKZU4JvyOLNzyMh4g3UU6TkuzKdLdc2Lmk4uEDT5qOs2Kkqnf KuJyrG3L5 NEW CERTIFICATE REQUEST----- xss_clean() 살펴보기 # xss_clean 메서드가 어떻게 구현되어 있는지 살펴보기 위해 상속하고 있는 클래스를 따라가본다.
A Class ---&amp;gt; MYRest_Controller ---&amp;gt; REST_Controller ---&amp;gt; CI_Controller
class A extends MYRest_Controller { .</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/LANGUAGES/PHP/PHP-Function-Return-Type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/LANGUAGES/PHP/PHP-Function-Return-Type/</guid>
      <description>PHP7부터 function 에 return type 을 명시할 수 있다.
function isTrue(): bool { return true; } &amp;lsquo;function 내부의 return 값&amp;rsquo; 과 &amp;lsquo;명시된 type&amp;rsquo; 이 다를 경우 # (암묵적으로) function 내부의 return 값의 타입을 변환한다.
function isTrue(): bool { return 1; } var_dump(isTrue()); // 출력: bool(true) declare(strict_types=1); 선언을 통해 위와 같은 암묵적인 변환을 막을 수도 있다. 즉, 엄격하게 타입을 체크할 수 있다.
위 선언을 해주면, IDE에서는 곧바로 빨간줄이 생긴다.
참고 # https://wiki.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/LANGUAGES/PHP/PHP-PHP-%EA%B8%B0%EB%B3%B8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/LANGUAGES/PHP/PHP-PHP-%EA%B8%B0%EB%B3%B8/</guid>
      <description>PHP 기본 # PHP(Hypertext Preprocessor)는 server-side html-embedded 스크립트 언어(&amp;ldquo;서버에서 실행되며 HTML 을 포함하는 스크립트 언어&amp;rdquo;)이다.
html 내용을 php 확장자로 저장하여도 아무런 지장이 없다. 1개의 프로세스를 생성한 후, 그 안에서 여러 개의 쓰레드를 생성하여 응답/처리하는 방식이다.
PHP 를 이해하기 위해서 알아야 할 가장 큰 것은, &amp;lsquo;PHP 는 1개가 아니다&amp;rsquo; 라는 것이다.
PHP 는 스크립트(Script)다. # PHP 로 웹 서비스를 할 때, 웹서버는 단순히 중개 역할을 해준다. 예를 들어, PHP 파일에 대한 요청이 오면 이 요청을 PHP Interpreter 에게 넘겨주고, 응답을 받아 브라우저에게 최종적으로 응답하는 것이다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/LINUX/LINUX-epoll/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/LINUX/LINUX-epoll/</guid>
      <description>http://blueheartscabin.blogspot.com/2013/08/c-epoll.html
select, poll, epoll # 관심 있는 fd (= 대상 fd)들을 등록해두고 이들 중 이벤트가 발생하는 것을 감지하기 위해 사용하는 함수다.
다만, 이벤트를 감지하는 동작 방식에 차이가 있다.
select : 어떤 fd에 발생한 이벤트인지 찾기 위해 등록된 fd 리스트를 선형 탐색한다.
epoll : 이벤트가 발생한 fd들을 반환해준다.
이해한 내용이 맞는 지 다른 글도 확인
epoll 프로그래밍 흐름 # 소켓 생성, 설정 socket(), bind(), setsockopt() epoll 에 등록 (epoll_ctl) listen() epoll_wait() epoll_wait 를 통해 이벤트 발생을 감지/accept : accpet() :thinking: accpet 로 부터 넘어온 fd와 통신 준비 fcntl() epoll 에 새로운 fd 등록 : epoll_ctl epoll_ctl # epoll이 관찰할 fd, 이벤트를 등록하기 위한 인터페이스라고 한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/LINUX/LINUX-rsync/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/LINUX/LINUX-rsync/</guid>
      <description>rsnyc # 서버 간 파일, 디렉토리 정보를 동기화한다.
서로 다른 컴퓨터에 있는 정보(파일, 디렉토리)를 동기화한다.
비교해서 수정된 부분만 업데이트한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/LINUX/LINUX-%EC%86%8C%EC%BC%93-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/LINUX/LINUX-%EC%86%8C%EC%BC%93-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/</guid>
      <description>http://biscuit.cafe24.com/moniwiki/wiki.php/socket%C7%C1%B7%CE%B1%D7%B7%A1%B9%D6%B1%E2%BA%BB
socket() bind() listen() read() / write() 1. socket() # socket() 함수는 통신을 위한 하나의 포인트(= endpoint)를 만든다. 통신을 위한 매개체(= fd)를 만든다.
&amp;quot; socket() 함수는, 통신을 위한 끝점 한개를 만든다 (무슨 소리냐! :@). 워낙 여러가지 통신에 사용할 수 있는 함수이지만, 이 글에서는 TCP/IP 통신을 위한 부분에 국한해서, 뭔가 통신을 하기위한 매개체(이것을 fd, file descriptor 라고 한다)를 한개 생성하는데 쓴다. &amp;ldquo;
#include &amp;lt;sys/types.h&amp;gt; #include &amp;lt;sys/socket.h&amp;gt; int socket(int domain, int type, int protocol); int fd; if ((fd = socket(PF_INET, SOCK_STREAM, 0)) &amp;lt; 0) { fprintf(stderr, &amp;#34;socket() error\n&amp;#34;); exit(-1); } &amp;rdquo; socket() 함수의 파라미터 domain과 type은 TCP/IP의 IP와 TCP를 의미한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/NETWORK/NETWORK-LDAP/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/NETWORK/NETWORK-LDAP/</guid>
      <description>우선 개념만 정리, 다시 학습 필요 !!
LDAP(Lightwieght Directory Access Protocol) # 디렉토리 서비스를 제공하기 위한 프로토콜
네트워크상에서 조직(Organization), 개인(Private), 파일(File), 디바이스(Device) 등을 &amp;lsquo;찾아볼 수 있게 해주는&amp;rsquo; 소프트웨어 프로토콜
LDAP 은 DAP 의 스펙을 최대한 유지 + 경량화 → 네트워크 부담을 줄이고 활용성을 높임
데이터 형식에 있어서, 대부분 단순한 문자열을 사용 → &amp;lsquo;구현 단순화&amp;rsquo;, &amp;lsquo;성능 향상&amp;rsquo;시켰다고 한다.
LDAP 등장하기 전, 디렉토리 서비스 표준이었던 X.500 DAP(Directory Access Protocol)이 존재했었다. 하지만 이 프로토콜은 무겁고, 제약이 많았다고 한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/NETWORK/NETWORK-Network_NAT/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/NETWORK/NETWORK-Network_NAT/</guid>
      <description>NAT(Network Address Translation)는 IP, PORT 정보를 변경하는 기술이다. 패킷(IP, Port)에 변화가 생기기에 패킷에 대한 체크섬도 재계산되어야 한다고 한다.
NAT 를 이용하면 내부의 여러 사설 IP가 외부로 나갈 때 하나의 공인 IP 주소를 통해 나갈 수 있다.
&amp;lsquo;NAT를 사용하여 얻을 수 있는 이점&amp;rsquo; == &amp;lsquo;사설 네트워크(사설 IP)를 사용하여 얻을 수 있는 이점&amp;rsquo;
1. IP 주소 절약
&amp;lsquo;사설 IP 사용&amp;rsquo;의 이점인 것 같다. NAT를 통해 사설 IP, 공인 IP 를 활용할 수 있는데, 사설 IP 를 활용할 수 있다는 것은 그만큼 IP 주소를 절약할 수 있다는 것이다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/NETWORK/NETWORK-Network_Tunneling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/NETWORK/NETWORK-Network_Tunneling/</guid>
      <description>&amp;lsquo;터널링&amp;rsquo;이란, 연결해야 할 두 지점간에 통로를 생성하는 것이다. 이 터널은 터널링을 지원하는 프로토콜을 사용하여 구현되며, 사설망과 같은 보안 기능을 제공하게 된다. 경유지(두 지점 사이의 홉)들을 통하지 않고 두 지점을 바로 연결시킨 것이다.
참고 # VPN이란? 정의/터널링/터널링 프로토콜 등 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/NETWORK/NETWORK-OSI-7-Layer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/NETWORK/NETWORK-OSI-7-Layer/</guid>
      <description>OSI 7 Layer 이해하기
OSI 7 Layer # (전송 시) 7계층 -&amp;gt; 1계층 순서로 헤더를 붙인다. (캡슐화)
(수신 시) 1계층 -&amp;gt; 7계층 순서로 헤더를 떼어낸다. (디캡슐화)
Application Layer (7 Layer)
응용프로그램과 관련된 계층이다. 사용자/애플리케이션이 네트워크에 접근할 수 있도록 한다. 사용자를 위한 인터페이스를 지원한다. (사용자가 직접적으로 접촉하는 유일한 계층이다.) HTTP, FTP, SMTP, DNS 등이 있다. 데이터 Format : Data + HTTP Header Presentation Layer (6 Layer)
데이터를 어떻게 표현할지 결정한다. (전송할, 전송된) 데이터의 인코딩, 디코딩, 암호화 등이 이뤄진다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/NETWORK/NETWORK-%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%84%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/NETWORK/NETWORK-%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%84%9C/</guid>
      <description>먼저 &amp;lsquo;L4/L7 로드밸런싱 쉽게 이해하기&amp;rsquo; 블로그의 글을 읽었다.
L4/L7 로드밸런싱에 대해서 놓치기 쉬운 것(오해하기 쉬운 것)은 다음과 같다고 한다.
상위 계층의 장비는 하위 계층의 기능을 포함한다. 다만 효율성 있게 사용하기 위해 사용하지 않을 뿐이다.
로드밸런서 # 로드밸런서의 종류는 L2(MAC addr), L3(IP), L4(Port), L7(Application) 로드밸런서가 있다고 한다. 이들 중 L4, L7 로드밸런서가 많이 사용된다고 한다. (* L4부터 Port 를 다룰 수 있는데, 이 말은 즉슨 한 대의 서버에 여러 포트로 여러 서비스를 운영할 수 있다는 것을 의미한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/NUXT/NUXT-Nuxt-%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/NUXT/NUXT-Nuxt-%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4/</guid>
      <description> Nuxt LifeCycle # Nuxt ServerInit (lifecycle hook 호출) Route Middleware validate() asyncData() Vue lifecycle </description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/NUXT/NUXT-Static-site-vs-SSR/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/NUXT/NUXT-Static-site-vs-SSR/</guid>
      <description>Static-Site vs SSR (in Nuxt) # Static-Site # 빌드 시에 완벽한 HMTL 페이지를 생성한다.
이 페이지들은 웹서버를 통해 전달된다.
페이지의 내용을 변경하기 위해서는 재빌드 되어야한다.
속도, 배포, 보안 측면에서 장점이 있다.
즉 빌드 시에 페이지를 완성시키고, 클라이언트의 요청이 들어오면 완성된 페이지를 전달하기만 하면 된다.
SSR # SSR 은 웹페이지를 브라우저에서 렌더링하지 않고 서버에서 렌더링하여 전달하는 것이다.
콘텐츠 변경(최신 유지) 등의 장점이 있다.
즉 클라이언트의 요청이 들어오면, 서버 측에서 렌더링을 진행하고 전달한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/NUXT/NUXT-Vue-%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/NUXT/NUXT-Vue-%EB%9D%BC%EC%9D%B4%ED%94%84%EC%82%AC%EC%9D%B4%ED%81%B4/</guid>
      <description>Vue Life-cycle # new Vue() Init (Event, Lifecycle) : 이벤트 &amp;amp; 라이프사이클 초기화 beforeCreate Init (injections &amp;amp; reactivity) : 반응성 주입 created &amp;hellip; (el, template 속성 확인 등) beforeMount mounted beforeUpdate updated beforeDestroy destroyed beforeCreate() # 가장 먼저 실행되는 훅이다.
Vue 인스턴스가 생성된 직후에 실행된다.
데이터(data), 이벤트(methods) 속성이 정의되어 있지 않다.
화면(template) 요소에 접근할 수 없다.
created() # 데이터(data)와 이벤트(methods)가 초기화되어, 접근할 수 있다.
화면(template) 요소에 접근할 수 없다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/OS/01.-OS-Introduction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/OS/01.-OS-Introduction/</guid>
      <description>OS Introduction # OS 란?
프로그램이 동작하는 것을 쉽게 해준다. 시스템을 효율적으로, 정확하게 운영한다. &amp;lsquo;자원관리자&amp;rsquo; 이다. 물리 자원 : CPU, Dram(Memory), Disk, keyboard(KBD), Network, &amp;hellip; 가상 자원 : Process, Thread, Virtual Memory, Page, File, Directory, Driver, Protocol, &amp;hellip; * OSTEP(OS Three Easy Picese) : Virtualization, Concurrency, Persistence
* OS 의 기본 목표 : Abstraction, Performance, Protection, Reliability, &amp;hellip;
컴퓨터 시스템의 계층
user1 user2 user3 ... userN -------------------------------------- | System Program &amp;amp; Application Program | | OS | -------------------------------------- -------------------------------------- | HW | -------------------------------------- 프로그램을 수행하면 아래와 같은 것들이 진행된다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/OS/02.-Processes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/OS/02.-Processes/</guid>
      <description>Processes # * Program : Disk 상의 file
* Process : Program 실행 상태
Process 를 운영하기 위해 필요한 것
CPU : registers (IR, PC, SP, &amp;hellip;) Memory : Address Space (stack, heap, data, text) I/O information : Opened files/devices Multiple Processes 운영 방식
Time sharing 기법 사용
context switch 발생 Program 실행 시 OS 의 역할
Load (적재) Disk -&amp;gt; Memory Eagerly vs Lazily Dynamic Allocation (동적 할당) stack heap initialize parameters (argc, argv) Initialization (초기화) file descriptors(0, 1, 2) I/O Jump to main (main 함수 실행) Process 의 Lify-Cycle (상태)</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/OS/03.-Scheduling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/OS/03.-Scheduling/</guid>
      <description>Scheduling # 스케줄링 이란, 시스템의 자원을 어떤 프로세스에게 할당할 것인지 선택하는 것이다.
누가(어떤 프로세스) 자원(CPU)을 사용할지 선택하는 것이다.
선점형 스케줄링, 비선점형 스케줄링이 있다.
* Workload : 일의 양
Scheduling Metric
완료 시간 (Turnaround time)
Turnaround time = Completion time - Arrival time Batching System 에 좋은 metric 이다. 응답 시간 (Response time)
Response time = First run time - Arrival time I/O 에 좋은 metric 이다. (사용자는 빠른 응답시간이 중요하다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/OS/04.-Memory-Management/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/OS/04.-Memory-Management/</guid>
      <description>Memory Management # Memory Virtualization Keywords
Virtual address (Private) Address space HW help Address Space 개념의 변천사
Early System -&amp;gt; Multiprogramming &amp;amp; Time sharing -&amp;gt; Virtual memory(Address space)
Ealry System
Single programming system
물리 메모리를 직접적으로 사용한다.
물리 메모리보다 큰 메모리가 필요하다면, Overlay 기법을 사용한다.
* Overlay : 현재 꼭 필요한 Part 만 메모리에 올리는 것 (Part 번갈아가면서 실행)
Multiprogramming &amp;amp; Time sharing
컴퓨터 HW 가 좋아지면서, 한번에 여러 개의 프로그램을 올릴 수 있게 되었다 (?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/OS/07.-Concurrency-Thread-and-Lock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/OS/07.-Concurrency-Thread-and-Lock/</guid>
      <description>Concurrency : Thread and Lock # * 병행성 : 동시에 처리되는 것 처럼 보이게 하는 것
* 병렬성 : 동시에 처리되는 것
Keywords of concurrency
Shared data Race condition Coarse-grained locking &amp;hellip; Fron now on &amp;hellip;
Multi-threaded Program : multiple control flows in a program Concurrency : shared data -&amp;gt; race condition What is a Thread ?
Computing resources for a program
Thread는 프로세스 내에서 실행되는 흐름의 단위를 말한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/OS/08.-Concurrency-Semaphore-and-Deadlock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/OS/08.-Concurrency-Semaphore-and-Deadlock/</guid>
      <description>Concurrency: Semaphore and Deadlock # Producer/Consumber problem (Bounded buffer problem) # 한번에 여러 producer, consumer 가 버퍼에 접근하는 것을 막아야한다.
Semaphore # For both a lock and a condition variable</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/OS/10.-File-System-Basic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/OS/10.-File-System-Basic/</guid>
      <description>File System Basic # Persistence
메모리(휘발성) 상의 문제는 컴퓨터를 reboot 하면 해결된다.
디스크(비휘발성) 상의 문제는 컴퓨터를 reboot 해도 해결되지 않는다.
Computer system&amp;rsquo;s 4 key abstractions
Process Virtual Memory Lock File What is a file?
(영구히 저장되는) Bytes 들의 선형 집합(배열)이다.
각각의 file 은 절대경로, 상대경로를 갖는다.
Inode (OS, Low-level 단의 이름) 을 갖는다.
Device, Pipe, Socket, some processes 는 file 로서 취급된다.
(OS 가 관리하는 모든 장치는 file 로서 접근 가능하다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/OS/99.-RAID/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/OS/99.-RAID/</guid>
      <description>Redundant Array Inexpensive(Independent) Disk # (초창기에는) &amp;ldquo;저렴한 디스크를 사용해서 구성한다는 느낌으로&amp;rdquo; &amp;lsquo;Inexepnsive&amp;rsquo; 키워드를 사용했다고 한다.
&amp;ldquo;독립적인 저장 공간 구성한다는 느낌으로(즉, 안정성, 가용성)&amp;rdquo;,&amp;lsquo;Independent&amp;rsquo; 키워드를 사용한다고 한다.
개요 # RAID 특징
고가용성 (안정성) 향상 디스크 I/O 성능 향상 디스크 확장성 향상 RAID 구성은 &amp;lsquo;HW 방식&amp;rsquo;과 &amp;lsquo;SW 방식&amp;rsquo;이 있다.
1. HW 방식 # HW 방식은 메인보드에 &amp;lsquo;RAID 컨트롤러 카드&amp;rsquo; 라는 것을 장착하여 구현한다고 한다.
운영체제 부팅 진입 전, RAID 구성을 확인한다고 한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/OS/99.-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/OS/99.-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81/</guid>
      <description>스케줄링 # 스케줄링이란, 시스템의 자원을 어떤 프로세스에게 할당할 것인지 선택하는 것이다.
선점형 스케줄링, 비선점형 스케줄링이 있다.
선점형 스케줄링 # 어떤 프로세스가 시스템의 자원을 사용하여 작업을 진행하는 도중, 해당 작업을 중지하고 시스템의 자원을 다른 프로세스에게 넘겨줄 수 있는 스케줄링이다.
Round Robin (RR)
FCFS 기법 + 선점형의 기법이다.
SRT (Shortest Remaining Time)
SJF + 선점형의 기법이다.
MLQ
Queue 에 자원을 점유할 프로세스들을 대기시킨다.
여러 개의 Queue 를 갖는다. Queue 마다 우선순위가 있다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/REDIS/REDIS-Data-Structures/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/REDIS/REDIS-Data-Structures/</guid>
      <description>Lists # Redis Lists are implemented with linked lists because for a database system it is crucial to be able to add elements to a very long list in a very fast way.
O(1) # LPUSH, RPUSH LPOP, RPOP LLEN O(n) # LINDEX, LRANGE LSET Use Case # Feed system can be a good use case.
Every time a user posts a new photo, we add its ID into a list with LPUSH.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/REDIS/REDIS-Redis-Pipelining/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/REDIS/REDIS-Redis-Pipelining/</guid>
      <description>Redis Pipelining # &amp;quot; How to optimize round-trip times by batching Redis commands &amp;ldquo;
여러 명령(command)을 한번에 요청/응답하는 것
DB 에서는 Bulk 연산자를 지원하지만, 레디스에서는 Bulk 연산자를 지원하지 않는다. 대신 pipelin api 를 지원한다.
(흔히 나오는 예시) (아래)HTTP pipelining 과 비슷한 개념이다.
문제1. RTT (Round-Trip Time) # Redis는 고성능의 저장소이지만, TCP 기반 위에서 동작한다.
즉 요청/응답을 위해 (TCP 기반의)네트워크 I/O가 발생할 것이다. Redis 의 성능이 아무리 좋아도, RTT가 길다면 클라이언트 입장에서 (시간 당)처리량이 줄어들 수 밖에 없다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/REDIS/REDIS-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/REDIS/REDIS-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/</guid>
      <description>&amp;quot; 여러 자료구조를 사용할 수 있는 Redis 의 특성상 트랜잭션을 잘 이용하면 더 유용하게, 다양한 상황에서 Redis 를 사용할 수 있을 것 입니다. &amp;ldquo; 출처 : https://sabarada.tistory.com/177
Redis 에서는 MULTI, EXEC, DISCARD 와 WATCH 명령어를 사용할 수 있다.
명령어 설명 MULTI 트랜잭션 시작 트랜잭션 시작 시, 이후 명령어(들)은 바로 실행되지 않고 queue 에 쌓임 EXEC queue 에 쌓인 명령어(들)을 일괄적으로 실행
* RDBMS 의 commit DISCARD queue 에 쌓인 명령어(들)을 버림</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/SPRING/SPRING-2.7.2-3.0.1-migration/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/SPRING/SPRING-2.7.2-3.0.1-migration/</guid>
      <description>전제 조건 # Java 17 이상 SpringBoot 2.7.x 참고 문서 # wiki: Spring Boot 3.0 Migration Guide TIP # 다음 라이브러리가 도움을 준다.
runtime(&amp;#34;org.springframework.boot:spring-boot-properties-migrator&amp;#34;) 의존성 설치 후 애플리케이션을 시작하면, 로그에 변경된 사항을 알려준다.
Core Changes # Jakarta EE (패키지명 변경 : javax -&amp;gt; jakarta) # history 잠깐 보면, 2017년 오라클에서 이클립스 재단으로 자바 EE를 이관했다. (&amp;ldquo;썬 마이크로시스템즈를 인수한 오라클이 사실상 자바EE의 수익화에 실패하면서 기술 주도권을 포기한 것으로 판단됩니다.&amp;rdquo;) (오픈소스) 이클립스 재단으로 이관된 자바 EE의 공식 명칭이 자카르타 EE 이다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/SPRING/SPRING-@SpringBootApplication/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/SPRING/SPRING-@SpringBootApplication/</guid>
      <description>@SpringBootApplication # /** * Indicates a configuration class that declares one or more @Bean methods * and also triggers auto-configuration and component scanning. * This is a convenience annotation that is equivalent to declaring @Configuration, @EnableAutoConfiguration and @ComponentScan. */ @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) }) public @interface SpringBootApplication { ... } 아래 기능을 하는 Configuration Class</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/SPRING/SPRING-@ToString-Enable-toString-Object-View/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/SPRING/SPRING-@ToString-Enable-toString-Object-View/</guid>
      <description>Intellij 디버깅 시,
Build, Execution, Deployment &amp;gt; Debugger &amp;gt; Data Views &amp;gt; Java &amp;gt; Enable toString() Object View 설정이 활성화되어 있다는 가정
Lazy 연관관계를 가진 Entity 조회 시, Lazy 객체의 초기화(Fetch) 시점이 예상과 다를 수 있다.
예시 # ... @ToString @Entity public class Poster { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = &amp;#34;user_id&amp;#34;) private User user; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = &amp;#34;poster_type_id&amp;#34;) private PosterType posterType; .</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/SPRING/SPRING-@Transactional/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/SPRING/SPRING-@Transactional/</guid>
      <description>PROPAGATION (전파) # 이름 설명 REQUIRED Default 설정 - 이미 시작된 트랜잭션이 없는 경우 : 트랜잭션 생성 - 이미 시작된 트랜잭션이 있는 경우 : 해당 트랜잭션에 참여 REQUIRES_NEW 항상 새로운(new), 독립된 트랜잭션 시작 - 이미 시작된 트랜잭션이 없는 경우 : 트랜잭션 생성 - 이미 시작된 트랜잭션이 있는 경우 : 새로운 트랜잭션 생성, 기존 트랜잭선은 보류(suspend) * 트랜잭션 보류(suspension)의 경우 모든 트랜잭션 매니저(Transaction manager)에서 기본적으로 동작하지 않음에 주의.
(TransactionManager to be made available to it) SUPPORTS - 이미 시작된 트랜잭션이 없는 경우 : 트랜잭션 없이 진행 - 이미 시작된 트랜잭션이 있는 경우 : 해당 트랜잭션에 참여 MANDATORY 기존에 생성된 트랜잭션이 있도록 강제한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/SPRING/SPRING-@Version/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/SPRING/SPRING-@Version/</guid>
      <description>@Version # &amp;lsquo;낙관적 락&amp;rsquo; 구현 시 사용될 수 있음
package javax.persistence; ... /** * Specifies the version field or property of an entity class that serves as its optimistic lock value. * * The version is used to ensure integrity when performing the merge operation and for optimistic concurrency control. * * Only a single Version property or field should be used per class; applications that use more than one Version property or field will not be portable.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/SPRING/SPRING-ApplicationEventPublisher/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/SPRING/SPRING-ApplicationEventPublisher/</guid>
      <description>동작 순서 : ApplicationEventPublisher.publishEvent() # 간단 요약 # AbstractApplicationContext.publishEvent() 호출 ApplicationEvent 타입 확인 &amp;amp; Wrapping (PayloadApplicationEvent) Multicast to listeners ApplicationEventMulticaster.multicastEvent() 호출 (Default) SimpleApplicationEventMulticaster Listener loop 돌며 invoke() public void myMethod() { ... applicationEventPublisher.publishEvent(myObject); } AbstractApplicationContext # public abstract class AbstractApplicationContext extends DefaultResourceLoader implements ConfigurableApplicationContext { ... /** * Publish the given event to all listeners. * Note: Listeners get initialized after the MessageSource, * to be able to access it within listener implementations.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/SPRING/SPRING-DispatcherServlet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/SPRING/SPRING-DispatcherServlet/</guid>
      <description>Dispatcher Servlet # (웹 상에서) 클라이언트로부터 어떠한 요청이 들어오면 (Tomcat 과 같은) Servlet Container 가 요청을 받는다. 이때 제일 앞에서 서버로 들어오는 모든 요청을 처리하는(수신하는) &amp;lsquo;Front-Controller&amp;rsquo; 를 Dispatcher-Servlet 이라고 한다.
MVC 아키텍쳐는 보통 이 Front-Controller 패턴과 함께 사용된다고 한다.
공통적인 작업은 Dispatcher-Servlet 이 처리하고 세부적인 작업에 대해서는 적절한 Controller 에 작업을 위임한다.
잠시 Servlet 개념으로 돌아가보면, 기존에는 모든 Servlet 에 대해 web.xml 에서 URL 매핑을 등록해주어야 했다. 그런데 Dispatcher-Servlet 이 등장하면서 해당 애플리케이션으로 들어오는 모든 요청을 핸들링 해주었다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/SPRING/SPRING-Embeded-TomcatTCP-ThreadRequest-Connection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/SPRING/SPRING-Embeded-TomcatTCP-ThreadRequest-Connection/</guid>
      <description>TCP 연결을 맺고 동시에 여러 요청(API 호출)을 했을 때 :arrow_right: 서로 다른 Thread 로 처리 # 내장 톰캣 설정 확인 # org.springframework.boot.autoconfigure.web.ServerProperties
package org.springframework.boot.autoconfigure.web; @ConfigurationProperties(prefix = &amp;#34;server&amp;#34;, ignoreUnknownFields = true) public class ServerProperties { ... /** * Tomcat properties. */ public static class Tomcat { /** * Maximum number of connections that the server accepts and processes at any * given time. Once the limit has been reached, the operating system may still * accept connections based on the &amp;#34;acceptCount&amp;#34; property.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/SPRING/SPRING-Filter-vs-Interceptor-vs-AOP/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/SPRING/SPRING-Filter-vs-Interceptor-vs-AOP/</guid>
      <description>Filter # 요청 / 응답을 필터링한다.
DispatcherServlet 이전에 실행 된다. 즉, 스프링 영역 외부에 존재하여, 스프링과 무관한 자원에 대해 동작한다.
init() : ServletContainer 에 Filter 가 등록되어 초기화될 때 실행 doFilter() : Filter가 적용된 servlet에 요청이 들어왔을 때 실행 (servlet에 전달하기 전에) destroy() : ServletContainer 가 종료될 때(Filter 가 삭제될 때)실행 일반적으로 Encoding 처리, XSS 방어 등을 처리하기 위해 사용될 수 있다.
Interceptor # 요청/응답에 대해 전(pre)/후(post)로 가로챈다.
DispatcherServlet 이 Controller 를 호출하기 전/후로 가로챈다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/SPRING/SPRING-IoC-%EC%99%80-DI/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/SPRING/SPRING-IoC-%EC%99%80-DI/</guid>
      <description>IoC (Inversion of Control) # 제어(관리)의 역전 프로그램에 대해서 개발자가 관리하는 것이 아닌, 제 3의 존재가 관리한다. IoC의 이점
역할 / 책임을 분리한다. (의존성 주입 등 관리의 일부를 제 3의 존재가 한다. 즉 역할이 분리되는 것이다.) 유연하게 코드를 작성할 수 있다. (개발 코드에 집중할 수 있다. 편리하다.) 개발자가 관리한다는 것은 권한도 강해짐을 의미한다. 이를 제어할 수 있다. DI (Dependencies Injection) # IoC 이라는 큰 범주의 개념 중 구체적인 한 특징 (?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/SPRING/SPRING-Logging/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/SPRING/SPRING-Logging/</guid>
      <description>&amp;lsquo;Log&amp;rsquo; 는 소프트웨어의 행위(이벤트)를 기록하여, 문제가 발생했을 때 문제를 빠르게 파악할 수 있게 합니다. 또는 소프트웨어 자체를 모니터링할 수 있게 합니다.
Java 에서 log 관련 프레임워크는 아래와 같은 것들이 있습니다.
Slf4j Log4j Logback Log4j2 Slf4j (Simple Logging Facade For Java) # logger 인터페이스, 추상체 역할을 합니다. 즉, 다른 logging 프레임워크 구현체들의 인터페이스, 추상체 역할을 합니다.
예를 들어, Logback, Log4j2 의 Logger 클래스는 Slf4j Logger 인터페이스를 구현합니다.
package ch.qos.logback.classic; public final class Logger implements org.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/SPRING/SPRING-Lombok-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/SPRING/SPRING-Lombok-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC/</guid>
      <description>컴파일 시점에 Annotation Processor 를 통해 소스코드의 AST(Abstract Syntax Tree)를 동적으로 조작/수정한다.
컴파일 시점에 바이트 코드를 변환하여 추가적인 코드를 주입/생성한다.
AnnotationProcessor # 컴파일 단계에서 정의/사용된 annotation 코드를 스캔/분석/처리하기 위해 사용되는 훅이다.
컴파일 시점에 끼어들어 annotation 이 붙어있는 코드를 스캔/분석/처리하여 추가적인 소스 코드를 만들어낼 수 있다.
참고 # Lombok의 동작원리 Lombok은 어떻게 동작하는 걸까? </description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/SPRING/SPRING-OSIV/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/SPRING/SPRING-OSIV/</guid>
      <description>Spring Framework 의 OSIV 에 대해 이해해보기
스프링에서 기본적으로 영속(준영속)상태, 트랜잭션의 범위는 아래와 같다고 한다.
그림에서와 같이 Intercepter, Controller, View 단에서는 준영속 상태이기 때문에 영속 상태의 이점을 누리지 못한다. 영속 상태의 이점이란, 변경 감지, 지연 로딩 등의 기능이다. 즉, 쉽게 보면 Controller 에서는 변경 감지나 지연 로딩의 기능을 사용할 수 없는 것이다.
public class OrderController { ... public String index(Long id) { Order order = orderService.getOrder(id); order.getShop(); // 지연로딩이라면 사용할 수 없다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/SPRING/SPRING-Reactive-Kafka/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/SPRING/SPRING-Reactive-Kafka/</guid>
      <description>Overview # 두 가지 핵심 인터페이스(패키지)
카프카에 메시지 발행
reactor.kafka.sender.*
reactor.kafka.sender.KafkaSender 카프카의 메시지 컨슘
reactor.kafka.receiver.*
reactor.kafka.receiver.KafkaReceiver KafkaSender # KafkaSender 는 thread-safe 하다. 여러 스레드와 공유하여 처리할 수 있다.
카프카로 메시지를 전송할 때 사용하는 KafkaProducer 하나와 연결된다.
KafkaSender 는 sender 설정 옵션(reactor.kafka.sender.SenderOptions) 인스턴스로 만든다.
KafkaSender 를 만든 후엔, SenderOptions 를 수정해도 KafkaSender 에 반영되지 않는다. 동시에 전송할 수 있는 최대 메시지 수(max inflight)와 같은 KafkaSender 전용 설정 옵션도 KafkaSender 인스턴스를 만들기 전에 미리 설정할 수 있다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/SPRING/SPRING-RedisKeyValueAdapter-update/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/SPRING/SPRING-RedisKeyValueAdapter-update/</guid>
      <description>update # element 가 컬렉션인 경우 # (컬렉션 요소들) 전체 삭제 후 다시 insert
// 1 127.0.0.1:6379&amp;gt; hgetall test 1) &amp;#34;_class&amp;#34; 2) &amp;#34;~~~&amp;#34; 3) &amp;#34;ids.[0]&amp;#34; 4) &amp;#34;1&amp;#34; 3) &amp;#34;ids.[1]&amp;#34; 4) &amp;#34;2&amp;#34; // 2 127.0.0.1:6379&amp;gt; hgetall test 1) &amp;#34;_class&amp;#34; 2) &amp;#34;~~~&amp;#34; // 3 127.0.0.1:6379&amp;gt; hgetall test 1) &amp;#34;_class&amp;#34; 2) &amp;#34;~~~&amp;#34; 3) &amp;#34;ids.[0]&amp;#34; 4) &amp;#34;3&amp;#34; 그 외 # hmset, hset 커맨드로 overwrite
참고 # public void update(PartialUpdate&amp;lt;?&amp;gt; update) { RedisPersistentEntity&amp;lt;?&amp;gt; entity = this.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/SPRING/SPRING-Servlet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/SPRING/SPRING-Servlet/</guid>
      <description>Servlet # 클라이언트의 요청을 처리하고, 결과를 반환하는 (Servlet 클래스의 구현 규칙을 지킨) Java 프로그램(클래스)이다.
서블릿은 자바로 구현된 CGI라고 불린다.
* 실제 주석 내용
서블릿은 웹 서버 내에서 실행되는 작은 Java 프로그램이다. 일반적으로 서블릿은 HTTP 를 통해 웹 클라이언트의 요청을 받고, 응답한다.
* CGI(Common GateWay Interface)란?
외부 프로그램과 웹서버 사이에서 정보를 주고받는 방법/규약을 말한다.
Servlet (Interface) # 이 인터페이스는 서블릿을 초기화하고 요청을 서비스하고, 서블릿을 서버로부터 삭제하는 메소드를 정의하고 있다. 즉, 생명 주기 메소드들을 정의한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/SPRING/SPRING-ServletContext-ApplicationContext/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/SPRING/SPRING-ServletContext-ApplicationContext/</guid>
      <description>ServletContextListener # ServletContext 의 변화(라이프사이클)를 감지한다.
웹 애플리케이션의 &amp;lsquo;시작&amp;rsquo;, &amp;lsquo;종료&amp;rsquo; 시에 아래 메서드가 호출된다. contextInitialized() : 웹 애플리케이션이 시작될 때 호출 servlet, filter 의 초기화보다 먼저 실행 contextDestroyed() : 웹 애플리케이션이 종료될 때 호출 servlet, filter 는 해당 메서드 호출 전에 이미 종료된 상태 /** * Implementations of this interface receive notifications about changes to the * servlet context of the web application they are part of. To receive * notification events, the implementation class must be configured in the * deployment descriptor for the web application.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/SPRING/SPRING-Session-1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/SPRING/SPRING-Session-1/</guid>
      <description>서블릿 컨테이너(e.g. 톰캣) 자체적으로 세션 관리
Session # 주요 인터페이스/클래스
HttpSession StandardSession /** * Provides a way to identify a user across more than one page request or visit to a Web site and to store information about that user. * The session persists for a specified time period, across more than one connection or page request from the user. * A session usually corresponds to one user, who may visit a site many times.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/SPRING/SPRING-Spring-Batch-1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/SPRING/SPRING-Spring-Batch-1/</guid>
      <description>개요 # &amp;quot; A Job has one to many steps, each of which has exactly one ItemReader, one ItemProcessor, and one ItemWriter &amp;ldquo;
하나의 Job 은 여러 Step 을 갖는다.
하나의 Step 은 각각 1개의 ItemReader, ItemProcessor, ItemWriter 를 갖는다.
Job # &amp;rdquo; A Job is an entity that encapsulates an entire batch process. &amp;ldquo;
하나의 잡은 Batch Process 를 표현하는 수단으로 볼 수 있음
Job은 작업이 무엇이고, 어떻게 하는지 에 대해 정의</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/SPRING/SPRING-Spring-Batch-2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/SPRING/SPRING-Spring-Batch-2/</guid>
      <description>애플리케이션 실행 순서 # SpringApplication ---&amp;gt; JobLauncherApplicationRunner (ApplicationRunner) ---&amp;gt; JobLauncherApplicationRunner # SpringApplication 에 의해 run() 메서드가 호출되고, execute() 메서드를 실행한다.
protected void execute(Job job, JobParameters jobParameters) throws JobExecutionAlreadyRunningException, JobRestartException, JobInstanceAlreadyCompleteException, JobParametersInvalidException, JobParametersNotFoundException { JobParameters parameters = getNextJobParameters(job, jobParameters); // (1) JobExecution execution = this.jobLauncher.run(job, parameters); // (2) if (this.publisher != null) { this.publisher.publishEvent(new JobExecutionEvent(execution)); // (3) } } (1) jobParameter 를 가져온다. (2) jobLauncher.run() 을 통해 job 을 실행한다. jobLauncher.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/SPRING/SPRING-Spring-Cloud-Gateway-1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/SPRING/SPRING-Spring-Cloud-Gateway-1/</guid>
      <description>Spring Cloud Gateway (SCG) # 용어 # Route
SCG의 &amp;lsquo;기본 설정 그룹&amp;rsquo; 정도로 볼 수 있을 것 같음 ID, Dest URI, 일련의 Preciates, 일련의 Filters 등이 정의
예를 들어, 하나의 route는 predicate 가 true 일 때 매치
Predicate
Java8 의 Predicate Input-Type : ServerWebExchange HTTP request(header, parameter 등)로부터 해당 route를 매치시킬 것인지 아닌지 등을 판단하기 위해 사용된다. Filter
(SpringFramework GatewayFilter) (before or after sending the downstream request)request, response 를 조작할 수 있음 동작 원리 # 어떻게 동작하는지에 대한 그림은 여기를 참고하자.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/SPRING/SPRING-Spring-Cloud-Gateway-2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/SPRING/SPRING-Spring-Cloud-Gateway-2/</guid>
      <description>[웨비나] API Gateway를 활용한 API 개발과 비즈니스 로직 실행 # Gateway 고려사항 # 수많은 API 요청을 처리할 수 있는 안정적인 인프라 Scale Out 가능 여부 트래픽 제어 (Rate Limit, &amp;hellip;) Gateway 를 위한 트래픽 제어 Internel Service 를 위한 트래픽 제어 모니터링 사용 현황 (호출량) 응답 시간 오류 현황 다양한 성능 정보 인증 (+ 인가) API Key 를 이용한 제어 IP ACL 를 이용한 제어 유연한 API 관리 리소스, 메서드 관리 Client ---&amp;gt; Mock API ---&amp;gt; G/W ---&amp;gt; Internel 네이버 Gateway 의 경우 아래 Endpoint 에 대한 호출이 가능하다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/SPRING/SPRING-Spring-Cloud-Gateway-3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/SPRING/SPRING-Spring-Cloud-Gateway-3/</guid>
      <description>spring-cloud-starter-gateway # Dependency # spring-cloud-starter spring-boot-starter-webflux netty &amp;hellip; spring-cloud-starter-loadbalancer (optional) spring-cloud-gateway-server 실질적으로 이 모듈에 Gateway와 관련된 클래스(코드)가 있다고 보면 될 것 같다. spring-cloud-gateway-server # Dependency # 기본적인 Dependency 가 모두 들어있다. (다만, optional 활성 여부를 꼭 확인할 것)
spring-boot-starter spring-boot-starter-validation io.projectreactor.addons:reactor-extra spring-boot-starter-oauth2-client (optional) spring-boot-starter-actuator (optional) &amp;hellip; Flow # https://dlsrb6342.github.io/2019/05/14/spring-cloud-gateway-%EA%B5%AC%EC%A1%B0/ 여기의 글도 보기 좋다.
HttpServerOperations (reactor-netty-http) ---&amp;gt; HttpWebHandlerAdapter(spring-web) ---&amp;gt; (WebHandler.handle(), DispatcherHandler.handle()) RoutePredicateHandlerMapping(spring-cloud-gateway-server) ---&amp;gt; FilteringWebHandler.handle() DispatcherHandler # public class DispatcherHandler implements WebHandler, PreFlightRequestHandler, ApplicationContextAware { @Nullable private List&amp;lt;HandlerMapping&amp;gt; handlerMappings; @Nullable private List&amp;lt;HandlerAdapter&amp;gt; handlerAdapters; @Nullable private List&amp;lt;HandlerResultHandler&amp;gt; resultHandlers; .</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/SPRING/SPRING-Spring-Cloud-Gateway-4-Error-Handling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/SPRING/SPRING-Spring-Cloud-Gateway-4-Error-Handling/</guid>
      <description>Gateway 에서 에러 발생 시, 핸들링할 수 있는 WebExceptionHandler를 구현합니다.
구현 내용 # ErrorWebExceptionHandler 인터페이스 구현 → GlobalErrorWebExceptionHandler ErrorAttributes 인터페이스 구현 → GlobalErrorAttributes 흐름 # ExceptionHandlingWebHandler 가 FilteringWebHandler 에 Request 처리를 위임하는 방식 (참고 : WebHttpHandlerBuilder.build()) 연관 클래스 # 클래스 설명 / 역할 ExceptionHandlingWebHandler WebExceptionHandler List 포함 exceptionHandler 에러를 핸들링한다. WebExceptionHandler Contract for handling exceptions during web server exchange processing. GlobalErrorWebExceptionHandler 이 해당 WebHandler 에서 Exception 발생 시, WebExceptionHandler(GlobalErrorWebExceptionHandler) 가 처리 ErrorAttributes Provides access to error attributes which can be logged or presented to the user.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/SPRING/SPRING-Spring-Cloud-Gateway-5-RouteLocator/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/SPRING/SPRING-Spring-Cloud-Gateway-5-RouteLocator/</guid>
      <description> </description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/SPRING/SPRING-Spring-MVC-Error/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/SPRING/SPRING-Spring-MVC-Error/</guid>
      <description>Spring MVC : Error # 핵심 클래스 / 인터페이스 # class (interface) 설명 ErrorMvcAutoConfiguration (MVC) Error Controller 관련 Auto-configuration 클래스 ErrorController Error Controller 인터페이스 하위 : AbstractErrorController, BasicErrorController BasicErrorController Error Controller 구현 클래스 Spring Web(MVC)에서 Default 로 사용되는 구현체 (with DefaultErrorViewResolver) ErrorProperties (위에서 사용되는) Error property 클래스 Path, WhiteLabel, &amp;hellip; ErrorMvcAutoConfiguration # // Load before the main WebMvcAutoConfiguration so that the error View is available @AutoConfiguration(before = WebMvcAutoConfiguration.class) @ConditionalOnWebApplication(type = Type.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/SPRING/SPRING-Spring-Security-1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/SPRING/SPRING-Spring-Security-1/</guid>
      <description>Overview # A Review Of Filters # DelegatingFilterProxy # package org.springframework.web.filter;
서블릿 컨테이너(Servet Conatiner) &amp;lt;-&amp;gt; 스프링 애플리케이션컨텍스트(ApplicationContext) 사이를 연결시켜주는(bridge) 역할을 한다.
WebApplicationContext 에서 위임할 Filter(Bean)을 찾고, 해당 Filter 의 doFilter() 메서드를 호출한다. &amp;lsquo;서블릿 컨테이너&amp;rsquo; 는 &amp;lsquo;스프링에 등록된 Bean&amp;rsquo; 들을 사용(인식)하지 않는다. 따라서, (서블릿 컨테이너 표준에 맞게 등록된) DelegatingFilterProxy가 스프링에 등록된 Bean(단, Fiter 구현체)에 위임한다. &amp;ldquo;(Servlet)Filter vs Bean Filter&amp;rdquo; 의 차이에 대해 이해할 것
public class DelegatingFilterProxy extends GenericFilterBean { .</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/SPRING/SPRING-Spring-Security-2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/SPRING/SPRING-Spring-Security-2/</guid>
      <description>Servlet Authentication Architecture # 클래스 설명 SecurityContextHolder Where Spring Security stores the details of who is authenticated SecurityContext It is contained in SecurityContextHolder
It contains the Authentication of the currently authenticated user AuthenticationManager &amp;lsquo;인증&amp;rsquo;을 처리하기 위한 인터페이스
Authentication authenticate(Authentication authentication) throws AuthenticationException; ProviderManager AuthenticationManager 구현 클래스 AuthenticationProvider (실질적인) &amp;lsquo;인증&amp;rsquo; 을 처리하는 인터페이스
e.g. AbstractUserDetailsAuthenticationProvider : ID, Password 인증
(ID, Password 인증은 추상메서드로 되어 있기에, 사용자가 구현) GrantedAuthority (인증 시) 부여된 권한 AbstractAuthenticationProcessingFilter A base Filter used for authentication</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/SPRING/SPRING-SpringBoot-JPA-Spring-Data-Jpa-Hibernate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/SPRING/SPRING-SpringBoot-JPA-Spring-Data-Jpa-Hibernate/</guid>
      <description>jpa vs hibernate vs spring data jpa 글을 읽고 이해한 내용 정리해보기
JPA (Java Persisetence API) # JPA 는 인터페이스(명세)이다. 간단하게 &amp;ldquo;관계형 데이터베이스 사용을 위한 인터페이스&amp;rdquo; 이다.
EntityManager 가 바로 JPA 인터페이스의 실물(구현체)이다.
EntityManager 를 살펴보면 관계형 데이터베이스 사용을 위한 기능들이 정의되어 있음을 알 수 있다.
public interface EntityManager { /** * Make an instance managed and persistent. * ... */ public void persist(Object entity); /** * Merge the state of the given entity into the * current persistence context.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/SPRING/SPRING-SpringBoot-Multiple-DB-%EC%97%B0%EB%8F%99/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/SPRING/SPRING-SpringBoot-Multiple-DB-%EC%97%B0%EB%8F%99/</guid>
      <description>SpringBoot 에서 여러 개의 DB 연동해보기
개요 # 회사에서 새로운 프로젝트를 SpringBoot 환경으로 진행하게 되었다. 기존의 대부분의 프로젝트는 PHP 진영의 CodeIgniter(이하 CI) 라는 프레임워크가 사용되어왔다. SpringBoot로 컨버팅하는 작업도 일부 포함되어 있었기에, 이것저것 알아봐야하는 것들이 많았다.
그 중에 가장 처음 직면한 문제는 DB 연동 문제였다. 우리 팀은 기본적으로 Oracle DB를 베이스로 하는데, 몇몇 프로젝트에서는 Mysql 을 사용한 프로젝트도 있었다. 문제는 이번에 작업해야 할 프로젝트가 Oracle, Mysql DB를 둘 다 연동/사용해야 했다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/SPRING/SPRING-SpringBoot-N&#43;1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/SPRING/SPRING-SpringBoot-N&#43;1/</guid>
      <description>N+1 문제 # (쿼리를 통해 데이터를 가져올때) (연관관계에 있는)데이터를 얻기 위해 추가적인 쿼리가 발생하는 문제
예시 : 단건 조회 # @Getter @Builder @AllArgsConstructor @NoArgsConstructor(access = AccessLevel.PROTECTED) @Entity public class Orders { @GeneratedValue(strategy = GenerationType.IDENTITY) @Id private Long id; @Column private String name; @ManyToOne(fetch = FetchType.EAGER) @JoinColumn(name = &amp;#34;customer_id&amp;#34;) private Customer customer; @OneToMany(fetch = FetchType.EAGER, mappedBy = &amp;#34;orders&amp;#34;) private List&amp;lt;OrderItem&amp;gt; orderItems; } EAGER 방식
left join , inner join 으로 한번에 가져온다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/SPRING/SPRING-Webflux/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/SPRING/SPRING-Webflux/</guid>
      <description> 아래 글을 참고한다.
https://godekdls.github.io/Reactive%20Spring/springwebflux/ https://godekdls.github.io/Reactive%20Spring/springwebflux2/ https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html </description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/SPRING/SPRING-WebServer-vs-WAS-vs-Servlet-Container/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/SPRING/SPRING-WebServer-vs-WAS-vs-Servlet-Container/</guid>
      <description>WebServer vs WAS(Web Application Server) vs Servlet Container # WebServer (웹 서버) # 정적인 페이지(HTML, CSS)를 제공하는 서버이다.
클라이언트의 요청 중 자체적으로 처리할 수 없는 요청은 WAS로 넘긴다.
웹서버와 WAS, 즉 역할을 분리함으로써 요청에 대한 부담을 나눌 수 있다.
Apache, Nginx, IIS 등이 있다.
WAS # 서버 사이드 언어(코드)를 통해 동적인 콘텐츠를 만드는 서버이다.
웹 서버에서 처리할 수 없는 동적인 콘텐츠를 생성하고, 이것을 웹서버에 제공한다.
보통 웹서버의 기능을 포함하고 있어서 웹 서버 없이도 웹 서비스를 운영할 수 있다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/WEB/WEB-Apache-vs-Nginx/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/WEB/WEB-Apache-vs-Nginx/</guid>
      <description>Apache # Apache 는 MPM(Multi Process Module) 방식으로 동작한다.
MPM 은 다시 아래와 같은 방식이 있다.
Prefork MPM Worker MPM Event MPM Prefork MPM # 각각의 요청을 각각의 프로세스(1 therad) 가 처리한다.
프로세스 별로 처리하기 때문에 안정적이다. (= 메모리 영역을 공유하지 않는다, 메모리 공간이 독립적이다)
자원의 사용량이 크다.
default 개수만큼 apache 자식 프로세스를 생성해놓는다. 프로세스는 client 요청을 처리하고, 요청이 많을 경우 Process를 새로 생성하여 처리한다.
Worker MPM # Prefork와 같이 Default로 Apache 자식 프로세스를 생성해놓는다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/WEB/WEB-CSRF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/WEB/WEB-CSRF/</guid>
      <description>CSRF # Cross Site Request Forgery
웹 애플리케이션 취약점 중 하나이다.
자신의 의지와는 무관하게 공격자가 의도한 행위(수정, 삭제, 등록 등)를 특정 웹사이트에 요청하게 하는 공격이다.
피해자(희생자)의 권한을 도용하여 공격자가 웹사이트에 특정 요청을 하는 것이다.
대상이 될 서비스(웹 애플리케이션)에 피해자가 로그인 한 상태이다. 이때, 정상적인 쿠키 등을 발급받는다. 피해자가 공격자의 피싱 사이트에 접속 방어 기법 # 일반적으로 CSRF 방어 기법은 조회성 메소드(GET) 에는 적용하지 않고, POST, PUT, PATCH, DELETE 메소드에 중점적으로 적용한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/WEB/WEB-DOM/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/WEB/WEB-DOM/</guid>
      <description>DOM 이란?
DOM(Document Object Model, 문서 객체 모델) 이란? # XML이나 HTML과 같은 문서에 접근(조작)하기 위한 인터페이스 문서 내의 모든 요소(예를 들어, 태그)를 정의하고 (그 요소들에)접근하는 방법을 제공 W3C의 표준 객체 모델 (위의 말을 조금 쉽게 풀어쓰면) 우리는 DOM 덕분에 아래와 같은 작업을 할 수 있다.
(JS) 새로운 HTML 요소 추가/수정/삭제 (JS) 새로운 HTML Event 추가 (JS) CSS 변경 등 DOM은 아래와 같이 노드 트리 형태로 나타난다고 한다.
출처: 위키백과: 문서 객체 모델</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/WEB/WEB-HTTP-Header/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/WEB/WEB-HTTP-Header/</guid>
      <description>커스텀 등록 헤더는 &amp;lsquo;X-&amp;rsquo; 라고 붙이곤 했었는데 RFC 6648(2012.06)에 의해 폐기
분류 (by Context) # General Header
request/response 공통(모두) 적용 body에 전송되는 데이터와는 관련이 없음 (예를 들면, Content-Type 등을 의미하는 건가?) Request Header
클라이언트 정보 Response Header
서버 정보 (이름, 버전 등) Entity Header
Entity Body 정보 (Content-Length, MIME 타입 등) 프록시 처리 방법에 따라 분류할 수도 있다.
End-to-end headers, Hop-by-hop headers
General Header # request / response 모두에서 사용되는 공통 헤더</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/WEB/WEB-OAuth-2.0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/WEB/WEB-OAuth-2.0/</guid>
      <description>Grant Type # 방식 사용자 인증 과정 개입 설명 authorization_code O * 인증 과정에서 Authorization Code 교환 후 access token 을 받고, 사용한다. implicit O * 인증 과정에서 Authorization Code 의 교환 없이, 즉시 access token 을 받고, 사용한다. client_credentials X * 인증 과정에서 client credential 정보(ex : client id, client secret)를 통해 access token 을 받고, 사용한다. password (Resource Owner Password Credentials, Password Credentials) X * 인증 과정에서 client credential 정보(ex : client id, client secret, id, password)를 통해 access token 을 받고, 사용한다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/WEB/WEB-Restful-API/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/WEB/WEB-Restful-API/</guid>
      <description>REST(Representational State Transfer) # 정의 1. (자원을 정의한 후) 자원(혹은 자원의 이름, 표현)으로 구분하여 자원의 상태(정보)를 주고 받는 모든 것
정의 2. Resource(자원, URI), Method(행위), Representation of Resource(자원의 형태/표현)를 사용하는 것
REST 구성 요소 # 자원(Resource, URI)
자원의 고유한 식별 값 (&amp;lsquo;모든 자원에는 고유한 ID가 존재한다&amp;rsquo;라는 전제) 행위(Method)
(자원에 대해서) 하고자 하는 행위 e.g. (HTTP 프로토콜에서) GET, POST, PUT, DELETE 등 자원의 형태/표현(Representation of Resource)
Client, Server가 주고 받는 자원의 형태/표현 e.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/WEB/WEB-SSL-Handshake/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/WEB/WEB-SSL-Handshake/</guid>
      <description>SSL Handshake 동작 원리 / 과정 # SSL Handshake의 목표
신뢰할 수 있는 서버(연결)인지 확인합니다. 통신 시 사용할 암호화 알고리즘을 결정합니다. 자세한 설명/그림은 여기를 참고합니다.
1. [Client 측] Client Hello
Client -&amp;gt; Server 로 연결을 시도합니다. 이때, 아래의 내용을 포함합니다.
사용할 수 있는 암호화 알고리즘 (즉, 어떤 암호화 알고리즘을 사용할 수 있는지) SSL Protocol version 등등 2. [Server 측] Server Hello / Certificate
Server -&amp;gt; Client 로 응답합니다. 이때, 아래의 내용을 포함합니다.</description>
    </item>
    
    <item>
      <title>@ComponentScan</title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/@ComponentScan/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/@ComponentScan/</guid>
      <description>@Component 어노테이션이 달린 클래스들을 모두 찾아, 빈으로 등록 # @Component @Controlloer (@Component 갖고 있음) : Spring MVC 컨트롤러로 인식 @Service (@Component 갖고 있음) : 특별한 기능 X 비즈니스 로직 인식 용도 @Repository (@Component 갖고 있음) : 데이터(DB) 계층의 에러를 스프링의 (통일된)예외로 변환 여러 DB마다 에러가 다를 수 있다 -&amp;gt; 통일화 @Configuration (@Component 갖고 있음) : 스프링 설정 정보로 인식 * 어노테이션의 어노테이션을 인식 =&amp;gt; Java의 기능 X, Spring 의 기능 O</description>
    </item>
    
    <item>
      <title>@Configuration과 바이트코드 조작의 마법</title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/@Configuration%EA%B3%BC-%EB%B0%94%EC%9D%B4%ED%8A%B8%EC%BD%94%EB%93%9C-%EC%A1%B0%EC%9E%91%EC%9D%98-%EB%A7%88%EB%B2%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/@Configuration%EA%B3%BC-%EB%B0%94%EC%9D%B4%ED%8A%B8%EC%BD%94%EB%93%9C-%EC%A1%B0%EC%9E%91%EC%9D%98-%EB%A7%88%EB%B2%95/</guid>
      <description> @Configuration, @Bean 을 통해 Bean 을 등록할 수 있다. # CGLIB 이 나의 클래스를 상속한 Proxy 클래스(객체)를 생성하고, 이 클래스(객체)를 Bean 으로 등록 # if(클래스(객체) 이미 존제?) { return 객체 반환 } else { obj = new 클래스(); obj -&amp;gt; bean 으로 저장; return obj } @Configuration 없이 @Bean 만 사용해도 Bean 으로 등록된다. # 단, 이때는 CGLIB 이 Proxy 객체로 만들어주지 않느다. = Proxy 객체를 생성 X = 싱글톤을 보장 X </description>
    </item>
    
    <item>
      <title>01. 계층형 아키텍처의 문제는 무엇일까?</title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EB%A7%8C%EB%93%A4%EB%A9%B4%EC%84%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%ED%81%B4%EB%A6%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/01.-%EA%B3%84%EC%B8%B5%ED%98%95-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EC%9D%98-%EB%AC%B8%EC%A0%9C%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EB%A7%8C%EB%93%A4%EB%A9%B4%EC%84%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%ED%81%B4%EB%A6%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/01.-%EA%B3%84%EC%B8%B5%ED%98%95-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EC%9D%98-%EB%AC%B8%EC%A0%9C%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C/</guid>
      <description>01. 계층형 아키텍처의 문제는 무엇일까? # 사실 계층형 아키텍처는 &amp;lsquo;견고한 아키텍쳐&amp;rsquo;이다.
(계층을 잘 이해하고 구성한다면) 웹 계층이나, 영속성 계층에 독립적으로 도메인 로직을 작성할 수 있다. (계층을 잘 이해하고 구성한다면) 도메인 로직에 영향을 주지 않고 웹 계층, 영속성 계층의 기술을 추가/변경할 수 있다. = 각각을 독립적인 계층으로 만들 수 있다. = 결합도를 낮출 수 있다. 잘 만들어진 &amp;lsquo;계층형 아키텍쳐&amp;rsquo;는 선택의 폭을 넓히고, 변화하는 요구사항과 외부 요인에 빠르게 적응할 수 있게 해준다.</description>
    </item>
    
    <item>
      <title>01. 사용자 수에 따른 규모 확장성</title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EA%B0%80%EC%83%81-%EB%A9%B4%EC%A0%91-%EC%82%AC%EB%A1%80%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84-%EA%B8%B0%EC%B4%88/01_%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%88%98%EC%97%90-%EB%94%B0%EB%A5%B8-%EA%B7%9C%EB%AA%A8-%ED%99%95%EC%9E%A5%EC%84%B1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EA%B0%80%EC%83%81-%EB%A9%B4%EC%A0%91-%EC%82%AC%EB%A1%80%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84-%EA%B8%B0%EC%B4%88/01_%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%88%98%EC%97%90-%EB%94%B0%EB%A5%B8-%EA%B7%9C%EB%AA%A8-%ED%99%95%EC%9E%A5%EC%84%B1/</guid>
      <description>어떤 데이터베이스를 사용할 것인가? # 아래의 경우 NoSQL(비-관계형 데이터베이스)가 바람직한 선택이 될 수 있습니다.
아주 낮은 응답 지연시간(latency) 요구 데이터 비정형 데이터 직렬화, 역직렬화를 할 수 있기만 하면 됨 아주 많은 양의 데이터를 저장 수직적 규모 확장 vs 수평적 규모 확장 # 수직적 규모 확장에는 다음과 같은 단점이 있습니다.
SPOF, 서버 장애 시 모든 서비스 중단/장애 Scale-Up에 한계가 있음 CPU, Memory 를 무한으로 늘릴 수 없음 [다중화] (웹 계층)웹 서버의 다중화를 위해 선택할 수 있는 것?</description>
    </item>
    
    <item>
      <title>01. 스프링 코어</title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%8A%A4%ED%94%84%EB%A7%81-5-%EB%A0%88%EC%8B%9C%ED%94%BC/1%EC%9E%A5.%EC%8A%A4%ED%94%84%EB%A7%81-%EC%BD%94%EC%96%B4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%8A%A4%ED%94%84%EB%A7%81-5-%EB%A0%88%EC%8B%9C%ED%94%BC/1%EC%9E%A5.%EC%8A%A4%ED%94%84%EB%A7%81-%EC%BD%94%EC%96%B4/</guid>
      <description>스프링 코어 # 아래 클래스는 스프링 IoC 컨테이너 (이하 IoC 컨테이너) 가 스캐닝한다.
자바 구성 클래스 (Java Configuration Class)
@Configuration @Bean 자바 컴포넌트 클래스 (Java Component Class)
@Component @Controller @Service @Repository @Configuration public class SequenceGeneratorConfiguration { @Bean public SequenceGenerator sequenceGenerator() { SequenceGenerator seqGen = new SequenceGenerator(); ... return seqGen } } 스프링은 @Configuration 의 클래스를 스캐닝하면, 그 안에서 (Bean 인스턴스를 생성해 반환하는) @Bean 자바 메소드를 찾는다.
기본적으로 Bean 의 이름은 메소드 명을 따라간다.</description>
    </item>
    
    <item>
      <title>01. 인터넷 통신</title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EB%AA%A8%EB%93%A0-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A5%BC-%EC%9C%84%ED%95%9C-HTTP-%EC%9B%B9-%EA%B8%B0%EB%B3%B8-%EC%A7%80%EC%8B%9D/01_%EC%9D%B8%ED%84%B0%EB%84%B7%ED%86%B5%EC%8B%A0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EB%AA%A8%EB%93%A0-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A5%BC-%EC%9C%84%ED%95%9C-HTTP-%EC%9B%B9-%EA%B8%B0%EB%B3%B8-%EC%A7%80%EC%8B%9D/01_%EC%9D%B8%ED%84%B0%EB%84%B7%ED%86%B5%EC%8B%A0/</guid>
      <description>요약 # IP # 출발지 IP, 목적지 IP Packet 단위 사용 (Layer 3) 비연결성 패킷 받을 대상이 없는지 확인 X 패킷 받을 대상이 어떤 상태인지 알 수 X 비신뢰성 패킷을 잘 받았는지 확인 X 중간에 소실될 수 도 있음 패킷을 순서대로 잘 보냈는지 확인 X 늦게 보낸 게 더 빨리 도착할 수도 있음 프로그램 구분 X &amp;lsquo;비연결성, 비신뢰성, 프로그램 구분&amp;rsquo; 을 어떻게 해결 ?? =&amp;gt; TCP(UDP)
TCP (혹은 UDP) # 참고 (TCP/IP Layer)</description>
    </item>
    
    <item>
      <title>02. URI</title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EB%AA%A8%EB%93%A0-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A5%BC-%EC%9C%84%ED%95%9C-HTTP-%EC%9B%B9-%EA%B8%B0%EB%B3%B8-%EC%A7%80%EC%8B%9D/02_URI/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EB%AA%A8%EB%93%A0-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A5%BC-%EC%9C%84%ED%95%9C-HTTP-%EC%9B%B9-%EA%B8%B0%EB%B3%B8-%EC%A7%80%EC%8B%9D/02_URI/</guid>
      <description>요약 # URI : Uniform Resource Identifier # (통일화 된) 자원(리소스) 식별자 ..?
URI 의 종류 # URL (Uniform Resource Locator) scheme, host, port, query parameter(string), fragment fragment 서버에 전송하는 정보 X html 내부 북마크 등에 사용 URN (Uniform Resource Name) URN 이 잘 안쓰이는 이유? 자원을 식별하기 위해서는 &amp;lsquo;고유&amp;rsquo;해야한다. &amp;lsquo;이름&amp;rsquo;으로 &amp;lsquo;고유성&amp;rsquo;을 갖기는 힘들지 않을까..? 이름을 고유한 번호 형태로 부여할 수도 있을텐데(e.g. ISBN) 이렇게 되면, 식별하기 어려울 것이다.
반변 &amp;lsquo;Locator&amp;rsquo; 기반으로 하면 (애초에)IP(서버) 가 다 다르니까 &amp;lsquo;고유성&amp;rsquo;을 갖기 더 수월하지 않을까.</description>
    </item>
    
    <item>
      <title>02. 개략적인 규모 추정</title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EA%B0%80%EC%83%81-%EB%A9%B4%EC%A0%91-%EC%82%AC%EB%A1%80%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84-%EA%B8%B0%EC%B4%88/02_%EA%B0%9C%EB%9E%B5%EC%A0%81%EC%9D%B8-%EA%B7%9C%EB%AA%A8-%EC%B6%94%EC%A0%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EA%B0%80%EC%83%81-%EB%A9%B4%EC%A0%91-%EC%82%AC%EB%A1%80%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84-%EA%B8%B0%EC%B4%88/02_%EA%B0%9C%EB%9E%B5%EC%A0%81%EC%9D%B8-%EA%B7%9C%EB%AA%A8-%EC%B6%94%EC%A0%95/</guid>
      <description>2장 개략적인 규모 추정 # 구글의 시니어 펠로(senior fellow) 제프 딘(Jeff Dean)에 따르면, &amp;ldquo;개략적인 규모 추정&amp;quot;은 보편적으로 통용되는 성능 수치상에서 사고 실험을 행하여 추정치를 계산하는 행위로서, 어떤 설계가 요구사항에 부합할 것인지 보기 위한 것이다.
개략적 규모 추정을 효과적으로 해내려면 규모 확장성을 표현하는 데 필요한 기본기에 능숙해야 한다.
특히 2의 제곱수, latency(응답 지연), throughput(처리량, 처리율), 가용성과 관련된 수치들을 잘 이해하고 사용할 수 있어야 한다.
2의 제곱수 # 2^n 근사치 단위 2^10 1,000 (1천) KB 2^20 1,000,000 (1백만) MB 2^30 1,000,000,000 (10억) GB 2^40 1,000,000,000,000 (1조) TB 2^50 1,000,000,000,000,000 (1,000조) PB Latency (모든 프로그래머가 알야아 하는 응답 지연 값) # 구글의 제프 딘은 2010년에 통상적인 (컴퓨터에서 구현된 연산들의) 응답 지연 값을 공개한 바 있다.</description>
    </item>
    
    <item>
      <title>02. 스프링 MVC</title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%8A%A4%ED%94%84%EB%A7%81-5-%EB%A0%88%EC%8B%9C%ED%94%BC/2%EC%9E%A5.-%EC%8A%A4%ED%94%84%EB%A7%81-MVC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%8A%A4%ED%94%84%EB%A7%81-5-%EB%A0%88%EC%8B%9C%ED%94%BC/2%EC%9E%A5.-%EC%8A%A4%ED%94%84%EB%A7%81-MVC/</guid>
      <description>스프링 MVC # MVC 는 아주 일반적인 UI 디자인 패턴이다.
Model, View, Controller 의 역할을 분리한다. (* UI 에서 비즈니스 로직을 분리시킬 수 있다.)
Model : Data 에만 집중한다. View : Model(Data)를 보여주는 것에만 집중한다. (렌더링에 집중한다.) Controller : 요청을 받고, 비즈니스 로직을 수행을 위해 적절히 업무를 분배한다. Front Controller # Front Controller(프론트 컨트롤러)는 Spring MVC 의 중심 컴포넌트이다.
Spring MVC 에서 &amp;lsquo;Dispatcher Servlet&amp;rsquo; 는 Front Controller 패턴을 구현한 것이다.</description>
    </item>
    
    <item>
      <title>02. 의존성 역전하기</title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EB%A7%8C%EB%93%A4%EB%A9%B4%EC%84%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%ED%81%B4%EB%A6%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/02.-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%97%AD%EC%A0%84%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EB%A7%8C%EB%93%A4%EB%A9%B4%EC%84%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%ED%81%B4%EB%A6%B0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/02.-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%97%AD%EC%A0%84%ED%95%98%EA%B8%B0/</guid>
      <description>02. 의존성 역전하기 # 1장에서 계층형 아키텍쳐의 단점에 대해 살펴보았고, 이번 장에서는 &amp;lsquo;대안&amp;rsquo;(SRP, DIP) 에 대해 이야기한다.
단일 책임 원칙 (SRP) # &amp;quot; 하나의 컴포넌트는 오로지 한 가지 일만 해야 하고, 그것을 올바르게 수행해야 한다. &amp;ldquo;
(실제로) 위 문장(하나의 컴포넌트는 오로지 한 가지 일을 해야한다.)은 &amp;lsquo;단일 책임 원칙의 실제 의도&amp;rsquo;는 아니다.
&amp;lsquo;오로지 한 가지 일만 하는 것&amp;rsquo;은 단일 책임이라는 말을 직관적으로 해석한 것이다.
단일 책임 원칙의 실제 정의는 다음과 같다.</description>
    </item>
    
    <item>
      <title>03. HTTP</title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EB%AA%A8%EB%93%A0-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A5%BC-%EC%9C%84%ED%95%9C-HTTP-%EC%9B%B9-%EA%B8%B0%EB%B3%B8-%EC%A7%80%EC%8B%9D/03_HTTP/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EB%AA%A8%EB%93%A0-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A5%BC-%EC%9C%84%ED%95%9C-HTTP-%EC%9B%B9-%EA%B8%B0%EB%B3%B8-%EC%A7%80%EC%8B%9D/03_HTTP/</guid>
      <description>요약 # HTTP (HyperText Transfer Protocol) # Client - Server 구조 클라이언트 - 서버의 분리는 역할/책임 분리의 의미에서도 중요한 것 비상태성 (Stateless) 서버 확장(Scale Out) OK (클라이언트의 요청에 대해서) 항상 다른 서버가 처리 OK 클라이언트쪽에서 조금 불편 (서버 측에서 정보를 기억하는게 아니니까) 상태가 필요한 경우 : 대표 예시 -&amp;gt; 로그인 특정 서버에 구애받지 않게 독립적인(외부) 상태 저장소 사용 비연결성 연결을 유지할 경우, 수많은 클라이언트와 연결해야 하는 부담 서버 자원을 효율적으로 사용하기 위함 단순 * HyperText 란?</description>
    </item>
    
    <item>
      <title>03. Key-Value Store 설계</title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EA%B0%80%EC%83%81-%EB%A9%B4%EC%A0%91-%EC%82%AC%EB%A1%80%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84-%EA%B8%B0%EC%B4%88/06_Key-Value-Store-%EC%84%A4%EA%B3%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EA%B0%80%EC%83%81-%EB%A9%B4%EC%A0%91-%EC%82%AC%EB%A1%80%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84-%EA%B8%B0%EC%B4%88/06_Key-Value-Store-%EC%84%A4%EA%B3%84/</guid>
      <description>Key-Value Store # 대표적인 예시 : amazon dynamodb, memcached, redis, &amp;hellip;
Key 는 유일해야 한다.
Key 는 짧을수록 성능 상 유리하다. Value 는 Key를 통해서만 접근할 수 있다. Value 는 다양한 자료구조(문자열, 리스트, 객체)일 수 있다.
완벽한 설계란 없다. READ(일기), WRITE(쓰기), MEMORY USAGE(메모리 사용량) 사이에 균형(balance)을 찾고 데이터의 일관성, 가용성 사이에서 타협적 결정을 내려야 한다.
단일 서버 Key-Value Store # 한 대의 서버만 사용하는 Key-Value Store를 설계하는 것은 쉽다. 가장 직관적으로 (인메모리)해시 테이블에 저장하면 된다.</description>
    </item>
    
    <item>
      <title>03. 사용자 및 권한</title>
      <link>https://hjjae2.github.io/docs/BOOKS/Real-Mysql-8.0/03_%EC%82%AC%EC%9A%A9%EC%9E%90-%EB%B0%8F-%EA%B6%8C%ED%95%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/Real-Mysql-8.0/03_%EC%82%AC%EC%9A%A9%EC%9E%90-%EB%B0%8F-%EA%B6%8C%ED%95%9C/</guid>
      <description>MySQL 사용자 계정 = 사용자 ID, 호스트(사용자 IP) 구성
MySQL 8.0 부터는 Role(역할) 개념이 도입되었다. Role 을 부여함으로써, 미리 준비된 권한들을 부여할 수 있다.
3.1 사용자 식별 # 사용자 계정
사용자 ID 호스트(사용자 IP, 도메인) 아래와 같이 동일한 두 계정이 있다면, 로그인 시 좁은 범위의 계정이 선택된다.
`test`@`127.0.0.1` (pw : 123) `test`@`%` (pw : abc) (로컬호스트 환경에서) test 계정으로 로그인 시, test@127.0.01 계정으로 로그인을 시도 한다.
3.2 사용자 계정 관리 # Mysql 8.</description>
    </item>
    
    <item>
      <title>04. 아키텍처</title>
      <link>https://hjjae2.github.io/docs/BOOKS/Real-Mysql-8.0/04_%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/Real-Mysql-8.0/04_%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/</guid>
      <description>Mysql 서버 = Mysql 엔진 + Storage 엔진
Handler API(핸들러 API)를 구현하여, (추가적인) Storage 엔진을 개발/적용할 수 있다. 4.1 MySQL 엔진 아키텍처 # Mysql 서버는 다른 DBMS 에 비해 구조가 독특하다고 볼 수 있다.
아래와 같이 구조를 나눠볼 수 있다. Mysql 엔진 Storage 엔진 - 커넥션 핸들러 - SQL 파서 - SQL 옵티마이저
- 캐시 &amp;amp; 버퍼
- &amp;hellip; - InnoDB
- MyISAM
- &amp;hellip; 커넥션 핸들러 SQL 파서 , SQL 옵티마이저 , 캐시 &amp;amp; 버퍼 스토리지 엔진 (InnoDB, MyISAM, .</description>
    </item>
    
    <item>
      <title>1-01. 성능이란?</title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%8B%A4%EB%AC%B4%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94/1-01.-%EC%84%B1%EB%8A%A5%EC%9D%B4%EB%9E%80/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%8B%A4%EB%AC%B4%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94/1-01.-%EC%84%B1%EB%8A%A5%EC%9D%B4%EB%9E%80/</guid>
      <description>01. 성능이란 # 시스템 성능은 &amp;lsquo;시간당 처리량&amp;rsquo;이며, 영향을 미치는 요소는 &amp;lsquo;응답시간&amp;rsquo;, &amp;lsquo;동시에 처리할 수 있는 프로세스 수&amp;rsquo;이다.
응답시간은 사용자의 특성, 환경에 따라 요구하는 수준이 다르다. 동일한 응답시간에 대해 고객마다 만족도도 다르다.
이는 모든 시스템과 사용자에게 일률적으로 적용할 수 있는 응답시간의 기준은 없다는 것을 의미한다.
1.1 동시 사용자 # 성능 분석이나 테스트 시 공식적으로 적용되는 동시 사용자라는 의미는 대상 서버에 접속하고 있는 사용자로 정의한다.
동시 사용자는 다음과 같이 두 유형의 합으로 표현할 수 있다.</description>
    </item>
    
    <item>
      <title>10. 알림 시스템 설계</title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EA%B0%80%EC%83%81-%EB%A9%B4%EC%A0%91-%EC%82%AC%EB%A1%80%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84-%EA%B8%B0%EC%B4%88/10_%EC%95%8C%EB%A6%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EA%B0%80%EC%83%81-%EB%A9%B4%EC%A0%91-%EC%82%AC%EB%A1%80%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84-%EA%B8%B0%EC%B4%88/10_%EC%95%8C%EB%A6%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84/</guid>
      <description>개요 # 앱(iOS, Android) 알림, SMS, Email 알림을 보내야 한다.
iOS 푸시 알림 # iOS에서 Push Notification(푸시 알림)을 보내기 위해서 3가지 컴포넌트가 필요하다.
알림 제공자(Provider), APNS, iOS 단말기(Device)
컴포넌트 설명 알림 제공자 (Provider) 알림 요청을 APNS에 요청하는 주체이다. 알림 요청을 생성하기 위해 단말 토큰(device token), 내용(payload) 가 필요하다고 한다. APNS (Apple Push Notification Service) 애플이 제공하는 원격 서비스이다. 푸시 알림을 iOS 단말기로 보내는 역할을 담당한다. iOS 단말기 사용자가 사용하는 단말기(장치)이다.</description>
    </item>
    
    <item>
      <title>1장 객체, 설계</title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8/1%EC%9E%A5-%EA%B0%9D%EC%B2%B4-%EC%84%A4%EA%B3%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8/1%EC%9E%A5-%EA%B0%9D%EC%B2%B4-%EC%84%A4%EA%B3%84/</guid>
      <description>1장 &amp;lsquo;객체, 설계&amp;rsquo;의 핵심 부분 정리해보기
로버트 마틴 &amp;lsquo;클린 소프트웨어: 애자일 원칙과 패턴, 그리고 실천 방법&amp;rsquo; 에서 소프트웨어 모듈이 가져야 하는 세 가지 기능은 다음과 같다.
실행 중에 제대로 동작한다. 변경을 위해 존재한다. 대부분의 모듈은 생명주기 동안 변경되기 때문에 간단하게 변경할 수 있어야 한다. 변경하기 어렵다면, 개선해야 한다. 코드를 읽는 사람과 의사소통한다. 개발자가 쉽게 읽고 이해할 수 있어야 한다. 읽는 사람과 의사소통할 수 없는 모듈은 개선되어야 한다. 객체 사이의 의존성을 완전히 없애는 것이 정답은 아니다.</description>
    </item>
    
    <item>
      <title>1장. 자바 8,9,10,11 무슨 일이 일어나고 있는가?</title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EB%AA%A8%EB%8D%98-%EC%9E%90%EB%B0%94-%EC%9D%B8-%EC%95%A1%EC%85%98/1%EC%9E%A5-%EC%9E%90%EB%B0%94-891011-%EB%AC%B4%EC%8A%A8-%EC%9D%BC%EC%9D%B4-%EC%9D%BC%EC%96%B4%EB%82%98%EA%B3%A0-%EC%9E%88%EB%8A%94%EA%B0%80/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EB%AA%A8%EB%8D%98-%EC%9E%90%EB%B0%94-%EC%9D%B8-%EC%95%A1%EC%85%98/1%EC%9E%A5-%EC%9E%90%EB%B0%94-891011-%EB%AC%B4%EC%8A%A8-%EC%9D%BC%EC%9D%B4-%EC%9D%BC%EC%96%B4%EB%82%98%EA%B3%A0-%EC%9E%88%EB%8A%94%EA%B0%80/</guid>
      <description>자바 8,9,10,11 무슨 일이 일어나고 있는가? # 자바 역사를 통틀어 자바 8에서 가장 큰 변화가 일어났다.
자바 8에서 제공하는 새로운 기술은 다음과 같다.
스트림 API 메서드에 코드를 전달하는 것 (함수형 프로그래밍(?)) 인터페이스 Default 메서드 에러를 자주 일으키고 멀티코어 CPU를 이용하는 것보다 훨씬 비용이 비싼 synchrosized 키워드 대신에 Stream API 을 사용할 수 있다.
또, Stream API 덕분에 메서드에 코드를 전달하는 것, 인터페이스의 Default 메서드 가 자연스럽게 탄생하게 되었다. (?)</description>
    </item>
    
    <item>
      <title>2장. 동작 파라미터화 코드 전달하기</title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EB%AA%A8%EB%8D%98-%EC%9E%90%EB%B0%94-%EC%9D%B8-%EC%95%A1%EC%85%98/2%EC%9E%A5-%EB%8F%99%EC%9E%91-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%ED%99%94-%EC%BD%94%EB%93%9C-%EC%A0%84%EB%8B%AC%ED%95%98%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EB%AA%A8%EB%8D%98-%EC%9E%90%EB%B0%94-%EC%9D%B8-%EC%95%A1%EC%85%98/2%EC%9E%A5-%EB%8F%99%EC%9E%91-%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%ED%99%94-%EC%BD%94%EB%93%9C-%EC%A0%84%EB%8B%AC%ED%95%98%EA%B8%B0/</guid>
      <description>동작 파라미터화 코드 전달하기 # 쉽게 말하면 메서드를 파라미터로 전달하는 것이다.
동작 파라미터화란? 아직은 어떻게 실행할 것인지 결정하지 않은 코드블록이다. 코드블록은 나중에 프로그램에서 호출한다. 즉, 코드블록의 실행은 나중이다.
예시코드 # 첫 번째 시도 # public static List&amp;lt;Apple&amp;gt; filterApple(List&amp;lt;Apple&amp;gt; apples) { List&amp;lt;Apple&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); for(Apple apple : apples) { if(GREEN.equals(apple.getColor())) { result.add(apple); } } return result; } 여기서 조건(GREEN)이 변경(RED)되거나 추가(Weight)된다면 해당 메서드를 사용할 수 없다. (새로운 메서드를 생성할 것이다.</description>
    </item>
    
    <item>
      <title>3장. 람다표현식</title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EB%AA%A8%EB%8D%98-%EC%9E%90%EB%B0%94-%EC%9D%B8-%EC%95%A1%EC%85%98/3%EC%9E%A5-%EB%9E%8C%EB%8B%A4%ED%91%9C%ED%98%84%EC%8B%9D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EB%AA%A8%EB%8D%98-%EC%9E%90%EB%B0%94-%EC%9D%B8-%EC%95%A1%EC%85%98/3%EC%9E%A5-%EB%9E%8C%EB%8B%A4%ED%91%9C%ED%98%84%EC%8B%9D/</guid>
      <description>람다 표현식 # 람다? # 람다 표현식(이하 람다)는 메서드로 전달할 수 있는 익명함수를 단순화 한 것이다.
람다 표현식(lambda expression)이란 간단히 말해 메소드를 하나의 식으로 표현한 것입니다.
람다는 {parameters} {-&amp;gt;} {body} 의 형태로 작성된다.
(Apple a1, Apple a2) -&amp;gt; a1.getWeight().compareTo(a2.getWeight()); 자바 8에서 지원하는 5 가지 람다 표현식의 예제 # 1. (String s) -&amp;gt; s.length() 2. (Apple a) -&amp;gt; a.getWeight() &amp;gt; 150 3. (int x, int y) -&amp;gt; { System.out.println(x, y); } 4.</description>
    </item>
    
    <item>
      <title>4장. 스트림 소개</title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EB%AA%A8%EB%8D%98-%EC%9E%90%EB%B0%94-%EC%9D%B8-%EC%95%A1%EC%85%98/4%EC%9E%A5-%EC%8A%A4%ED%8A%B8%EB%A6%BC-%EC%86%8C%EA%B0%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EB%AA%A8%EB%8D%98-%EC%9E%90%EB%B0%94-%EC%9D%B8-%EC%95%A1%EC%85%98/4%EC%9E%A5-%EC%8A%A4%ED%8A%B8%EB%A6%BC-%EC%86%8C%EA%B0%9C/</guid>
      <description>Stream 이란, &amp;lsquo;데이터 처리 연산을 지원하도록, source 에서 추출된 연속된 요소(sequence of elements)&amp;rsquo; 라고 한다.
연속된 요소
컬렉션과 마찬가지로 (특정 요소 형식으로 이루어진) 연속된 값 집합의 인터페이스를 제공한다.
컬렉션은 자료구조(data structure)이므로, 시간/공간 복잡도에 대한 고려, 저장, 접근 연산이 주를 이룬다.
반면, 스트림은 filter, sorted, map 과 같은 표현식(표현 계산식)이 주를 이룬다.
즉, 컬렉션의 주제는 데이터(data)이고 스트림의 주제는 계산(operation, calculation)이다.
소스(Source)
스트림은 컬렉션, 배열, I/O 자원 등의 &amp;lsquo;데이터 소스&amp;rsquo;로부터 데이터를 소비한다.</description>
    </item>
    
    <item>
      <title>5장. 객체 지향 설계 5원칙 (SOLID)</title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%9E%90%EB%B0%94-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5%EC%9D%98-%EC%9B%90%EB%A6%AC%EC%99%80-%EC%9D%B4%ED%95%B4/5%EC%9E%A5.-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84-5%EC%9B%90%EC%B9%99-SOLID/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%9E%90%EB%B0%94-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5%EC%9D%98-%EC%9B%90%EB%A6%AC%EC%99%80-%EC%9D%B4%ED%95%B4/5%EC%9E%A5.-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84-5%EC%9B%90%EC%B9%99-SOLID/</guid>
      <description>객체 지향 설계 5 원칙 - SOLID # * 주관적으로 해석될 수 있다.
객체 지향의 특성을 올바르게 사용하는 방법, 즉 객체 지향 언어를 이용해 객체 지향 프로그램을 올바르게 설계해 나가는 방법/원칙에 대한 고민이 있었다.
많은 Best Practice, 시행 착오 속에서 SOLID 개념이 탄생되었다.
이들의 기본적인 원칙은 응집도(cohension)를 높이고, 결합도(coupling)는 낮추는 것에 있다.
우리들의 프로그램(소프트웨어)에 녹여내야 하는 개념이다.
디자인 패턴, 스프링 프레임워크의 뼈대이다.
객체 지향 4대 특성을 제대로 활용하면 자연스럽게 SOLID 가 적용된다.</description>
    </item>
    
    <item>
      <title>5장. 대규모 데이터 처리의 어려운 점 (메모리와 디스크)</title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%84%9C%EB%B9%84%EC%8A%A4%EB%A5%BC-%EC%A7%80%ED%83%B1%ED%95%98%EB%8A%94-%EA%B8%B0%EC%88%A0/5%EC%9E%A5_%EB%8C%80%EA%B7%9C%EB%AA%A8-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%B2%98%EB%A6%AC%EC%9D%98-%EC%96%B4%EB%A0%A4%EC%9A%B4-%EC%A0%90-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%99%80-%EB%94%94%EC%8A%A4%ED%81%AC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%84%9C%EB%B9%84%EC%8A%A4%EB%A5%BC-%EC%A7%80%ED%83%B1%ED%95%98%EB%8A%94-%EA%B8%B0%EC%88%A0/5%EC%9E%A5_%EB%8C%80%EA%B7%9C%EB%AA%A8-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%B2%98%EB%A6%AC%EC%9D%98-%EC%96%B4%EB%A0%A4%EC%9A%B4-%EC%A0%90-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%99%80-%EB%94%94%EC%8A%A4%ED%81%AC/</guid>
      <description>(대규모 데이터 처리가 어려운 이유)메모리 내에서 처리(계산)할 수 없다. # 메모리에서 처리할 수 없으면 DISK 를 사용해야 한다. 메모리의 크기는 DISK에 비해 작기 때문에 데이터의 크기가 클 경우 메모리에서 모두 처리할 수 없게 된다. 메모리는 디스크에 비해 10^5(10만) ~ 10^6(100만) 배 빠르다. 메모리는 왜 디스크보다 빠를까? # 1. 물리적인 구조
물리적인 구조가 그렇다. 메모리는 전기적인 부품이다. 데이터를 탐색하는 속도가 빠르다.
반대로 DISK는 동축 상에 원반(disk)로 쌓여 있다. 원반 회전, 헤드의 이동 등의 물리적인 비용이 발생하고 이게 크다.</description>
    </item>
    
    <item>
      <title>6장. 규모 조정의 요소</title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%84%9C%EB%B9%84%EC%8A%A4%EB%A5%BC-%EC%A7%80%ED%83%B1%ED%95%98%EB%8A%94-%EA%B8%B0%EC%88%A0/6%EC%9E%A5_%EA%B7%9C%EB%AA%A8-%EC%A1%B0%EC%A0%95%EC%9D%98-%EC%9A%94%EC%86%8C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%84%9C%EB%B9%84%EC%8A%A4%EB%A5%BC-%EC%A7%80%ED%83%B1%ED%95%98%EB%8A%94-%EA%B8%B0%EC%88%A0/6%EC%9E%A5_%EA%B7%9C%EB%AA%A8-%EC%A1%B0%EC%A0%95%EC%9D%98-%EC%9A%94%EC%86%8C/</guid>
      <description>규모 조정 # CPU 부하의 규모 조정은 간단하다. # 스케일 아웃 전략을 통해 대응한다. 보통 웹, API, 크롤러 등의 애플리케이션에 해당된다. I/O 부하의 규모 조정은 어렵다. # 보통 DB(with 대규모 데이터) 가 해당된다. 두 종류의 부하(CPU, I/O)와 웹 애플리케이션 # 일반적으로 웹 애플리케이션은 CPU 바운드 프로그램이다.
반면, 일반적으로 디스크에 저장된 데이터를 찾아내는 프로그램(= DB)는 I/O 바운드 프로그램이다.
멀티태스킹 OS와 부하 # (멀티 태스킹 환경에서) A가 CPU 를 점유하고 있는 동안 (CPU가 필요한)B, C 는 대기하게 된다.</description>
    </item>
    
    <item>
      <title>6장. 스프링이 사랑한 디자인 패턴</title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%9E%90%EB%B0%94-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5%EC%9D%98-%EC%9B%90%EB%A6%AC%EC%99%80-%EC%9D%B4%ED%95%B4/6%EC%9E%A5.-%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%B4-%EC%82%AC%EB%9E%91%ED%95%9C-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%9E%90%EB%B0%94-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5%EC%9D%98-%EC%9B%90%EB%A6%AC%EC%99%80-%EC%9D%B4%ED%95%B4/6%EC%9E%A5.-%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%B4-%EC%82%AC%EB%9E%91%ED%95%9C-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/</guid>
      <description>스프링이 사랑한 디자인 패턴 # 디자인 패턴이란?
프로그램을 작성하다보면 비슷비슷한 상황에 직면하게 된다. 이러한 상황에서 이전의 많은 개발자들이 고민하고 정제한 (사실상의)표준 설계 패턴이다.
Design Pattern = 설계 패턴
개발을 하면서 사용된 다양한 설계 패턴 중 많은 사람들이 인정한 Best Practice 를 정리한 것이다.
&amp;lsquo;객체 지향의 4대 특성&amp;rsquo;과 &amp;lsquo;객체 지향의 설계 5 원칙&amp;rsquo;이 기반이 된다.
디자인 패턴은 객체 지향의 특성 중 상속, 인터페이스, 합성(객체를 속성으로 사용하는 것)을 이용한다.
어댑터 패턴 (Adapter Pattern) 프록시 패턴 (Proxy Pattern) 데코레이터 패턴 (Decorator Pattern) 싱클톤 패턴 (Singleton Pattern) 템플릿 메서드 패턴 (Template Method Pattern) 팩토리 메서드 패턴 (Factory Method Pattern) 전략 패턴 (Strategy Pattern) 템플릿 콜백 패턴 (Template Callback Pattern) 이 외 다양한 패턴들 어댑터 패턴 (Adapter Pattern) # 어댑터(adapter) 는 변환기(converter) 라고 할 수 있다.</description>
    </item>
    
    <item>
      <title>7장. 대규모 데이터를 다루기 위한 기초 지식</title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%84%9C%EB%B9%84%EC%8A%A4%EB%A5%BC-%EC%A7%80%ED%83%B1%ED%95%98%EB%8A%94-%EA%B8%B0%EC%88%A0/7%EC%9E%A5_%EB%8C%80%EA%B7%9C%EB%AA%A8-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EB%8B%A4%EB%A3%A8%EA%B8%B0-%EC%9C%84%ED%95%9C-%EA%B8%B0%EC%B4%88_%EC%A7%80%EC%8B%9D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%84%9C%EB%B9%84%EC%8A%A4%EB%A5%BC-%EC%A7%80%ED%83%B1%ED%95%98%EB%8A%94-%EA%B8%B0%EC%88%A0/7%EC%9E%A5_%EB%8C%80%EA%B7%9C%EB%AA%A8-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EB%8B%A4%EB%A3%A8%EA%B8%B0-%EC%9C%84%ED%95%9C-%EA%B8%B0%EC%B4%88_%EC%A7%80%EC%8B%9D/</guid>
      <description>대규모 데이터를 다루는 세 가지 요령 # 1. 최대한 메모리에서 처리한다.
ex: disk seek 횟수 최소화 ex: 국소성 활용한 분산 실현 2. (데이터량에 따른) 효율적인 알고리즘/자료구조 사용
ex: 선형 탐색 -&amp;gt; 이분 탐색 3. 데이터 압축, 검색 기술과 같은 테크닉
ex: 데이터 압축(데이터 용량 ↓) = 메모리 처리 ↑ = seek 횟수 ↓ Load Average 다음은 CPU 사용률, I/O 대기율 # 과부하로 시스템의 성능이 떨어지는 원인은 대부분의 경우에 CPU, I/O에 있다.</description>
    </item>
    
    <item>
      <title>7장. 스프링 삼각형과 설정 정보</title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%9E%90%EB%B0%94-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5%EC%9D%98-%EC%9B%90%EB%A6%AC%EC%99%80-%EC%9D%B4%ED%95%B4/7%EC%9E%A5.-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%82%BC%EA%B0%81%ED%98%95%EA%B3%BC-%EC%84%A4%EC%A0%95-%EC%A0%95%EB%B3%B4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%9E%90%EB%B0%94-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5%EC%9D%98-%EC%9B%90%EB%A6%AC%EC%99%80-%EC%9D%B4%ED%95%B4/7%EC%9E%A5.-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%82%BC%EA%B0%81%ED%98%95%EA%B3%BC-%EC%84%A4%EC%A0%95-%EC%A0%95%EB%B3%B4/</guid>
      <description>스프링 삼각형과 설정 정보 # 스프링을 이해하기 위해 스프링의 3대 프로그래밍 모델을 이해할 수 있어야 한다.
스프링의 3대 프로그래밍 모델이란?
IoC/DI AOP PSA * POJO 기반임을 기억하자.
IoC/DI # 제어의 역전, 의존성 주입
* 주입이란? 외부에서 라는 뜻을 내포하고 있다. 즉, 외부에서 생성되어 주입이 되는 것이다.
다음과 같은 코드가 있다.
// 운전자 public class Driver { public static void main(String[] args) { Car car = new Car(); } } // 자동차 public class Car { Tire tire; public Car() { tire = new KoreaTire(); } .</description>
    </item>
    
    <item>
      <title>Broker, Replication, ISR</title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%95%84%ED%8C%8C%EC%B9%98-%EC%B9%B4%ED%94%84%EC%B9%B4-for-beginners/Broker-Replication-ISR/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%95%84%ED%8C%8C%EC%B9%98-%EC%B9%B4%ED%94%84%EC%B9%B4-for-beginners/Broker-Replication-ISR/</guid>
      <description>Kafka Broker : 카프카가 설치된 서버의 단위를 의미
보통 브로커 3대 유지하기를 권장한다고 함 partition -&amp;gt; replication 의 수 만큼 복제 (단, 브로커 개수에 제한된다.)
Leader partition (DB의 master 개념) producer의 데이터를 전달받는 주체 Follower parition (DB의 slave 개념) Leader partition(브로커) 죽었을 때 -&amp;gt; follower partition 이 Leader 가 되어 가용성 보장 ISR = Leader + Follower partition e.g. replciation 3 이라면, Leader partition 1, Follower partition 2 개 존재한다.</description>
    </item>
    
    <item>
      <title>Mock Roles, not Objects</title>
      <link>https://hjjae2.github.io/docs/BOOKS/PAPER-Mock-Roles-not-Objects/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/PAPER-Mock-Roles-not-Objects/</guid>
      <description>Mock Roles, not Objects # 4. MOCK OBJECTS IN PRACTICE # 시스템 설계가 약할 때(강한 결합, 잘못된 책임 등_), Mock 기반의 테스트 코드는 굉장히 복잡해지고, 많은 문제(problem)를 야기한다.
예를 들어, 우리가 하나의 클래스에 너무 많은 역할을 부여하고 테스트 코드(with Mocking) 작성할 때 이상함을 느끼곤한다. (그러곤 이 부분에 대해 리팩토링을 하곤 한다.)
이런 케이스도 위에서 말한 케이스에 포함되는 것 같다.
한 가지 대응 방법은 &amp;lsquo;Mocking 사용&amp;rsquo;을 중단하는 것이다.
&amp;lsquo;Mocking 사용&amp;rsquo;은 설계 개선(위에서 말한 &amp;lsquo;예시&amp;rsquo; 처럼)을 위한 목적으로 사용하는 것이 더 낫다고 생각한다.</description>
    </item>
    
    <item>
      <title>기본</title>
      <link>https://hjjae2.github.io/docs/BOOKS/IOS-Android-%EC%95%B1-%EA%B0%9C%EB%B0%9C%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%8B%A4%EC%A0%84-React-Native-Basic/%EA%B8%B0%EB%B3%B8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/IOS-Android-%EC%95%B1-%EA%B0%9C%EB%B0%9C%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%8B%A4%EC%A0%84-React-Native-Basic/%EA%B8%B0%EB%B3%B8/</guid>
      <description>기본 원리 # React Native # 1. Bundling
JS 파일을 React N 이 번들링하여, 각 플랫폼에 제공(?)한다.
2. Bridge
(플랫폼 단에서) JS Thread 와 Native Threads 가 매끄럽게 이어질 수 있도록(?) Bridge 를 제공한다.
Bulding 종류 # 종류 장점 단점 Expo CLI 1. 개발 환경 구축이 쉽다. 2. 실제로 개발이 쉽고 편하다. 1. OS Layer 와 직접 상호작용 불가능하다. (Java, Kotlin, Object-C, Swift 로 추가 작성이 불가능하다.) 2. Expo에서 제공해주는 모듈만 사용 가능하다.</description>
    </item>
    
    <item>
      <title>빈 생명 주기</title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/%EB%B9%88-%EC%83%9D%EB%AA%85-%EC%A3%BC%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/%EB%B9%88-%EC%83%9D%EB%AA%85-%EC%A3%BC%EA%B8%B0/</guid>
      <description>스프링 Bean 은 다음과 같은 라이프사이클
(Bean) 객체 생성 의존관계 주입 스프링 컨테이너 생성 (ApplicationContext) 스프링 Bean 생성/등록 의존관계 주입 (DI) 초기화 콜백 : 빈 생성 / DI 이후 호출 사용 (개발자 코드 동작) 소멸(전) 콜백 : 빈 소멸 전 호출 스프링(스프링 컨테이너) 종료 생성자에서 하면 되는 것을, 왜(굳이) 초기화 콜백 사용??
-&amp;gt; (권장!!) 객체의 생성 / 초기화 분리한다.
책임 / 역할 분리 생성자 : 필수 정보 / 메모리 할당 등 &amp;lsquo;생성&amp;rsquo; 에 중점을 둔다.</description>
    </item>
    
    <item>
      <title>빈 스코프</title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/%EB%B9%88-%EC%8A%A4%EC%BD%94%ED%94%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/%EB%B9%88-%EC%8A%A4%EC%BD%94%ED%94%84/</guid>
      <description>빈 스코프 : 빈이 존재할 수 있는 범위 # 기본 값 : singleton (애플리케이션 시작 ~ 종료)
즉, 스프링 컨테이너의 시작과 끝 (동일한 범위를 갖는다.)
스코프 종류 # singleton, prototype, request 는 기억하고 넘어갈 것
singleton prototype 빈 생성 / 의존관계 / 초기화하여 반환하고 끝 (관리 X) 매우 짧은 범위의 스코프 request (웹 관련 scope) 웹 요청이 들어오고 나갈 때 까지의 스코프 session (웹 관련 scope) 웹 세션 생성 ~ 종료 스코프 application (웹 관련 scope) 웹 서플릿 컨텍스트와 같은 범위 웹스코프 (라이브러리 필요 : spring-boot-starter-web)</description>
    </item>
    
    <item>
      <title>섹션1. Service Discovery</title>
      <link>https://hjjae2.github.io/docs/BOOKS/Spring-Cloud%EB%A1%9C-%EA%B0%9C%EB%B0%9C%ED%95%98%EB%8A%94-%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98/%EC%84%B9%EC%85%981-Service-Discovery/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/Spring-Cloud%EB%A1%9C-%EA%B0%9C%EB%B0%9C%ED%95%98%EB%8A%94-%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98/%EC%84%B9%EC%85%981-Service-Discovery/</guid>
      <description>Service Discovery(Eureka) 이해해보기
PC 가 한 대라면 같은 IP/다른 PORT 형태로 여러 애플리케이션을 구성할 수 있다. PC 가 여러 대라면, 다른 IP/같은 PORT 형태로 여러 애플리케이션을 구성할 수 있다.
Service Discovery 란, 외부에서 내부의 마이크로서비스를 찾기 위해(검색) 사용된다. Key, Value 쌍으로 서비스를 등록하고 검색할 수 있다. 또, Netflix Eureka 는 Netfix 에서 만든 오픈소스를 아파치 재단에 등록한 것이다.
Load Balancer 혹은 API Gateway 에 요청이 들어왔을 때, 먼저 Service Discovery 에 해당 서비스가 어디 위치하고 있는지 조회하는 개념이다.</description>
    </item>
    
    <item>
      <title>섹션2. API Gateway</title>
      <link>https://hjjae2.github.io/docs/BOOKS/Spring-Cloud%EB%A1%9C-%EA%B0%9C%EB%B0%9C%ED%95%98%EB%8A%94-%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98/%EC%84%B9%EC%85%982-API-Gateway/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/Spring-Cloud%EB%A1%9C-%EA%B0%9C%EB%B0%9C%ED%95%98%EB%8A%94-%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98/%EC%84%B9%EC%85%982-API-Gateway/</guid>
      <description>API Gateway # 외부에 노출되는 API 이다.
내부의 API 들은 감추고, 외부에 노출하여 Proxy/Gateway 역할(즉 단일 진입점 역할)을 한다.
Client 는 API Gateway(단일 API) 만 바라보고 작업할 수 있다.
API Gateway 는 인증, 인가, LB, Routing, Logging, CircuitBreaker 의 역할을 한다. (?)
Netflix Ribbon # Spring Cloud 에서 MSA 간 통신이 필요하다.
ResetTemplate : RestAPI 를 통해 통신한다. Feign Client : MicroService의 이름을 등록하고, 이름으로 호출한다. Ribbon : Client-Side Load Balancer</description>
    </item>
    
    <item>
      <title>섹션3. Spring Configuration Service</title>
      <link>https://hjjae2.github.io/docs/BOOKS/Spring-Cloud%EB%A1%9C-%EA%B0%9C%EB%B0%9C%ED%95%98%EB%8A%94-%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98/%EC%84%B9%EC%85%983-Spring-Configuration-Service/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/Spring-Cloud%EB%A1%9C-%EA%B0%9C%EB%B0%9C%ED%95%98%EB%8A%94-%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98/%EC%84%B9%EC%85%983-Spring-Configuration-Service/</guid>
      <description>서버, 클라이언트 구성에 필요한 설정 정보(application.yml)를 외부 시스템에서 관리할 수 있다.
하나의 중앙화 된 저장소(GIT Repository, Secure Valut, Secure File Storage 등)에서 관리할 수 있다.
각 서비스를 다시 빌드하지 않고 바로 적용 가능하다.
애플리케이션 배포 파이프라인을 통해 DEV-STAGE-PROD 환경에 맞는 구성 정보로 사용 가능하다.
저장소로부터 Spring Cloud Config Server가 config 파일(값)을 가져와 각각의 service 에 전달해줄 수 있다.
Config Server # @SpringBootApplication @EnableConfigServer public class ConfigServiceApplication { ... } server: port: 8888 spring: application: name: config-service cloud: config: server: git: uri: file:///Users/leehyunjae/local-repository # spring.</description>
    </item>
    
    <item>
      <title>의존관계 주입</title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/%EC%9D%98%EC%A1%B4%EA%B4%80%EA%B3%84-%EC%A3%BC%EC%9E%85/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/%EC%9D%98%EC%A1%B4%EA%B4%80%EA%B3%84-%EC%A3%BC%EC%9E%85/</guid>
      <description>주입 방법 # 생성자 주입 # final OK (누락 X) 변경 가능성 X 최초 1번 실행 보장 생성자 1개 =&amp;gt; @Autowired 생략 가능 여러 개, 생략 불가능 세터 주입 # 생성자 이후에 처리 (= final X)
단점
Setter Open 변경 가능성 final X 선택적 (null OK) 필드 주입 # 생성자 이후에 처리 (= final X)
DI Framework 에 의존 테스트할 때, 주입해줄 수 없음. Setter 열어줘야함. final X 선택적 (null OK) * 단, 일부 테스트 코드에서는 OK 일반 메서드 주입 # 생성자 이후에 처리 (= final X)</description>
    </item>
    
    <item>
      <title>컨슈머 랙(Consumer Lag)</title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%95%84%ED%8C%8C%EC%B9%98-%EC%B9%B4%ED%94%84%EC%B9%B4-for-beginners/%EC%BB%A8%EC%8A%88%EB%A8%B8-%EB%9E%99Consumer-Lag/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%95%84%ED%8C%8C%EC%B9%98-%EC%B9%B4%ED%94%84%EC%B9%B4-for-beginners/%EC%BB%A8%EC%8A%88%EB%A8%B8-%EB%9E%99Consumer-Lag/</guid>
      <description>파티션에 데이터가 들어갈 때 offset 이라는 숫자가 붙게 된다. (0 부터 시작한다.)
컨슈머의 상태를 추측할 수 있음 (모니터링 지표)
각 파티션의 offset 기준으로, 컨슈머의 상태를 확인할 수 있도록 함 lag은 프로듀서 생산 속도(offset), 컨슈머 소비 속도(offset)의 차이를 기반으로 함
lag은 여러개가 될 수 있음 (파티션별로) records-lag-max : lag 값 중 가장 큰 값 컨슈머가 느리거나, 정상적으로 동작하지 않으면 lag 이 필연적으로 발생한다고 한다.
모니터링 애플리케이션, 카프카 버로우(Burrow) # 컨슈머 쪽에서 ELK, Grafana 쪽으로 데이터를 보내 확인할 수도 있으나, 컨슈머에 의존하게 되는 문제가 있다.</description>
    </item>
    
    <item>
      <title>토픽</title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%95%84%ED%8C%8C%EC%B9%98-%EC%B9%B4%ED%94%84%EC%B9%B4-for-beginners/%ED%86%A0%ED%94%BD/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%95%84%ED%8C%8C%EC%B9%98-%EC%B9%B4%ED%94%84%EC%B9%B4-for-beginners/%ED%86%A0%ED%94%BD/</guid>
      <description> TOPIC # (DB)Table, (FileSystem)Directory 와 비슷한 개념
&amp;lsquo;이름&amp;rsquo; 무슨 데이터를 갖는지 명확하게 네이밍 &amp;lsquo;파티션&amp;rsquo; consumer 가 partition 데이터를 읽어도 바로 삭제되지 않음 (중요) 데이터를 2번(혹은 여러 번) 소비해야할 때 유용, 중요한 특징 늘리는 것 가능 / 줄이는 것 불가능 파티션을 늘리고 컨슈머를 늘려 -&amp;gt; 데이터 처리를 분산 파티션 데이터 삭제 방식 일정 &amp;lsquo;시간&amp;rsquo; 이후 삭제 일정 &amp;lsquo;용량&amp;rsquo; 이후 삭제 </description>
    </item>
    
    <item>
      <title>파티셔너</title>
      <link>https://hjjae2.github.io/docs/BOOKS/%EC%95%84%ED%8C%8C%EC%B9%98-%EC%B9%B4%ED%94%84%EC%B9%B4-for-beginners/%ED%8C%8C%ED%8B%B0%EC%85%94%EB%84%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/%EC%95%84%ED%8C%8C%EC%B9%98-%EC%B9%B4%ED%94%84%EC%B9%B4-for-beginners/%ED%8C%8C%ED%8B%B0%EC%85%94%EB%84%88/</guid>
      <description>프로듀서가 데이터를 보냄 -&amp;gt; 파티셔너가 이를 처리
어떤 파티션에 데이터를 저장할 지 결정 파티셔너 따로 설정하지 않는다면, UniformStickyPartioner 로 설정 (이 방식은 아래와 같이 동작)
메시지 키가 있는 데이터에 대해서는 해쉬 값을 생성하여 파티션을 결정 동일한 메시지 키(해쉬 값)은 동일한 파티션에 들어감 메시지 키가 없는 레코드는 Round-Robin 다만 전통적인 RR 과 조금 다르다. Batch 단위로 동작한다(?) 사용자 지정 파티셔너도 사용 가능
CustomPartitional 인터페이스를 제공한다고 함 예시 # 파티셔너, 파티션 결정이 중요한 이유는 아래와 같은 예시로 사용 가능</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/AWS/OpenSearch/02.-%EB%82%B4%EB%B6%80-%EA%B5%AC%EC%A1%B0-%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%8A%A4%EC%BC%80%EC%9D%BC%EB%A7%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/AWS/OpenSearch/02.-%EB%82%B4%EB%B6%80-%EA%B5%AC%EC%A1%B0-%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%8A%A4%EC%BC%80%EC%9D%BC%EB%A7%81/</guid>
      <description>OpenSearch 구조 # 파란색 부분(Index, Shard)에 대해서만 이해하고 있다면 일반적인 사용에서 문제가 없다. 초록색 부분(Lucene Index, Segment)는 깊은 사용, 성능 최적화 등을 위해 이해해야 하는 부분이다. Shard # 영상에서, 샤드 = 물리적인 노드 1대1 대응해서 설명하는 것 같다.
즉, 아래 그림은 각각의 물리적인 노드 위에 각 샤드가 있는 것을 가정한다.
샤드의 수 = 데이터 노드(or AZ) x N Replica 수 = AZ x N Index 디자인 # Index 패턴 # 패턴 설명 Rolling Index - 인덱스 기간, 보존 기간이 있고 계속적으로 데이터가 흘러 들어오는 경우 - 오래된 Index 는 보유 기간에 따라 Warm/Cold 계층으로 마이그레이션, 삭제 가능 - search-logs-2022, weblogs-2022-07, &amp;hellip; Long-Term Retention Index - 같은 Index에 소스 데이터 저장</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/AWS/OpenSearch/03.-5xx-Error-with-Scaling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/AWS/OpenSearch/03.-5xx-Error-with-Scaling/</guid>
      <description>SysMemoryUtilization 값이 90%를 초과하는 것은 이슈가 있는 것은 아니고, FreeStorageSpace, JVMMemoryPressure, CPUUilization 값을 확인해보아야 한다.
5xx 에러가 발생했을 경우 아래 부분을 의심해볼 수 있다.
확인 사항 1. 스토리지 가용 공간 확인 # 아래에 해당되는 경우 (1) 인스턴스 타입을 변경하거나 (2) EBS 볼륨을 늘리거나 (3) 인스턴스를 추가할 수 있다.
가용 공간이 노드 스토리지의 20% or 20GB 미만인지 확인한다. ISM 통해 스냅샷 저장 후 불필요한 데이터는 삭제한다. Lack of available storage space If one or more nodes in your cluster has less than 20% of available storage space, or less than 20 GB of storage space, basic write operations like adding documents and creating indexes can start to fail.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/AWS/01.-API-Gateway/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/AWS/01.-API-Gateway/</guid>
      <description>What is Amazon API Gateway? # Amazon API Gateway is an AWS service for creating, publishing, maintaining, monitoring, and securing REST, HTTP, and WebSocket APIs at any scale.
API developers can create APIs that access AWS or other web services, as well as data stored in the AWS Cloud.
As an API Gateway API developer, you can create APIs for use in your own client applications. Or you can make your APIs available to third-party app developers.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/AWS/02.-Batch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/AWS/02.-Batch/</guid>
      <description>Launch Template # AWS Batch only updates the launch template with a new launch template version during infrastructure updates. For more information, see Updating compute environments.
Q1. launch template 지정 시 해당 launch template 을 (직접적으로)사용하는 것인지 테스트 필요하다. (단순히 설정 정보를 읽어오는 정도(import)로만 사용하고, 별도 launch template 이 생성되는 건지)
A1. launch template 을 지정해도, (batch 에 의해)별도 launch template 이 생성되는 것을 확인했다.
Launch template 버전 변경이 필요한 경우 # create-compute-environment 문서에 나와있다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/AWS/03.-Cloud-Formation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/AWS/03.-Cloud-Formation/</guid>
      <description>What is AWS CloudFormation? # 요약: IaC를 위한 서비스다.
AWS resources 를 관리(모델링, 셋업 등)할 수 있는 서비스이다.
1. CloudFormation Template 을 생성한다.
템플릿 : AWS 리소스 명시 Json, Yaml 포맷 지원 참고 2. CloudFormation 은 템플릿을 기반으로 리소스를 프로비저닝하고 구성한다.
You create a template that describes all the AWS resources that you want (like Amazon EC2 instances or Amazon RDS DB instances), and CloudFormation takes care of provisioning and configuring those resources for you.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/AWS/04.-Elastic-Beanstalk/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/AWS/04.-Elastic-Beanstalk/</guid>
      <description>Elastic Beanstalk 에 대한 기본 개념은 어렵지 않고 문서에 잘 설명이 되있어서 문서만 참고해도 좋을 듯 하다.
What is AWS Elastic Beanstalk? # Elastic Beanstalk를 사용하면 애플리케이션을 실행하는 인프라에 대해 자세히 알지 못해도 AWS 클라우드에서 애플리케이션을 신속하게 배포하고 관리할 수 있습니다. Elastic Beanstalk를 사용하면 선택 또는 제어에 대한 제한 없이 관리 복잡성을 줄일 수 있습니다. 애플리케이션을 업로드하기만 하면 Elastic Beanstalk에서 용량 프로비저닝, 로드 밸런싱, 조정, 애플리케이션 상태 모니터링에 대한 세부 정보를 자동으로 처리합니다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/AWS/05.-Glue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/AWS/05.-Glue/</guid>
      <description>What is AWS Glue? # 완전 관리형(=서버 리스) ETL(extract, transform, load) 서비스
(데이터를) 카테고라이징, 정리, 보강 (데이터를) 다양한 data store, data stream 간 이동 Glue 구성 요소
Central metadata repository (= Data Catalog) ETL engine (= python, scala code 등을 자동으로 생성하는 ETL Engine) Scheduler (= 의존성을 핸들링하고, Job monitoring, retry 를 처리할 수 있는 유연한 스케줄러) Glue 특징
semi-structured data(반구조화된 데이터)와 함께 처리되도록 설계되었다. ETL 스크립트를 사용할 수 있는 dynamic frame(동적 프레임) 이라는 컴포넌트(?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/AWS/06.-IAM/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/AWS/06.-IAM/</guid>
      <description>IAM # AWS Identity and Access Management(IAM)는 AWS 리소스에 대한 access를 안전하게 제어할 수 있는 웹서비스이다.
Entity(User, Group, Role)에 Policy를 적용해서 AWS 리소스(EC2, S3, RDS, &amp;hellip;) 에 대한 접근을 관리한다.
Keyword : User, Group, Role, Policy
Terms # IAM Resources # user, group, role, policy, identity provider objects
IAM identities # identify(식별), group(그룹화)에 사용되는 IAM resource object
IAM identity 에 policy(정책)을 연결(부여)할 수 있다. ex : users, groups, roles IAM Entities # authentication(인증)을 위해 사용하는 IAM resource object</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/AWS/07.-VPC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/AWS/07.-VPC/</guid>
      <description>https://www.44bits.io/ko/post/understanding_aws_vpc 내용입니다.
&amp;quot; Amazon Virtual Private Cloud(VPC)를 사용하면 AWS 클라우드에서 논리적으로 격리된 공간을 프로비저닝하여 고객이 정의하는 가상 네트워크에서 AWS 리소스를 시작할 수 있습니다. IP 주소 범위 선택, 서브넷 생성, 라우팅 테이블 및 네트워크 게이트웨이 구성 등 가상 네트워킹 환경을 완벽하게 제어할 수 있습니다. VPC에서 IPv4와 IPv6를 모두 사용하여 리소스와 애플리케이션에 안전하고 쉽게 액세스할 수 있습니다. – 아마존 버추얼 프라이빗 클라우드(Amazon Virtual Private Cloud) &amp;ldquo;
AWS에서는 AWS계정을 생성할 때 리전 별로 기본 VPC를 함께 생성해준다.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://hjjae2.github.io/docs/SPRING/SPRING-Spring-Cache/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/SPRING/SPRING-Spring-Cache/</guid>
      <description>참고 # https://docs.spring.io/spring-framework/docs/6.0.4/reference/html/integration.html#cache https://docs.spring.io/spring-boot/docs/current/reference/html/io.html Caching (from spring-boot docs) # &amp;quot; You can also use the standard JSR-107 (JCache) annotations (such as @CacheResult) transparently. However, we strongly advise you to not mix and match the Spring Cache and JCache annotations. &amp;quot;
Spring Cache 어노테이션과 JCache 어노테이션을 혼합하여 사용하지 않는다.
&amp;quot; If you do not add any specific cache library, Spring Boot auto-configures a simple provider that uses concurrent maps in memory.</description>
    </item>
    
    <item>
      <title>스타일 (1)</title>
      <link>https://hjjae2.github.io/docs/BOOKS/IOS-Android-%EC%95%B1-%EA%B0%9C%EB%B0%9C%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%8B%A4%EC%A0%84-React-Native-Basic/%EC%8A%A4%ED%83%80%EC%9D%BC-1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://hjjae2.github.io/docs/BOOKS/IOS-Android-%EC%95%B1-%EA%B0%9C%EB%B0%9C%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%8B%A4%EC%A0%84-React-Native-Basic/%EC%8A%A4%ED%83%80%EC%9D%BC-1/</guid>
      <description> Style 방식 # 1. inline
&amp;lt;View style={{...}}&amp;gt; ... &amp;lt;/View&amp;gt; 2. StyleSheet
&amp;lt;View style={styles.mainView}&amp;gt; ... &amp;lt;/View&amp;gt; ... const styles = StyleSheet.create({ mainView: { .... } }) </description>
    </item>
    
  </channel>
</rss>
