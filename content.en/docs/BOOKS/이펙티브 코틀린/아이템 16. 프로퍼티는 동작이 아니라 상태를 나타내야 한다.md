---
type: 'docs'
title: ""
bookFlatSection: true
bookCollapseSection: false
bookHidden: false
bookToC: true
bookComments: false
bookSearchExclude: false
bookFlatSection: true
weight: 1
---

## 프로퍼티는 동작이 아니라 상태를 나타내야 한다.

코틀린의 프로퍼티는 자바의 필드랑 비슷해 보이지만, **서로 완전히 다른 개념이다.**

둘 다 데이터를 저장한다는 점은 같다. 하지만 프로퍼티에는 더 많은 기능이 있다.

### 프로퍼티

1. 사용자 정의 getter/setter 가질 수 있다.
   1. **val 프로퍼티에는 백킹 필드가 만들어지지 않는다.**
2. 필드가 필요 없다. **프로퍼티는 개념적으로 '접근자'를 나타낸다.**
   1. **따라서 코틀린에서는 인터페이스에서도 프로퍼티를 정의할 수 있다.** (아래 '예시 1' 참고)
3. 위임(property delegate)할 수 있다.
4. 프로퍼티는 본질적으로 **함수**이다. 
   1. 확장 프로퍼티를 만들 수 있다.
   2. 프로퍼티를 함수 대신 사용할 수도 있지만, 그렇다고 완전히 대체해서 사용하는 것은 좋지 않다. (아래 '예시 2' 참고)

```kotlin
// 예시 1. 인터페이스에서도 프로퍼티를 정의할 수 있다.
interface Person {
    val name: String // getName() (getter)
}
```

```kotlin
// 예시 2. 함수를 완전히 대체하는 것은 좋지 않다.
// 이유 : 관습적으로 게터에 알고리즘, (무거운)계산 등의 로직이 들어갈 것이라고 생각하지 않는다.
val Tree<Int>.sum: Int
    get() = when(this) {
        is Leaf -> value
        is Node -> left.sum + right.sum
    }
```

<br>

**원칙적으로 프로퍼티는 상태(state)를 표현하거나 설정하기 위한 목적으로만 사용하는 것이 좋다. 다른 로직 등을 포함하지 않는 것이 좋다.**

> ㄴ 이런 관점에서는 '필드'처럼 사용되는 것 같다.

> *" 많은 사람은 경험적으로 프로퍼티는 상태 집합을 나타내고, 함수는 행동을 나타낸다고 생각한다. "*
> 
> 이전 장에서 본 인식 부하 감소(인지 부하 감소) 내용을 기억해보면, 충분히 이해된다.