---
type: 'docs'
title: "03. Key-Value Store 설계"
bookFlatSection: true
bookCollapseSection: false
bookHidden: false
bookToC: true
bookComments: false
bookSearchExclude: false
bookFlatSection: true
weight: 1
---

# Key-Value Store

> 대표적인 예시 : amazon dynamodb, memcached, redis, ...

Key 는 유일해야 한다.
- Key 는 짧을수록 성능 상 유리하다.

Value 는 Key를 통해서만 접근할 수 있다.
Value 는 다양한 자료구조(문자열, 리스트, 객체)일 수 있다.


완벽한 설계란 없다. READ(일기), WRITE(쓰기), MEMORY USAGE(메모리 사용량) 사이에 균형(balance)을 찾고 데이터의 일관성, 가용성 사이에서 타협적 결정을 내려야 한다.

<br>

## 단일 서버 Key-Value Store

한 대의 서버만 사용하는 Key-Value Store를 설계하는 것은 쉽다. 가장 직관적으로 (인메모리)해시 테이블에 저장하면 된다. 다만, 메모리가 부족해질 수 있은이 다음 요소를 고려해볼만 할 것이다.

- 데이터 압축 (compression)
- 자주 사용되는 데이터만 메모리에 저장, 나머지는 디스크에 저장

그러나 단일 서버의 특성 상 금방 한계가 찾아온다.

> 분산 Key-Value Store 를 고려하자.

<br>

## 분산 Key-Value Store

분산 Key-Value 저장소는 '분산 해시 테이블'이라고도 불린다.

분산 Key-Value 저장소는 Key-Value 쌍을 여러 서버에 분산시키는 것이다. 

분산 시스템을 설계할 때는 CAP(Consistency, Availability, Partition tolerance theorem)를 이해해야한다.

<br>

### CAP 정리

**CAP 정리는 (C, A, P)세 가지 요구사항을 동시에 만족하는 분산 시스템을 설계하는 것은 불가능하다는 정리다.** (이들 중 두 가지를 충족하려면 나머지 하나는 반드시 희생되어야 한다.)

|요구사항|설명|
|-|-|
|C (consistency, 일관성)|분산 시스템을 사용하는 모든 클라이언트는 어떤 노드에 접속하더라도 언제나 같은(일관성 있는)데이터를 사용/볼 수 있어야 한다.|
|A (Availability, 가용성)|일부 노드에 장애가 발생하더라도 항상 정상 처리(응답)될 수 있어야 한다.|
|P (Partition tolerance, 파티션 허용/내성)|네트워크에 파티션이 생기더라도 시스템은 계속 동작하여야 한다. <br><br>* 파티션은 두 노드 사이에 통신 장애가 발생했음을 의미한다.|

<br>

Key-Value 저장소는 어떤 두 가지를 만족시키느냐에 따라 다음과 같이 분류할 수 있다.

|시스템|설명|
|-|-|
|CP 시스템|일관성, 파티션 허용을 지원하는 Key-Value 저장소. <br><br>가용성을 희생한다.|
|CA 시스템|일관성, 가용성을 지원하는 Key-Value 저장소. <br><br>파티션 허용을 희생한다. <br><br>**통상 네트워크 장애는 피할 수 없는 일로 여겨지므로, 분산 시스템은 반드시 파티션 문제를 감내할 수 있도록 설계되어야 한다.<br>그러므로 실세계에 CA 시스템은 존재하지 않는다.**|
|AP 시스템|가용성, 파티션 허용을 지원하는 Key-Value 저장소. <br><br>일관성을 희생한다.|

<br><br>

### 분산 시스템에서의 CAP 예시

서로 연결되어 있는, 복제되고 있는 n1, n2, n3 노드가 있다.

```text
          n1
          |
          |
          |
n2 ----------------- n3
```

이때, n3 노드에서 장애가 발생했다. n1-n3, n2-n3 사이에 파티션이 발생했다.<br>
(= n3의 최신 데이터가 n1과 n2에 제대로 반영되지 않았다고 가정하자.)

이 상황에서 우리의 분산 시스템은 일관성, 가용성 중 하나를 선택해야 한다.

<br>

**일관성 선택 (= CP 시스템)**

일관성을 선택했다면, n1, n2 의 쓰기/읽기 연산을 중지해야 한다. 이유는 n3의 최신 데이터가 n1, n2에 반영되지 않았을테니까. 최신 데이터로 업데이트 될 때까지 클라이언트에게 데이터를 제공할 수 없다. (즉, 가용성이 깨진다.)

흔한 예시로, 은행권 시스템은 일관성을 우선적으로 지킨다.

<br>

**가용성 선택 (= AP 시스템)**

최신 데이터가 아닌, 오래된 데이터를 제공하더라도 n1, n2 노드에서는 연산을 허용한다. 

파티션 문제가 해결된 뒤 n1-n3, n2-n3 사이의 동기화가 이뤄질 것이다.

<br><br>

## Key-Value Store 시스템 컴포넌트

Key-Value Store 에 사용되는 핵심 컴포넌트들을 살펴보자.

- 데이터 파티션
- Replication (데이터 다중화)
- Consistency (데이터 일관성)
- Inconsistency resolution (일관성 불일치 해소)
- 장애 처리
- 시스템 아키텍처 다이어그램
- 쓰기 경로 (write path)
- 읽기 경로 (read path)

### 시스템 컴포넌트 : 데이터 파티션

> *위에서 잠깐 언급했지만, 대규모 애플리케이션의 경우 전체 데이터를 한 대의 서버에서 처리하는 것은 한계가 있다. 해결책은 데이터들을 작은 파티션들로 분할하여 여러 대의 서버에 저장하는 것이다. (= 분산 시스템)*

데이터를 파티션 단위로 나눌 때, 다음 두 가지를 중요하게 따져봐야 한다.

1. 데이터를 여러 서버에 고르게 분산할 수 있는가?
2. 노드가 추가되거나 삭제될 때 데이터의 이동(리밸런싱)을 최소화할 수 있는가?

(계속)